<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="假装是个程序员"><title>Java中的输入/输出流 | 子善</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java中的输入/输出流</h1><a id="logo" href="/.">子善</a><p class="description">假装是个程序员</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java中的输入/输出流</h1><div class="post-meta">Feb 15, 2016<span> | </span><span class="category"><a href="/categories/Java-Core/">Java-Core</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#u5B57_u8282_u6D41_uFF08InputSteam_uFF09"><span class="toc-number">1.</span> <span class="toc-text">字节流（InputSteam）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u5B57_u7B26_u6D41_uFF08Reader_uFF09"><span class="toc-number">2.</span> <span class="toc-text">字符流（Reader）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Reader"><span class="toc-number">2.1.</span> <span class="toc-text">Reader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InputStreamReader"><span class="toc-number">2.2.</span> <span class="toc-text">InputStreamReader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FileReader"><span class="toc-number">2.3.</span> <span class="toc-text">FileReader</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u7F13_u51B2_u6D41_uFF08Buffered_Stream_uFF09"><span class="toc-number">3.</span> <span class="toc-text">缓冲流（Buffered Stream）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Scanning"><span class="toc-number">4.</span> <span class="toc-text">Scanning</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#u6784_u6210_u65B9_u6CD5_uFF1A"><span class="toc-number">4.1.</span> <span class="toc-text">构成方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u4E3B_u8981_u65B9_u6CD5"><span class="toc-number">4.2.</span> <span class="toc-text">主要方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PrintStream"><span class="toc-number">5.</span> <span class="toc-text">PrintStream</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#u6784_u9020_u65B9_u6CD5_uFF1A"><span class="toc-number">5.1.</span> <span class="toc-text">构造方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u4E3B_u8981_u65B9_u6CD5-1"><span class="toc-number">5.2.</span> <span class="toc-text">主要方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PrintWriter"><span class="toc-number">6.</span> <span class="toc-text">PrintWriter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u6807_u51C6_u6D41"><span class="toc-number">7.</span> <span class="toc-text">标准流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Console"><span class="toc-number">8.</span> <span class="toc-text">Console</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u6570_u636E_u6D41_uFF08DataStream_uFF09"><span class="toc-number">9.</span> <span class="toc-text">数据流（DataStream）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u5BF9_u8C61_u6D41_uFF08Object_Stream_uFF09"><span class="toc-number">10.</span> <span class="toc-text">对象流（Object Stream）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#u590D_u6742_u5BF9_u8C61_u7684_u8F93_u5165_u6D41_u4E0E_u8F93_u51FA_u6D41"><span class="toc-number">10.1.</span> <span class="toc-text">复杂对象的输入流与输出流</span></a></li></ol></li></ol></div></div><div class="post-content"><p>流（Stream）是java中输入和输出经常涉及也是最简单的概念。Java中存在各种各样的流，字符流、字节流、缓存流、基本数据流、对象流等。Java持久化中谈及的序列化与反序列化同样离不开流（将整个对象写入流中，并可以从流中获取整个对象）。</p>
<a id="more"></a>
<h2 id="u5B57_u8282_u6D41_uFF08InputSteam_uFF09"><a href="#u5B57_u8282_u6D41_uFF08InputSteam_uFF09" class="headerlink" title="字节流（InputSteam）"></a>字节流（InputSteam）</h2><p>常见的有<code>FileInputSteam</code>，主要用于读取原生的字节流，如图片。如果想要读取关于字符的字节流可以使用<code>FileReader</code>。</p>
<h2 id="u5B57_u7B26_u6D41_uFF08Reader_uFF09"><a href="#u5B57_u7B26_u6D41_uFF08Reader_uFF09" class="headerlink" title="字符流（Reader）"></a>字符流（Reader）</h2><h3 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a><code>Reader</code></h3><p>所有的字符流都继承于Reader，它包含一个同步锁<code>lock</code>，默认是将自己作为一锁。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Reader</span> <span class="keyword">implements</span> <span class="title">Readable</span>, <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用于同步流</span></span><br><span class="line">    <span class="keyword">protected</span> Object lock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Reader</span><span class="params">(Object lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lock == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a><code>InputStreamReader</code></h3><p>InputStreamReader是从字节流到字符流的桥连接。它读取字节并将其编码成相应<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html" target="_blank" rel="external">字符集</a>的字符。字符集可以用指定的名称、或具体的字符集对象或者系统默认的字符集。</p>
<p>其实现是通过<code>StreamDecoder</code>的forInputStreamReader方法进行编码。<code>read()</code>方法同样委托给<code>StreamDecoder</code>。</p>
<h3 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a><code>FileReader</code></h3><p>继承于In继承putStreamReader，其实现是通过<code>FileInputSteam</code>创建字节流然后通过桥连接构造<code>StreamDecoder</code>，其读方法均由<code>InputStreamReader</code>实现（委托给<code>StreamDecoder</code>）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStreamReader</span> <span class="keyword">extends</span> <span class="title">Reader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InputStreamReader</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(in);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sd = StreamDecoder.forInputStreamReader(in, <span class="keyword">this</span>, (String)<span class="keyword">null</span>); <span class="comment">// check lock object</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="comment">// The default encoding should always be available</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sd.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReader</span> <span class="keyword">extends</span> <span class="title">InputStreamReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileReader</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> FileInputStream(fileName));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u7F13_u51B2_u6D41_uFF08Buffered_Stream_uFF09"><a href="#u7F13_u51B2_u6D41_uFF08Buffered_Stream_uFF09" class="headerlink" title="缓冲流（Buffered Stream）"></a>缓冲流（Buffered Stream）</h2><p>对于无缓冲的I/O操作，每次写或者读请求都会直接作用于操作系统，如硬盘访问、网络访问等代价非常昂贵的操作。 缓冲流的引入就是为了提升常规I/O操作的效率。</p>
<p>缓冲输入流是从一块缓冲的内容中读取数据，只有当缓冲区没有数据时才会调用操作系统的API获取一整块的数据，然后放入缓冲区以供程序读取。同样，缓冲输出流每次向缓冲区写入数据，只有当缓冲区被写满后才会调用操作系统的API将数据真正写入目标位置。</p>
<ul>
<li><p><a href="https://docs.oracle.com/javase/8/docs/api/java/io/BufferedInputStream.html" target="_blank" rel="external">BufferedInputStream</a>、<a href="https://docs.oracle.com/javase/8/docs/api/java/io/BufferedOutputStream.html" target="_blank" rel="external">BufferedOutputStream</a>：用于创建缓冲的字节流<br><strong> 分别继承于<code>FilterInputStream</code>和<code>FilterOutputStream</code>，本身字节流成员。
</strong> 必须使用字节流构造，并可以指定缓存区大小。</p>
</li>
<li><p><a href="https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html" target="_blank" rel="external">BufferedReader</a>、<a href="https://docs.oracle.com/javase/8/docs/api/java/io/BufferedWriter.html" target="_blank" rel="external">BufferedWriter</a>：用于创建缓冲的字符流</p>
</li>
</ul>
<h2 id="Scanning"><a href="#Scanning" class="headerlink" title="Scanning"></a>Scanning</h2><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html" target="_blank" rel="external">Scanner</a>，一个文本扫描工具，使用正则表达式解析基本数据类型和<code>String</code>类型。<code>Scanner</code>可以使用分隔符将输入数据分割成诸多片段，默认的分隔符为<em>whitespace</em>（参见<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isWhitespace-char-" target="_blank" rel="external">Character.isWhitespace</a>)。可以使用不同<code>next</code>方法将这些片段转化成不同的数据类型。</p>
<h3 id="u6784_u6210_u65B9_u6CD5_uFF1A"><a href="#u6784_u6210_u65B9_u6CD5_uFF1A" class="headerlink" title="构成方法："></a>构成方法：</h3><ul>
<li>字符流：<code>Readable</code>接口。比如继承于<code>Reader</code>的所有类，<code>FileReader</code>等。</li>
<li><p>字节流：<code>InputStream</code>，支持自定义charset。其实现是将<em>字节流转化为字符流</em>，使用字符流构造。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Scanner</span><span class="params">(InputStream source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> InputStreamReader(source), WHITESPACE_PATTERN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>字节可读管道：<code>ReadableByteChannel</code>，比如对应文件的管道<code>FileChannel</code>。</p>
</li>
<li>文件：<code>File</code>，支持自定义charset。其实现是构造<code>FileInputStream</code>，获取文件管道<code>FileChannel</code>，然后使用字节可读管道构造。</li>
<li>文件路径：<code>Path</code>，支持自定义charset。其实现是获取文件的字节流，然后构造字符流。</li>
<li>字符串：<code>String</code>。其实现是构造<code>StringReader</code>，然后构造字符流。</li>
</ul>
<h3 id="u4E3B_u8981_u65B9_u6CD5"><a href="#u4E3B_u8981_u65B9_u6CD5" class="headerlink" title="主要方法"></a>主要方法</h3><ul>
<li><code>hasNext、next</code>：不仅支持基础类型，还支持<code>BigDecimal</code>、<code>BigInteger</code>以及<code>nextLine</code>。这两个方法都会阻塞（block）等待输入。</li>
<li><code>useDelimiter</code>：自定义分隔符。</li>
<li><code>reset</code>：重置分隔符为<em>whitespace</em>。</li>
</ul>
<h2 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a><a href="https://docs.oracle.com/javase/8/docs/api/java/io/PrintStream.html" target="_blank" rel="external">PrintStream</a></h2><ul>
<li>异常：不会抛<code>IOException</code>，但是内部会有相应的标记，可以通过<code>checkError</code>来检查。</li>
<li>自动flush：当写入一个字节数组、或者调用<code>println</code>方法、或者写入换行符<code>\n</code>时会自动flush。</li>
</ul>
<p><em>注意</em>： 通过<em>PrintStream</em>打印的字符均会根据平台默认的字符编码被转成字节。</p>
<h3 id="u6784_u9020_u65B9_u6CD5_uFF1A"><a href="#u6784_u9020_u65B9_u6CD5_uFF1A" class="headerlink" title="构造方法："></a>构造方法：</h3><p>支持字节流、文件、文件名进行构造。使用字节流构造时，可自定义是否自动flush，默认为<code>false</code>。使用文件名或文件时，不可自定义，默认也为<code>false</code>。</p>
<p>相应的，用于处理字符的类为<a href="https://docs.oracle.com/javase/8/docs/api/java/io/PrintWriter.html" target="_blank" rel="external">PrintWriter</a>。一般情况下直接使用<code>PrintWriter</code>。</p>
<h3 id="u4E3B_u8981_u65B9_u6CD5-1"><a href="#u4E3B_u8981_u65B9_u6CD5-1" class="headerlink" title="主要方法"></a>主要方法</h3><ul>
<li><code>format(String format, Object... args)</code><br>类似C语言，格式化输入源数据。具体语法参考<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax" target="_blank" rel="external">Formatter</a>。</li>
</ul>
<h2 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="PrintWriter"></a><a href="https://docs.oracle.com/javase/8/docs/api/java/io/PrintWriter.html" target="_blank" rel="external">PrintWriter</a></h2><p>跟<code>PrintStream</code>类似，也是用于格式化输出。并且实现了所有<code>PrintStream</code>的方法。但自动flush时有点不同：不再直接检查被写入的是否为换行符<code>\n</code>，而是检查是否为当前平台的换行符。</p>
<p>支持字节流（OutStream）、字符流（Writer）、文件名、文件（File）进行构造。特别的，除了字节流构造意外，其他实现均为会转化成缓存字符流（<code>BufferedWriter</code>）。</p>
<h2 id="u6807_u51C6_u6D41"><a href="#u6807_u51C6_u6D41" class="headerlink" title="标准流"></a>标准流</h2><p>标准输入流：<code>System.in</code>。<br>标准输出流：<code>System.out</code>，<code>System.error</code>。</p>
<p>因为历史原因，这些标准流均为<em>字节流</em>，而非字符流。需要转化时可以通过<code>InputStreamReader</code>进行转化，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStreamReader cin = <span class="keyword">new</span> InputStreamReader(System.in)</span><br></pre></td></tr></table></figure>
<h2 id="Console"><a href="#Console" class="headerlink" title="Console"></a>Console</h2><p><code>Console</code>是更强大的标准流，同时提供了输入流和输出流，并且是字符流。还有一个安全特性是针对密码输入时设计。</p>
<ul>
<li>无public构造函数：使用时，通过System获取，<code>System.console()</code>。</li>
<li>readPassword：返回一个字符（char）数组，不再使用时可以将其重写置空，从内存中删除。</li>
</ul>
<h2 id="u6570_u636E_u6D41_uFF08DataStream_uFF09"><a href="#u6570_u636E_u6D41_uFF08DataStream_uFF09" class="headerlink" title="数据流（DataStream）"></a>数据流（DataStream）</h2><p>对输入/输出字节流的包装，方便程序中输入/输出基本类型以及String。</p>
<p>因为DataStream操作的是字节流，所以在使用时可以使用缓存流<code>BufferedInputStream</code>和<code>BufferedOutputStream</code>。</p>
<p>与其他流不同的地方是检测输入结束的条件，它是通过catch<code>EOFException</code>，而不是检测返回值，参见一下具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span> <span class="title">readByte</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ch = in.read();</span><br><span class="line">    <span class="keyword">if</span> (ch &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">byte</span>)(ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u5BF9_u8C61_u6D41_uFF08Object_Stream_uFF09"><a href="#u5BF9_u8C61_u6D41_uFF08Object_Stream_uFF09" class="headerlink" title="对象流（Object Stream）"></a>对象流（Object Stream）</h2><p>对象流包括<code>ObjectInputSteam</code>和<code>ObjectOutputStream</code>，实现的接口分别为<code>ObjectInput</code>和<code>ObjectOutput</code>（继承于数据流接口<code>DataInput</code>）。这也意味着在数据流中所有基本数据类型相关的方法，在对象流中都有相应的实现。</p>
<p><code>ObjectInputSteam</code>用来反序列化那些用<code>ObjectOutputStream</code>序列化的基本数据类型和对象。而<code>ObjectOutputStream</code>则是一种将对象持久化的方法。</p>
<h3 id="u590D_u6742_u5BF9_u8C61_u7684_u8F93_u5165_u6D41_u4E0E_u8F93_u51FA_u6D41"><a href="#u590D_u6742_u5BF9_u8C61_u7684_u8F93_u5165_u6D41_u4E0E_u8F93_u51FA_u6D41" class="headerlink" title="复杂对象的输入流与输出流"></a>复杂对象的输入流与输出流</h3><ul>
<li>当一个对象引用了其他对象时，其所有引用都会被写入流中。</li>
<li>当多个对象引用了同一个对象时，被引用的对象在流中只会存在一份。</li>
</ul>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://www.xiaoyuxee.com/2016/02/15/basic-IO-in-java/" data-id="cixags3ls0024l966qxl1qjqj" class="article-share-link">分享到</a><div class="tags"><a href="/tags/IO/">IO</a></div><div class="post-nav"><a href="/2016/03/11/nio-in-java/" class="pre">Java中的NIO</a><a href="/2016/02/06/aggregate-operation-in-java8/" class="next">Java8中的Stream</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://www.xiaoyuxee.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java-Core/">Java-Core</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network/">Network</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活随笔/">生活随笔</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/目标管理/">目标管理</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/ThreadPool/" style="font-size: 15px;">ThreadPool</a> <a href="/tags/ClassLoader/" style="font-size: 15px;">ClassLoader</a> <a href="/tags/Concurrency/" style="font-size: 15px;">Concurrency</a> <a href="/tags/Thread/" style="font-size: 15px;">Thread</a> <a href="/tags/Synchronizer/" style="font-size: 15px;">Synchronizer</a> <a href="/tags/Synchronization/" style="font-size: 15px;">Synchronization</a> <a href="/tags/TCP-IP/" style="font-size: 15px;">TCP/IP</a> <a href="/tags/NIO/" style="font-size: 15px;">NIO</a> <a href="/tags/个人计划/" style="font-size: 15px;">个人计划</a> <a href="/tags/Liveness/" style="font-size: 15px;">Liveness</a> <a href="/tags/Lambda/" style="font-size: 15px;">Lambda</a> <a href="/tags/Java8/" style="font-size: 15px;">Java8</a> <a href="/tags/Channel/" style="font-size: 15px;">Channel</a> <a href="/tags/Wiring-Beans/" style="font-size: 15px;">Wiring-Beans</a> <a href="/tags/JDBC/" style="font-size: 15px;">JDBC</a> <a href="/tags/Srping-MVC/" style="font-size: 15px;">Srping-MVC</a> <a href="/tags/Eclipse/" style="font-size: 15px;">Eclipse</a> <a href="/tags/IO/" style="font-size: 15px;">IO</a> <a href="/tags/Aggregate-Operation/" style="font-size: 15px;">Aggregate-Operation</a> <a href="/tags/Stream/" style="font-size: 15px;">Stream</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/05/01/port-of-tcp/">TCP中的端口号</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/27/understanding-classloader/">Java中的ClassLoader</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/07/executor-in-java-concurrency/">Java中的多线程（五）：ThreadPoolExecutor框架源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/31/synchronizer-in-java-concurrency/">Java中的多线程（四）：同步器</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/16/liveness-in-java-concurrency/">Java中的多线程（三）：活跃度</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/15/synchronization-in-java-concurrency/">Java中的多线程（二）：同步机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/15/base-in-java-concurrency/">Java中的多线程（一）：线程的基本概念和使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/13/in-depth-understanding-of-channel-in-nio/">深入理解NIO中的Channel</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/11/nio-in-java/">Java中的NIO</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/15/basic-IO-in-java/">Java中的输入/输出流</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">子善.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>