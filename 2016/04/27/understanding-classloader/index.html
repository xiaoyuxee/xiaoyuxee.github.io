<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="假装是个程序员"><title>Java中的ClassLoader | 子善</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java中的ClassLoader</h1><a id="logo" href="/.">子善</a><p class="description">假装是个程序员</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java中的ClassLoader</h1><div class="post-meta">Apr 27, 2016<span> | </span><span class="category"><a href="/categories/Java-Core/">Java-Core</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2016/04/27/understanding-classloader/" href="/2016/04/27/understanding-classloader/#disqus_thread" class="disqus-comment-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#u4EC0_u4E48_u662F_u7C7B_u52A0_u8F7D_u5668"><span class="toc-number">1.</span> <span class="toc-text">什么是类加载器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u7C7B_u52A0_u8F7D_u7684_u7C7B_u578B"><span class="toc-number">2.</span> <span class="toc-text">类加载的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#u542F_u52A8_u7C7B_u52A0_u8F7D_u5668_uFF08Bootstrap_ClassLoader_uFF09"><span class="toc-number">2.1.</span> <span class="toc-text">启动类加载器（Bootstrap ClassLoader）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u6269_u5C55_u7C7B_u52A0_u8F7D_u5668_uFF08ExtClassLoader_uFF09"><span class="toc-number">2.2.</span> <span class="toc-text">扩展类加载器（ExtClassLoader）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u5E94_u7528_u7A0B_u5E8F_u7C7B_u52A0_u8F7D_u5668_uFF08SCL_uFF09"><span class="toc-number">2.3.</span> <span class="toc-text">应用程序类加载器（SCL）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ClassLoader_u6784_u9020_u65B9_u6CD5"><span class="toc-number">3.</span> <span class="toc-text">ClassLoader构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u7C7B_u52A0_u8F7D_u7684_u751F_u547D_u5468_u671F"><span class="toc-number">4.</span> <span class="toc-text">类加载的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#u52A0_u8F7D_uFF08Loading_uFF09"><span class="toc-number">4.1.</span> <span class="toc-text">加载（Loading）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u521D_u59CB_u5316_u65F6_u673A"><span class="toc-number">4.2.</span> <span class="toc-text">初始化时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26lt_3Bclinit_26gt_3B_28_29_u65B9_u6CD5"><span class="toc-number">4.3.</span> <span class="toc-text"><clinit>()方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u5982_u4F55_u52A0_u8F7DClass"><span class="toc-number">5.</span> <span class="toc-text">如何加载Class</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u53CC_u4EB2_u59D4_u6D3E_u6A21_u578B"><span class="toc-number">6.</span> <span class="toc-text">双亲委派模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#u201C_u7834_u574F_u5386_u53F2_u201D"><span class="toc-number">6.1.</span> <span class="toc-text">“破坏历史”</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK1-2_u4E4B_u524D"><span class="toc-number">6.1.1.</span> <span class="toc-text">JDK1.2之前</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u7EBF_u7A0B_u4E0A_u4E0B_u6587_u7C7B_u52A0_u8F7D_u5668"><span class="toc-number">6.1.2.</span> <span class="toc-text">线程上下文类加载器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u52A8_u6001_u5316_u6A21_u5757_u89C4_u8303_uFF08OSGI_29"><span class="toc-number">6.1.3.</span> <span class="toc-text">动态化模块规范（OSGI)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u7C7B_u7684_u552F_u4E00_u6027"><span class="toc-number">7.</span> <span class="toc-text">类的唯一性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u53C2_u8003"><span class="toc-number">8.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="post-content"><p>在web开发中经常会遇到<code>ClassNotFoundException</code>和<code>NoSuchMethodError</code>，大家的第一直觉往往是jar包冲突，但其根本原因是什么呢？编译、打包时没有异常，只有在部署启动时才抛出异常，可见我们“写代码”时用到的类与运行时实际引用的类不一致，或者根本找不到（not found）。这篇文章就类的加载做一简单的介绍。</p>
<a id="more"></a>
<h2 id="u4EC0_u4E48_u662F_u7C7B_u52A0_u8F7D_u5668"><a href="#u4EC0_u4E48_u662F_u7C7B_u52A0_u8F7D_u5668" class="headerlink" title="什么是类加载器"></a>什么是类加载器</h2><p>ClassLoader用以加载Class文件：通过类名定位或者生成定义Class的文件。</p>
<h2 id="u7C7B_u52A0_u8F7D_u7684_u7C7B_u578B"><a href="#u7C7B_u52A0_u8F7D_u7684_u7C7B_u578B" class="headerlink" title="类加载的类型"></a>类加载的类型</h2><h3 id="u542F_u52A8_u7C7B_u52A0_u8F7D_u5668_uFF08Bootstrap_ClassLoader_uFF09"><a href="#u542F_u52A8_u7C7B_u52A0_u8F7D_u5668_uFF08Bootstrap_ClassLoader_uFF09" class="headerlink" title="启动类加载器（Bootstrap ClassLoader）"></a>启动类加载器（Bootstrap ClassLoader）</h3><ul>
<li>用于加载<code>sun.boot.clas.path</code>系统变量（也就是<code>&lt;JAVA_HOME&gt;/lib</code>）指定路径中的<em>指定</em>类库，如rt.jar。（名字不符合的类目即使放在lib目录下也不会被加载）</li>
<li>C++实现，虚拟机的一部分</li>
<li>无法被Java程序直接用<br><img src="/../images/bootstrap_classloader.png" alt="图1. Bootstrap classLoader中指定的路径"></li>
</ul>
<h3 id="u6269_u5C55_u7C7B_u52A0_u8F7D_u5668_uFF08ExtClassLoader_uFF09"><a href="#u6269_u5C55_u7C7B_u52A0_u8F7D_u5668_uFF08ExtClassLoader_uFF09" class="headerlink" title="扩展类加载器（ExtClassLoader）"></a>扩展类加载器（ExtClassLoader）</h3><ul>
<li>用于加载<code>java.ext.dirs</code>系统变量（也就是<code>&lt;JAVA_HOME&gt;/lib/ext</code>）指定路径中的<em>所有</em>类库</li>
<li><code>sun.misc.Launcher.ExtClassLoader</code>: 启动应用程序时在<code>Launcher</code>中被初始化</li>
<li>可以被Java程序直接引用</li>
</ul>
<h3 id="u5E94_u7528_u7A0B_u5E8F_u7C7B_u52A0_u8F7D_u5668_uFF08SCL_uFF09"><a href="#u5E94_u7528_u7A0B_u5E8F_u7C7B_u52A0_u8F7D_u5668_uFF08SCL_uFF09" class="headerlink" title="应用程序类加载器（SCL）"></a>应用程序类加载器（SCL）</h3><ul>
<li>也成为系统类加载器，用于加载用户类路径<code>java.class.path</code>中所有类库</li>
<li><code>sun.misc.Launcher.AppClassLoader</code>: 启动应用程序时在<code>Launcher</code>中被初始化</li>
<li>父类是<code>ExtClassLoader</code>, 通过<code>ClassLoader.getSystemClassLoader()</code>获取</li>
</ul>
<h2 id="ClassLoader_u6784_u9020_u65B9_u6CD5"><a href="#ClassLoader_u6784_u9020_u65B9_u6CD5" class="headerlink" title="ClassLoader构造方法"></a>ClassLoader构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 私有构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ClassLoader</span><span class="params">(Void unused, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ParallelLoaders.isRegistered(<span class="keyword">this</span>.getClass())) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ClassLoader</span><span class="params">(ClassLoader parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(checkCreateClassLoader(), parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认构造方法，设置双亲为系统类加载器</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(checkCreateClassLoader(), getSystemClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取系统类加载器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getSystemClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    initSystemClassLoader();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initSystemClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sclSet) &#123;</span><br><span class="line">        <span class="keyword">if</span> (scl != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"recursive invocation"</span>);</span><br><span class="line">        <span class="comment">// 系统类加载器、扩展类加载器均在Launcher中被初始化</span></span><br><span class="line">        sun.misc.Launcher l = sun.misc.Launcher.getLauncher();</span><br><span class="line">        <span class="keyword">if</span> (l != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Throwable oops = <span class="keyword">null</span>;</span><br><span class="line">            scl = l.getClassLoader(); <span class="comment">// 获取系统类加载器</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        sclSet = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u7C7B_u52A0_u8F7D_u7684_u751F_u547D_u5468_u671F"><a href="#u7C7B_u52A0_u8F7D_u7684_u751F_u547D_u5468_u671F" class="headerlink" title="类加载的生命周期"></a>类加载的生命周期</h2><p>类加载的生命周期包括：加载（Loading）-&gt; 验证（Verification）-&gt; 准备（Preparation）-&gt; 解析（Resolution）-&gt; 初始化（Initialization）-&gt; 使用（Using）-&gt; 卸载（Unloading）七个阶段。</p>
<h3 id="u52A0_u8F7D_uFF08Loading_uFF09"><a href="#u52A0_u8F7D_uFF08Loading_uFF09" class="headerlink" title="加载（Loading）"></a>加载（Loading）</h3><p>加载（Loading）阶段是类加载（Class Loading）过程中的一个阶段。在加载阶段需要完成三件事：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在Java堆中生成一个代表这个类的java.lang.Class对象</li>
</ol>
<p><em>对于何时开始加载，虚拟机规范中没有给出强制约束</em>，但对于何时进入初始化阶段，则给出了严格规定，而加载、验证、准备必须在初始化之前开始）</p>
<h3 id="u521D_u59CB_u5316_u65F6_u673A"><a href="#u521D_u59CB_u5316_u65F6_u673A" class="headerlink" title="初始化时机"></a>初始化时机</h3><ul>
<li>遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>、<code>invokstatic</code>4条字节码指令时（final修饰除外，因为编译期已经放入常量池）</li>
<li>使用<code>java.lang.reflect</code>进行反射调用时</li>
<li>初始化一个类时，如果发现其父类还没有初始化</li>
<li>虚拟机启动时，初始化包含<code>main()</code>方法的类</li>
</ul>
<p>说明：</p>
<ul>
<li>对于静态字段，只有直接定义这个字段的类才会被初始化，因为通过子类来引用父类中定义的静态字段时，只会触发父类的初始化</li>
<li>定义数组时，不会触发数组中具体类的初始化，只会触发由虚拟机自动生成的类，这个类中有属性length和方法<code>clone()</code></li>
<li>引用常量时，不会触发类的初始化。因为在编译阶段常量被存储到了调用类的常量池中。调用类与被调用常量所属的类在编译阶段之后，已经没有任何联系</li>
<li>接口在初始化时与类不同：需要求其父类接口完成初始化</li>
</ul>
<h3 id="26lt_3Bclinit_26gt_3B_28_29_u65B9_u6CD5"><a href="#26lt_3Bclinit_26gt_3B_28_29_u65B9_u6CD5" class="headerlink" title="&lt;clinit&gt;()方法"></a><code>&lt;clinit&gt;()</code>方法</h3><ul>
<li><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中所有<em>类变量的复制动作</em>和<em>静态语句块</em>中的语句合并而成</li>
<li><code>&lt;clinit&gt;()</code>方法与类的构造方法不用，不需要显式的调用父类构造器（虚拟机会保证父类的<code>&lt;clinit&gt;()</code>方法一定在子类的<code>&lt;clinit&gt;()</code>方法执行前完成</li>
<li>接口中不能使用静态语句块，但可以有类变量的初始化。只不过在执行接口的<code>&lt;clinit&gt;()</code>方法时，不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法。只有当父接口中定义的变量被使用时，父接口才会被初始化。</li>
<li>虚拟机保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境下被正确的加锁和同步。</li>
</ul>
<h2 id="u5982_u4F55_u52A0_u8F7DClass"><a href="#u5982_u4F55_u52A0_u8F7DClass" class="headerlink" title="如何加载Class"></a>如何加载Class</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name); <span class="comment">// 在JVM系统字典中寻找是否被实例化过</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>); <span class="comment">// 先委托双亲加载</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name); <span class="comment">// 如果双亲，则从启动类中加载</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                c = findClass(name); <span class="comment">// 通过自定义类加载器加载</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 子类自己实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在jvm系统字典中寻找是否已经被加载</span></span><br><span class="line"><span class="function">JNIEXPORT jclass JNICALL</span><br><span class="line"><span class="title">Java_java_lang_ClassLoader_findLoadedClass0</span><span class="params">(JNIEnv *env, jobject loader, jstring name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> JVM_FindLoadedClass(env, loader, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JVM_ENTRY(jclass, JVM_FindLoadedClass(JNIEnv *env, jobject loader, jstring name))</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 系统字典中寻找被加载过的实例</span></span><br><span class="line">    Klass* k = SystemDictionary::find_instance_or_array_klass(klass_name, h_loader, Handle(), CHECK_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (k == <span class="literal">NULL</span>) ? <span class="literal">NULL</span> : (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());</span><br><span class="line">JVM_END</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Look for a loaded instance or array klass by name.  Do not do any loading.</span></span><br><span class="line"><span class="comment">// return NULL in case of error.</span></span><br><span class="line">Klass* SystemDictionary::find_instance_or_array_klass(Symbol* class_name,</span><br><span class="line">                                                      Handle class_loader,</span><br><span class="line">                                                      Handle protection_domain,</span><br><span class="line">                                                      TRAPS) &#123;</span><br><span class="line">    find(class_name, class_loader, protection_domain, THREAD);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Klass* SystemDictionary::find(Symbol* class_name,</span><br><span class="line">                              Handle class_loader,</span><br><span class="line">                              Handle protection_domain,</span><br><span class="line">                              TRAPS) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 根据className 和 classLoader做hash</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> d_hash = dictionary()-&gt;compute_hash(class_name, loader_data);</span><br><span class="line">  <span class="keyword">int</span> d_index = dictionary()-&gt;hash_to_index(d_hash);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dictionary()-&gt;find(d_index, d_hash, class_name, loader_data, protection_domain, THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 系统类加载器</span></span><br><span class="line"><span class="function">JNIEXPORT jclass JNICALL</span><br><span class="line"><span class="title">Java_java_lang_ClassLoader_findBootstrapClass</span><span class="params">(JNIEnv *env, jobject loader, jstring classname)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    clname = getUTF(env, classname, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过BootLoader寻找</span></span><br><span class="line">    cls = JVM_FindClassFromBootLoader(env, clname);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u53CC_u4EB2_u59D4_u6D3E_u6A21_u578B"><a href="#u53CC_u4EB2_u59D4_u6D3E_u6A21_u578B" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>双亲委派模型其实只是一种推荐实现方式，模型本身是可以被破坏的：<br>因为<code>loadClass()</code>方法并非<code>final</code>，可以被重写（override）。</p>
<p>即使继承ClassLoader，ClassLoader的构造方法也支持将双亲设置为<code>null</code>，这样就可以绕过系统类加载器，先在启动类加载器中加载，找不到则通过子类的加载机制进行加载。所以<em>双亲委派模型</em>不是强制约束，而是Java设计者的推荐实现方式。</p>
<h3 id="u201C_u7834_u574F_u5386_u53F2_u201D"><a href="#u201C_u7834_u574F_u5386_u53F2_u201D" class="headerlink" title="“破坏历史”"></a>“破坏历史”</h3><h4 id="JDK1-2_u4E4B_u524D"><a href="#JDK1-2_u4E4B_u524D" class="headerlink" title="JDK1.2之前"></a>JDK1.2之前</h4><p>双亲委派模型在JDK1.2中被引进，而类加载器抽象类在JDK1.0时代已经存在，那时继承<code>ClassLoader</code>的唯一目的就是为了重写<code>loadClass()</code>方法，而虚拟机在类加载的时候会调用加载器的私有方法<code>loadClassInternal()</code>。具体参考邮件<a href="http://mail.openjdk.java.net/pipermail/hotspot-runtime-dev/2007-August/000013.html" target="_blank" rel="external">why is VM calling ClassLoader.loadClassInternal</a><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; loadClassInternal(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// For backward compatibility, explicitly lock on 'this' when</span></span><br><span class="line">    <span class="comment">// the current class loader is not parallel capable.</span></span><br><span class="line">    <span class="keyword">if</span> (parallelLockMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">             <span class="keyword">return</span> loadClass(name); <span class="comment">// 同步调用1.2版本前被重写的loadClass方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="u7EBF_u7A0B_u4E0A_u4E0B_u6587_u7C7B_u52A0_u8F7D_u5668"><a href="#u7EBF_u7A0B_u4E0A_u4E0B_u6587_u7C7B_u52A0_u8F7D_u5668" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h4><p>JNDI是后来J2EE容器必须提供的服务之一，将应用与实际数据相分离。它的代码是由启动类加载器去加载，但JNDI的目的是对资源的集中管理和查找，需要调用独立产商实现并部署在应用程序下的JNDI SPI代码，但启动类加载器完全不可能“认识”供应商的代码。</p>
<p>于是引入线程上下文类加载器。在初始化Launcher时，会初始化扩展类加载器、系统类加载器，同时还会将系统加载器设置到当前线程。JNDI服务使用这个类加载器去加载所需的SPI代码，即父类加载器委派子类加载器完成相关类。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    extcl = ExtClassLoader.getExtClassLoader();</span><br><span class="line"></span><br><span class="line">    loader = AppClassLoader.getAppClassLoader(extcl);</span><br><span class="line"></span><br><span class="line">    Thread.currentThread().setContextClassLoader(loader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="u52A8_u6001_u5316_u6A21_u5757_u89C4_u8303_uFF08OSGI_29"><a href="#u52A8_u6001_u5316_u6A21_u5757_u89C4_u8303_uFF08OSGI_29" class="headerlink" title="动态化模块规范（OSGI)"></a>动态化模块规范（OSGI)</h4><p>OSGi服务平台提供在多种网络设备上无需重启的动态改变构造的功能，完成模块化的热部署。而它的关键机制在于自定义的类加载器：每一个模块（Bundle）都有自己的类加载器，当需要更换模块时，将Bundle与类加载器一起替换掉以实现热替换。</p>
<p>OSGI中的类加载也不再是双亲委派模型，而是网状结构。</p>
<h2 id="u7C7B_u7684_u552F_u4E00_u6027"><a href="#u7C7B_u7684_u552F_u4E00_u6027" class="headerlink" title="类的唯一性"></a>类的唯一性</h2><p>在Java虚拟机中类的唯一性由<em>类本身</em>和<em>加载它的类加载器（ClassLoader）</em>共同确定。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Klass* SystemDictionary::resolve_instance_class_or_null(Symbol* name,</span><br><span class="line">                                                      Handle class_loader,</span><br><span class="line">                                                      Handle protection_domain,</span><br><span class="line">                                                      TRAPS) &#123;</span><br><span class="line">    class_loader = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));</span><br><span class="line">    ClassLoaderData *loader_data = register_loader(class_loader, CHECK_NULL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 针对class_name和loader_data进行hash</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> d_hash = dictionary()-&gt;compute_hash(name, loader_data);</span><br><span class="line">    <span class="keyword">int</span> d_index = dictionary()-&gt;hash_to_index(d_hash);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据hash值的索引进行查找</span></span><br><span class="line">    Klass* probe = dictionary()-&gt;find(d_index, d_hash, name, loader_data,</span><br><span class="line">                                        protection_domain, THREAD);</span><br><span class="line">    <span class="keyword">if</span> (probe != <span class="literal">NULL</span>) <span class="keyword">return</span> probe;</span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://mail.openjdk.java.net/pipermail/hotspot-runtime-dev/2007-August/000013.html" target="_blank" rel="external">why is VM calling ClassLoader.loadClassInternal</a></li>
<li><a href="http://media.techtarget.com/tss/static/articles/content/dm_classForname/DynLoad.pdf" target="_blank" rel="external">Understanding Class.forName()</a></li>
</ul>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://www.xiaoyuxee.com/2016/04/27/understanding-classloader/" data-id="cinyhkgkm0008ylm5n5ea84qn" class="article-share-link">分享到</a><div class="tags"><a href="/tags/ClassLoader/">ClassLoader</a></div><div class="post-nav"><a href="/2016/05/01/port-of-tcp/" class="pre">TCP中的端口号</a><a href="/2016/04/07/executor-in-java-concurrency/" class="next">Java中的多线程（五）：ThreadPoolExecutor框架源码解析</a></div><div id="disqus_thread"><script>var disqus_shortname = 'xiaoyuxee';
var disqus_identifier = '2016/04/27/understanding-classloader/';
var disqus_title = 'Java中的ClassLoader';
var disqus_url = 'http://www.xiaoyuxee.com/2016/04/27/understanding-classloader/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//xiaoyuxee.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://www.xiaoyuxee.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java-Core/">Java-Core</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network/">Network</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活随笔/">生活随笔</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/目标管理/">目标管理</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Channel/" style="font-size: 15px;">Channel</a> <a href="/tags/ClassLoader/" style="font-size: 15px;">ClassLoader</a> <a href="/tags/Concurrency/" style="font-size: 15px;">Concurrency</a> <a href="/tags/Thread/" style="font-size: 15px;">Thread</a> <a href="/tags/Synchronizer/" style="font-size: 15px;">Synchronizer</a> <a href="/tags/Synchronization/" style="font-size: 15px;">Synchronization</a> <a href="/tags/TCP-IP/" style="font-size: 15px;">TCP/IP</a> <a href="/tags/NIO/" style="font-size: 15px;">NIO</a> <a href="/tags/个人计划/" style="font-size: 15px;">个人计划</a> <a href="/tags/Liveness/" style="font-size: 15px;">Liveness</a> <a href="/tags/Lambda/" style="font-size: 15px;">Lambda</a> <a href="/tags/Java8/" style="font-size: 15px;">Java8</a> <a href="/tags/Wiring-Beans/" style="font-size: 15px;">Wiring-Beans</a> <a href="/tags/ThreadPool/" style="font-size: 15px;">ThreadPool</a> <a href="/tags/JDBC/" style="font-size: 15px;">JDBC</a> <a href="/tags/Srping-MVC/" style="font-size: 15px;">Srping-MVC</a> <a href="/tags/Eclipse/" style="font-size: 15px;">Eclipse</a> <a href="/tags/IO/" style="font-size: 15px;">IO</a> <a href="/tags/Aggregate-Operation/" style="font-size: 15px;">Aggregate-Operation</a> <a href="/tags/Stream/" style="font-size: 15px;">Stream</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/05/01/port-of-tcp/">TCP中的端口号</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/27/understanding-classloader/">Java中的ClassLoader</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/07/executor-in-java-concurrency/">Java中的多线程（五）：ThreadPoolExecutor框架源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/31/synchronizer-in-java-concurrency/">Java中的多线程（四）：同步器</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/16/liveness-in-java-concurrency/">Java中的多线程（三）：活跃度</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/15/synchronization-in-java-concurrency/">Java中的多线程（二）：同步机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/15/base-in-java-concurrency/">Java中的多线程（一）：线程的基本概念和使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/13/in-depth-understanding-of-channel-in-nio/">深入理解NIO中的Channel</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/11/nio-in-java/">Java中的NIO</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/15/basic-IO-in-java/">Java中的输入/输出流</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//xiaoyuxee.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">子善.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-34320961-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?df8e4e2f63affab3a847f75bd4b5f732";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>