<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="假装是个程序员"><title>Java中的多线程（二）：同步机制 | 子善</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java中的多线程（二）：同步机制</h1><a id="logo" href="/.">子善</a><p class="description">假装是个程序员</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java中的多线程（二）：同步机制</h1><div class="post-meta">Mar 15, 2016<span> | </span><span class="category"><a href="/categories/Java-Core/">Java-Core</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2016/03/15/concurrence-in-java-2/" href="/2016/03/15/concurrence-in-java-2/#disqus_thread" class="disqus-comment-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#u7EBF_u7A0B_u5E72_u6270"><span class="toc-number">1.</span> <span class="toc-text">线程干扰</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u5185_u5B58_u4E00_u81F4_u6027_u95EE_u9898"><span class="toc-number">2.</span> <span class="toc-text">内存一致性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#happens-before"><span class="toc-number">2.1.</span> <span class="toc-text">happens-before</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u5185_u90E8_u9501_u4E0E_u76D1_u89C6_u5668"><span class="toc-number">3.</span> <span class="toc-text">内部锁与监视器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u540C_u6B65_u65B9_u6CD5"><span class="toc-number">4.</span> <span class="toc-text">同步方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u540C_u6B65_u8BED_u53E5"><span class="toc-number">5.</span> <span class="toc-text">同步语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u591A_u6B21_u540C_u6B65"><span class="toc-number">6.</span> <span class="toc-text">多次同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u539F_u5B50_u8BBF_u95EE"><span class="toc-number">7.</span> <span class="toc-text">原子访问</span></a></li></ol></div></div><div class="post-content"><p>进程中的多个线程间往往需要通信，共同完成或维护进程的目的。线程间的通信主要通过共享数据（基础类型数据，对象引用等)，这种共享数据的方式会导致两种潜在发生的错误：线程干扰（thread interference）和内存一致性错误（memory consistency errors）。而同步（synchronization）机制应运而生，用于解决上面可能出现的错误。</p>
<p>同步机制虽然可以解决线程干扰和内存一致性问题，但也可能带来其他问题：线程竞争（thread contention）。当多个线程尝试访问同一块资源时产出了竞争关系，有可能会导致线程被挂起或者死锁。</p>
<a id="more"></a>
<h2 id="u7EBF_u7A0B_u5E72_u6270"><a href="#u7EBF_u7A0B_u5E72_u6270" class="headerlink" title="线程干扰"></a>线程干扰</h2><p>线程干扰是指，别的线程会影响当前线程执行结果的正确性。<br>举个常见的栗子：<code>i++</code>。这个自增操作对应的jvm指令大概是这样：</p>
<ol>
<li>内存中获取 i 的值</li>
<li>对 i 执行 i+1 操作</li>
<li>将 i+1 写入内存</li>
</ol>
<p>如果两个线程同时对某一成员执行自增操作，考虑以下场景：两个线程同时从内存中取得相同的值，执行递增操作后，写入内存的时间发生了差异。那么后执行的线程必然覆盖提前结束线程的操作结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100000</span>; i++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">reduce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100000</span>; i++) &#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInterference</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Counter counter = <span class="keyword">new</span> Counter();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; counter.increase());</span><br><span class="line">    </span><br><span class="line">    counter.reduce();</span><br><span class="line">    </span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 断言将会失败</span></span><br><span class="line">    assertEquals(<span class="number">0</span>, counter.getCount());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u5185_u5B58_u4E00_u81F4_u6027_u95EE_u9898"><a href="#u5185_u5B58_u4E00_u81F4_u6027_u95EE_u9898" class="headerlink" title="内存一致性问题"></a>内存一致性问题</h2><p>每个线程有自己的栈，为了提供访问效率，一般会将进程中堆上的数据做一份缓存放在自己的栈上面。那么有可能在短暂时间内会导致一个线程的修改结果对另一个线程不可见。Java提供了<a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.5" target="_blank" rel="external">happens-before</a>机制来避免内存一致性问题。</p>
<h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>只有当一个写操作与读操作存在happens-before关系时，才能保证此写操作的结果对那个读操作可见。同步（synchronized）、volatile关键字、Thread.start()，Thread.join()都会建立happens-before关系。</p>
<ul>
<li>一个线程中，每个操作与当前线程中后面的操作存在happens-before关系。</li>
<li>未上锁的同步区块或方法与后面的锁定区块或方法存在happens-before关系（注意：这种关系是可以传递的）</li>
<li>一个<em>volatile</em>域的写操作与随后的读操作存在happens-before关系。</li>
<li>一个主线程与它启动的其他线程存在happens-before关系。</li>
<li>一个线程与成功join的其他线程存在happens-before关系。</li>
</ul>
<h2 id="u5185_u90E8_u9501_u4E0E_u76D1_u89C6_u5668"><a href="#u5185_u90E8_u9501_u4E0E_u76D1_u89C6_u5668" class="headerlink" title="内部锁与监视器"></a>内部锁与监视器</h2><p>同步机制的实现是通过监视器来实现：<em>Java中的每个对象都有一个可以被锁定或者解锁的监视器</em>。任何时间段里有且只可能有一个线程拥有这个监视器的锁。任何尝试对已经锁定的监视器进行再次锁定的线程都会被阻塞（当然不包括已经含有此锁的线程），直到他们获得监视器的锁。</p>
<p><em>同步语句</em>会计算对象的引用，并尝试对对象的监视器进行锁定操作，直到锁定操作成功后才会执行后面的操作。当同步内容执行完毕后，又会自动对监视器进行解锁操作。</p>
<p>当一个<em>同步方法</em>被调用时，会自动进行锁定监视器的操作，同样只有锁定操作成功后才会执行方法体内的操作。对于<em>实例方法</em>，锁定的是被调用实例的监视器。而对于<em>静态方法</em>，锁定的是被调用的<code>Class</code>对象。</p>
<p>Java中并不会避免或者检测<em>死锁条件</em>，所以应用程序必要时需要自己避免死锁。</p>
<h2 id="u540C_u6B65_u65B9_u6CD5"><a href="#u540C_u6B65_u65B9_u6CD5" class="headerlink" title="同步方法"></a>同步方法</h2><p>方法同步的影响：</p>
<ul>
<li>不允许对一个对象的两个方法交替调用。也就是说当一个线程正在执行某对象的同步方法时，其他调用改方法的线程将被阻塞或挂起，直到那个正在执行的线程执行完毕。</li>
<li>当退出同步方法时，将与随后对此方法的调用自动建立happens-before关系。保证对象状态的改变对随后的线程可见。</li>
</ul>
<p>构造方法不能用于同步，因为没有意义，为什么呢？（因为只有当前线程才能创建它）。</p>
<h2 id="u540C_u6B65_u8BED_u53E5"><a href="#u540C_u6B65_u8BED_u53E5" class="headerlink" title="同步语句"></a>同步语句</h2><p>同步方法是对整个被调用的（this）<em>实例</em>或者<em>Class</em>的监视器进行锁定，而同步语句不一定要对当前被调用的实例锁定，它可以锁定指定的对象，这将非常有帮助。比如一个类中有两个成员，foo和bar，但它们并不会同时使用。所有对它们的更新都需要同步，但并不意味着两个线程不可以交叉分别更新它们。我们可以单独对它们的监视器进行锁定，针对基本类型可以分别创建一个对象锁。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> foo;</span><br><span class="line">    <span class="keyword">private</span> Object lockForFoo = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Long bar = <span class="number">0L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increaseFoo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockForFoo) &#123;</span><br><span class="line">            foo++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increaseBar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (bar) &#123;</span><br><span class="line">            bar++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.format(<span class="string">"foo=%d, bar=%d%n"</span>, foo, bar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    MyLock lock = <span class="keyword">new</span> MyLock();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; lock.increaseFoo()).start();;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; lock.increaseBar()).start();;</span><br><span class="line">    </span><br><span class="line">    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">    lock.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u591A_u6B21_u540C_u6B65"><a href="#u591A_u6B21_u540C_u6B65" class="headerlink" title="多次同步"></a>多次同步</h2><p>大家已经知道一个线程只能等待另一个线程解锁监视器后才能调用其同步方法，那如果一个同步方法中会调用另外一个同步方法会怎样？答案是可以的，该线程已经获得了这个实例的内部锁，可以再次进入别的同步方法。</p>
<h2 id="u539F_u5B50_u8BBF_u95EE"><a href="#u539F_u5B50_u8BBF_u95EE" class="headerlink" title="原子访问"></a>原子访问</h2><p>如上所示，<code>c++</code>在多线程环境容易导致并发问题，其中一个原因为这并不是一个原子性的操作，它被分解成3个指令来执行。对于这种基本类型的增减操作，Java提供了相关的<code>Atomic</code>原子类。</p>
<p>原子操作，意味着要么被全部执行，要么什么都不执行。虽然原子操作可以避免线程干扰的问题，但是不是在多线程环境下就一定不会有线程安全问题呢？答案是否定的，因为可能导致内存不一致问题。这时<code>volatile</code>就派上用场了。所以在使用Atomic类是需要注意内存一致性问题。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://www.xiaoyuxee.com/2016/03/15/concurrence-in-java-2/" data-id="cilukkm75000yw4m5qto7op5o" class="article-share-link">分享到</a><div class="tags"><a href="/tags/Concurrence/">Concurrence</a><a href="/tags/Synchronization/">Synchronization</a><a href="/tags/Thread/">Thread</a></div><div class="post-nav"><a href="/2016/03/16/concurrence-in-java-3/" class="pre">Java中的多线程（三）：活跃度</a><a href="/2016/03/15/concurrence-in-java-1/" class="next">Java中的多线程（一）：线程的基本概念和使用</a></div><div id="disqus_thread"><script>var disqus_shortname = 'xiaoyuxee';
var disqus_identifier = '2016/03/15/concurrence-in-java-2/';
var disqus_title = 'Java中的多线程（二）：同步机制';
var disqus_url = 'http://www.xiaoyuxee.com/2016/03/15/concurrence-in-java-2/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//xiaoyuxee.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://www.xiaoyuxee.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java-Core/">Java-Core</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活随笔/">生活随笔</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/目标管理/">目标管理</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Synchronization/" style="font-size: 15px;">Synchronization</a> <a href="/tags/NIO/" style="font-size: 15px;">NIO</a> <a href="/tags/Lambda/" style="font-size: 15px;">Lambda</a> <a href="/tags/Java8/" style="font-size: 15px;">Java8</a> <a href="/tags/Channel/" style="font-size: 15px;">Channel</a> <a href="/tags/JDBC/" style="font-size: 15px;">JDBC</a> <a href="/tags/Srping-MVC/" style="font-size: 15px;">Srping-MVC</a> <a href="/tags/Concurrence/" style="font-size: 15px;">Concurrence</a> <a href="/tags/Thread/" style="font-size: 15px;">Thread</a> <a href="/tags/Wiring-Beans/" style="font-size: 15px;">Wiring-Beans</a> <a href="/tags/Eclipse/" style="font-size: 15px;">Eclipse</a> <a href="/tags/IO/" style="font-size: 15px;">IO</a> <a href="/tags/Aggregate-Operation/" style="font-size: 15px;">Aggregate-Operation</a> <a href="/tags/Stream/" style="font-size: 15px;">Stream</a> <a href="/tags/个人计划/" style="font-size: 15px;">个人计划</a> <a href="/tags/Liveness/" style="font-size: 15px;">Liveness</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/03/16/concurrence-in-java-3/">Java中的多线程（三）：活跃度</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/15/concurrence-in-java-2/">Java中的多线程（二）：同步机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/15/concurrence-in-java-1/">Java中的多线程（一）：线程的基本概念和使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/13/in-depth-understanding-of-channel-in-nio/">深入理解nio中的Channel</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/11/nio-in-java/">Java中的NIO</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/15/basic-IO-in-java/">Java中的输入/输出流</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/06/aggregate-operation-in-java8/">Java8中的Stream</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/05/lambda-in-java8/">Java8中的Lambda表达式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/30/wiring-beans-in-spring/">Wiring Beans In Spring</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/24/database-access-in-java/">Java应用中的数据库访问</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//xiaoyuxee.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">子善.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/jquery.min.js?v=0.0.0"></script><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-34320961-1','auto');ga('send','pageview');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?df8e4e2f63affab3a847f75bd4b5f732";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>