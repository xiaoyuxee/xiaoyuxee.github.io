{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":0},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":0},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":0},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":0},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":0},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":0},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0},{"_id":"themes/maupassant/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0},{"_id":"themes/maupassant/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0},{"_id":"themes/maupassant/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0},{"_id":"themes/maupassant/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":0},{"_id":"themes/maupassant/source/css/jquery.fancybox.css","path":"css/jquery.fancybox.css","modified":0},{"_id":"source/images/demo.png","path":"images/demo.png","modified":0},{"_id":"source/images/Channel-class.png","path":"images/Channel-class.png","modified":0},{"_id":"source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":0}],"Cache":[{"_id":"source/_drafts/effective-plugins-of-eclipse.md","shasum":"616b6d0b76fb19a512e359e285e3a09a26238904","modified":1453112195000},{"_id":"source/_drafts/config-data-source-with-spring.md","shasum":"0f657c2fd3a3b08e468434d0ccdc3b77b1219f7a","modified":1454170680000},{"_id":"source/_drafts/MySql-Reading-List.md","shasum":"0f3a93c9644d20c1e1778b09f1149a1ca472e85c","modified":1483022800000},{"_id":"source/_drafts/Startup-Reading-List.md","shasum":"6c7ee218e8dce7c1932bd4ae2cba580d19fc9147","modified":1452449845000},{"_id":"source/_drafts/logback-tutorial.md","shasum":"fec638460fd975bd8a9fe3b315981e2c4fc1635f","modified":1453129968000},{"_id":"source/_drafts/java-interview.md","shasum":"09584c2348281e8285bee930e356df98a9afd826","modified":1455770837000},{"_id":"source/_drafts/mysql-basic-sql.md","shasum":"a424720f9418526dbc866346f94ea90d7b2d1f7b","modified":1453626029000},{"_id":"source/_drafts/nginx-http-rewrite.md","shasum":"11e3f06badcd7a96efc9540342cb358ef7a91b4e","modified":1456469755000},{"_id":"source/_drafts/simple-mysql-tutorial.md","shasum":"b084618766aaaa8432b29161f4a59fdfbc1ff8cc","modified":1452708084000},{"_id":"source/_drafts/resources-loading-in-spring.md","shasum":"8cbdca83fa7751628e33faa82b916ea3097770f3","modified":1454488485000},{"_id":"source/_drafts/study-spring-mvc.md","shasum":"eaa7ff5bbf23a4592a1cf0f804ff986e5aa0253e","modified":1475068857000},{"_id":"source/_posts/aggregate-operation-in-java8.md","shasum":"32fc081729e6f97ef09487f5e2dc244c5be7ae23","modified":1454787954000},{"_id":"source/_posts/base-in-java-concurrency.md","shasum":"7a1950350c5321dea05af3b39d107119155792c7","modified":1461998699000},{"_id":"source/_posts/coding-effectively-with-eclipse-on-mac.md","shasum":"73a3ac21c6e34ba36aa89e0eae2b531dfd447d8f","modified":1453641275000},{"_id":"source/_posts/basic-IO-in-java.md","shasum":"bcda262afb527e4797783bda65c06b11a6e73391","modified":1457970058000},{"_id":"source/_posts/config-diapatcher-servlet-with-servlet3.0.md","shasum":"18c622cc10b7460cb83e2f925007ee6292e01522","modified":1454898828000},{"_id":"source/_posts/database-access-in-java.md","shasum":"b0aa09b42f180af02ee6bcdb0183e80c211d520c","modified":1454896598000},{"_id":"source/_posts/executor-in-java-concurrency.md","shasum":"2e07312156a4e01936e419cb94f812789242bcac","modified":1461999399000},{"_id":"source/_posts/hello-world.md","shasum":"147e89826f5ff5a28464d9f0b87d86e928aeb32b","modified":1452443129000},{"_id":"source/_posts/in-depth-understanding-of-channel-in-nio.md","shasum":"3c87bb66d7af47443fd712c6ffa40d741f7b67d5","modified":1460791553000},{"_id":"source/_posts/lambda-in-java8.md","shasum":"c8da2330fc47d047e88a84ca7be59c599bbaee18","modified":1454898634000},{"_id":"source/_posts/liveness-in-java-concurrency.md","shasum":"38442221cc20c0d6a3e060180cf7057324013dc0","modified":1461998725000},{"_id":"source/_posts/my-2015.md","shasum":"6e7c80ccf8bb6b7af59d102f1c5c32c406d7c627","modified":1452615349000},{"_id":"source/_posts/nio-in-java.md","shasum":"549ee224be24fbe83f0e4fc1636c1c91a23d5762","modified":1457968861000},{"_id":"source/_posts/synchronization-in-java-concurrency.md","shasum":"50991d7b40fdeec4af491c3d4be9c223ca6ae6f2","modified":1461998758000},{"_id":"source/_posts/synchronizer-in-java-concurrency.md","shasum":"d1f3f7dab2dfa12bf0182a9146758c9afd5b6cbe","modified":1461998765000},{"_id":"source/_posts/wiring-beans-in-spring.md","shasum":"4555555631f346594e6726658562fcbaa13be641","modified":1454898517000},{"_id":"source/images/Channel-class.png","shasum":"67d029f05fc76c4e4fe336fdd1ecd5999402fe54","modified":1457848037000},{"_id":"source/images/demo.png","shasum":"0dc1116e08760fd6309629bbfa3a72dc736a991a","modified":1454865694000},{"_id":"themes/maupassant/LICENSE","shasum":"019dc6a9aba02ae3aaabca45f39aecd6e8e7f1d8","modified":1458150280000},{"_id":"themes/maupassant/README.md","shasum":"75d8c42569809961953d1934de445418c00ab94c","modified":1475066389000},{"_id":"themes/maupassant/_config.yml","shasum":"8c21341a2876c2a1c9807be5e2c724a4e39166e3","modified":1475068208000},{"_id":"themes/maupassant/languages/de-DE.yml","shasum":"5d3556a885e355a8c2da65ef3e7b3ee36a628bfa","modified":1458150280000},{"_id":"themes/maupassant/languages/en.yml","shasum":"e13ab1a2d2f1edbe67b4c035fd4667cb6a31db8e","modified":1458150280000},{"_id":"themes/maupassant/languages/es-ES.yml","shasum":"58e1d04bcd1834fa9d2960e18e027abbbccbedc9","modified":1458150280000},{"_id":"themes/maupassant/languages/fr-FR.yml","shasum":"b47906ec0abf867fb3e3360bc046b7afb68aee25","modified":1458150280000},{"_id":"themes/maupassant/languages/ko.yml","shasum":"909a33e0befa6978e8e72157c6b415b48551ee31","modified":1458150280000},{"_id":"themes/maupassant/languages/zh-CN.yml","shasum":"ebacfa5d0c14d603e0d505757adb24c0bbe5dd13","modified":1458150280000},{"_id":"themes/maupassant/languages/zh-TW.yml","shasum":"56b65995c60e99dcebbf00168447fd225d28e5b2","modified":1458150280000},{"_id":"themes/maupassant/layout/_partial/comments.jade","shasum":"6c7f63ba04a4d28323ba31e79a4927f3d3fcc56e","modified":1458150280000},{"_id":"themes/maupassant/layout/_partial/footer.jade","shasum":"aa020b794e697e8e9612530c97c6295efde469fe","modified":1458150280000},{"_id":"themes/maupassant/layout/_partial/after_footer.jade","shasum":"3dbcc9a9f0d6e55da191d3393c18bbfcfe99fa69","modified":1475066389000},{"_id":"themes/maupassant/layout/_partial/helpers.jade","shasum":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1458150280000},{"_id":"themes/maupassant/layout/_partial/mathjax.jade","shasum":"b54b56faff9e47ab3ca3cdd55056c73e60776f3c","modified":1475066389000},{"_id":"themes/maupassant/layout/_partial/mathjax2.jade","shasum":"d6ac5dc4e9c7a1b866f1f92d88988cfb35aded4c","modified":1475066389000},{"_id":"themes/maupassant/layout/_partial/post_nav.jade","shasum":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1458150280000},{"_id":"themes/maupassant/layout/_partial/paginator.jade","shasum":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1458150280000},{"_id":"themes/maupassant/layout/_partial/tag.jade","shasum":"0f0e6770e9d5dd8040e330d71bbbfadd2df36a28","modified":1458150280000},{"_id":"themes/maupassant/layout/_partial/totop.jade","shasum":"8225bbc3cdb9648bc2e6872e5c616a9a1e4def4f","modified":1458150280000},{"_id":"themes/maupassant/layout/_widget/category.jade","shasum":"7c6aed762934ca51aa2669b886254da24b77bc14","modified":1475066389000},{"_id":"themes/maupassant/layout/_widget/links.jade","shasum":"f57a0c76d243882b2b77330132bdb43bc648948b","modified":1458150280000},{"_id":"themes/maupassant/layout/_widget/recent_comments.jade","shasum":"e119c5afa85abc60d139e2da99b0bfcd7a6530f8","modified":1458150280000},{"_id":"themes/maupassant/layout/_widget/recent_posts.jade","shasum":"19431336d724d2118e46da43683bce9063176541","modified":1458150280000},{"_id":"themes/maupassant/layout/_widget/search.jade","shasum":"193546282908e499813534f86d27ef6e0a1357b3","modified":1458150280000},{"_id":"themes/maupassant/layout/_widget/tag.jade","shasum":"132f049ce677d0e38f50073174c4ee4b825d4a06","modified":1458150280000},{"_id":"themes/maupassant/layout/archive.jade","shasum":"0050c883b4f202add71c8664d65e6072179e7190","modified":1458150280000},{"_id":"themes/maupassant/layout/base.jade","shasum":"852c610ac392ef2fa130dbe73bcf4f96f423c869","modified":1475066389000},{"_id":"themes/maupassant/layout/base-without-sidebar.jade","shasum":"1ad721de96784bf4253316b796db6200148d4152","modified":1475066389000},{"_id":"themes/maupassant/layout/page.jade","shasum":"8d70fd3b93f2c9087a9ea7ec538dcc1d413bea01","modified":1458150280000},{"_id":"themes/maupassant/layout/post.jade","shasum":"9cf29fb0daed95935154ce0fa2b154df5a9b11b1","modified":1458150280000},{"_id":"themes/maupassant/layout/index.jade","shasum":"7466ce52023ed8a413a6b4461354a9e20e62fc14","modified":1475066389000},{"_id":"themes/maupassant/layout/single-column.jade","shasum":"c35fff4d9b331a41af5bc10f4278ec3d9da503db","modified":1475066389000},{"_id":"themes/maupassant/layout/timeline.jade","shasum":"f03d8df63a188543cfe4e85e76194abe081411a1","modified":1475066389000},{"_id":"themes/maupassant/package.json","shasum":"81fb4e2ac051ecfb9a93f37b28910291b939771a","modified":1458150280000},{"_id":"themes/maupassant/source/css/jquery.fancybox.css","shasum":"f42f761157f26244673eb2f4a9215c70956f80dc","modified":1458150280000},{"_id":"themes/maupassant/source/css/style.scss","shasum":"158f1ebecf7b994ffae5332a627465f6bf38113b","modified":1475068234000},{"_id":"themes/maupassant/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1458150280000},{"_id":"themes/maupassant/source/fancybox/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1458150280000},{"_id":"themes/maupassant/source/fancybox/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1458150280000},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1458150280000},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1458150280000},{"_id":"themes/maupassant/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1458150280000},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","shasum":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1458150280000},{"_id":"themes/maupassant/source/js/search.js","shasum":"53db2eb255dd40a412ed62ea7332ca5a22f7816f","modified":1458150280000},{"_id":"themes/maupassant/source/js/fancybox.js","shasum":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1475066389000},{"_id":"themes/maupassant/source/js/smartresize.js","shasum":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1458150280000},{"_id":"themes/maupassant/source/js/share.js","shasum":"f49776e0baa2b913ddc7a20db24b3edd469c8343","modified":1458150280000},{"_id":"themes/maupassant/source/js/totop.js","shasum":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1458150280000},{"_id":"source/apple-touch-icon.png","shasum":"8ea36f314bb4589d60b655d95447745ce6a9861f","modified":1487859116000},{"_id":"source/favicon.ico","shasum":"8ea36f314bb4589d60b655d95447745ce6a9861f","modified":1487859116000},{"_id":"public/apple-touch-icon.png","modified":1488381813692,"shasum":"8ea36f314bb4589d60b655d95447745ce6a9861f"},{"_id":"public/favicon.ico","modified":1488381813697,"shasum":"8ea36f314bb4589d60b655d95447745ce6a9861f"},{"_id":"public/2016/04/07/executor-in-java-concurrency/index.html","modified":1488381814208,"shasum":"5147ebad5555ca8262d9f3785643364217a1ca35"},{"_id":"public/2016/03/31/synchronizer-in-java-concurrency/index.html","modified":1488381814465,"shasum":"d13ca7fb3be7be9113c3c3aefffd6911734f4abe"},{"_id":"public/2016/03/16/liveness-in-java-concurrency/index.html","modified":1488381814656,"shasum":"efb915b348cead6788756d06ab61cb35c18c4108"},{"_id":"public/2016/03/15/synchronization-in-java-concurrency/index.html","modified":1488381814847,"shasum":"16e0f60076b3c9e55f6459a9d9cb6f9f57738927"},{"_id":"public/2016/03/15/base-in-java-concurrency/index.html","modified":1488381815031,"shasum":"3018c74bdf198eb4b403954994d58539b7a0c3e5"},{"_id":"public/2016/03/13/in-depth-understanding-of-channel-in-nio/index.html","modified":1488381815205,"shasum":"eebd1f8233364217a84303287a38d0917a2675f6"},{"_id":"public/2016/03/11/nio-in-java/index.html","modified":1488381815396,"shasum":"199be62af1def4071a3a13874bc5b506201bc066"},{"_id":"public/2016/02/15/basic-IO-in-java/index.html","modified":1488381815566,"shasum":"f56fd64b65de2da4967c8ec3e09f9551e92beb9e"},{"_id":"public/2016/02/06/aggregate-operation-in-java8/index.html","modified":1488381815728,"shasum":"6a5132f7f6951c2c4afb98034c64e6a50d3fe79a"},{"_id":"public/2016/02/05/lambda-in-java8/index.html","modified":1488381815898,"shasum":"c8b807b9368b0949cf4cbd57cf451c787c008742"},{"_id":"public/2016/01/30/wiring-beans-in-spring/index.html","modified":1488381816070,"shasum":"2794ea9e2f822a814814acc778b39306e6d748e2"},{"_id":"public/2016/01/24/database-access-in-java/index.html","modified":1488381816248,"shasum":"bd54dd36e8765302dba60e6f032baa25bb8abb23"},{"_id":"public/2016/01/17/coding-effectively-with-eclipse-on-mac/index.html","modified":1488381816414,"shasum":"690d1381605d16a5159ed208e6998b58726d6cc7"},{"_id":"public/2016/01/16/config-diapatcher-servlet-with-servlet3.0/index.html","modified":1488381816576,"shasum":"318c16393e9cff9aacfe54241e8a0f5414027f1d"},{"_id":"public/2016/01/11/my-2015/index.html","modified":1488381816742,"shasum":"00a9dd00230c2d6ec30bfc1304122f44dc34c8bb"},{"_id":"public/2016/01/10/hello-world/index.html","modified":1488381816899,"shasum":"4a057db8d0e905168c73a8202c532b04cd8fca99"},{"_id":"public/archives/index.html","modified":1488381817046,"shasum":"cd4c8a487157f1ea96ae57f4dd208dd569152345"},{"_id":"public/archives/page/2/index.html","modified":1488381817216,"shasum":"8cfe6e281f1d5a2d8a26d63b7812b8e0cc817a05"},{"_id":"public/archives/2016/index.html","modified":1488381817397,"shasum":"59dc5c5329b6df2029a16c7b4e04988d0b44d9f9"},{"_id":"public/archives/2016/page/2/index.html","modified":1488381817575,"shasum":"7bc3f326379ab41bd3a0e4f5f89f9cf58923f677"},{"_id":"public/archives/2016/01/index.html","modified":1488381817756,"shasum":"aefd394f5a2c5db808b0ca54d0e226d13fa2669e"},{"_id":"public/archives/2016/02/index.html","modified":1488381817849,"shasum":"be0ef8d40d7489c6d69233dc29f46b8c67dfd4ec"},{"_id":"public/archives/2016/03/index.html","modified":1488381817949,"shasum":"2db00fd23c19be80c90e0f5dea01759ca094ffb5"},{"_id":"public/archives/2016/04/index.html","modified":1488381818039,"shasum":"c3f27088a96a42e5d82320851feaf83b5c0e5782"},{"_id":"public/baidusitemap.xml","modified":1488381818041,"shasum":"a181cec6517f9592ea05393127e6e57e0096e450"},{"_id":"public/categories/Spring/index.html","modified":1488381818133,"shasum":"ab2e1dbfb0271badadc298adb1acf392b9bf92e1"},{"_id":"public/categories/Java-Core/index.html","modified":1488381818217,"shasum":"cfac3779794de341142ff08e54ea42b15f4682b5"},{"_id":"public/categories/目标管理/index.html","modified":1488381818311,"shasum":"a425cc05fe9ddec0de54d1c80877d0c014eaee80"},{"_id":"public/categories/生活随笔/index.html","modified":1488381818398,"shasum":"bb1bd961c2b41413b3b80bf79ffa54a8d81efd31"},{"_id":"public/CNAME","modified":1488381818399,"shasum":"aaaa5115944b78b8cb5575f065dacd043eff167a"},{"_id":"public/atom.xml","modified":1488381818401,"shasum":"822f776781657bf72a63ff0e58c4b659b44993a8"},{"_id":"public/index.html","modified":1488381818518,"shasum":"7f4c9b787af43d8775661e8ca594094d4f82a5f7"},{"_id":"public/page/2/index.html","modified":1488381818634,"shasum":"a49eaa6b3a1c6d19ff76934aa78e83aab504fe3b"},{"_id":"public/tags/Wiring-Beans/index.html","modified":1488381818730,"shasum":"2f262b7c9ba15722c7b193dc0c35b944792e5dd8"},{"_id":"public/tags/Concurrency/index.html","modified":1488381818820,"shasum":"489a39c8749432b5e8e7ad1d5f4efca069f02dca"},{"_id":"public/tags/Thread/index.html","modified":1488381818914,"shasum":"03536239067fed48056fe6c768755cfeeacfdabe"},{"_id":"public/tags/Synchronizer/index.html","modified":1488381819000,"shasum":"9122192533df99fc27be7cdd819d8e1920ca1a6e"},{"_id":"public/tags/Synchronization/index.html","modified":1488381819089,"shasum":"242b41251a6fb5998728567e433c8563fbc603b3"},{"_id":"public/tags/NIO/index.html","modified":1488381819171,"shasum":"c08e1b6b6237432c93096e4d0ba48e163d88dbbe"},{"_id":"public/tags/个人计划/index.html","modified":1488381819264,"shasum":"e42bce0611a456d29b75337fab49e350d3525fc2"},{"_id":"public/tags/Liveness/index.html","modified":1488381819359,"shasum":"69073492a169621622f0fa2ea1fe9f99071b0276"},{"_id":"public/tags/Lambda/index.html","modified":1488381819445,"shasum":"8dc5ee0da356421018f951753cd6e3a8ce57ec4f"},{"_id":"public/tags/Java8/index.html","modified":1488381819534,"shasum":"8bc7b389768c74e91ea4a126a8e704227852c110"},{"_id":"public/tags/Channel/index.html","modified":1488381819621,"shasum":"822777e4a4d6aa75e0694d0df058ef5da02e75f9"},{"_id":"public/tags/ThreadPool/index.html","modified":1488381819712,"shasum":"31add07c5ea62ce7a6d04eb28503434255ded9d2"},{"_id":"public/tags/JDBC/index.html","modified":1488381819798,"shasum":"e1010f6b95bbe7fee9a5318656f373c37cb625e5"},{"_id":"public/tags/Srping-MVC/index.html","modified":1488381819890,"shasum":"9a89cad6b4cd5a46a3d4645d8025ede7f8bba6c3"},{"_id":"public/tags/Eclipse/index.html","modified":1488381819976,"shasum":"83993317d41d74e3ad6444e63cc873bc543e3e33"},{"_id":"public/tags/IO/index.html","modified":1488381820063,"shasum":"372d5e530625799fa26fcc744ed6f317d70ab20c"},{"_id":"public/tags/Aggregate-Operation/index.html","modified":1488381820154,"shasum":"453c2450f94f43dca4d7d9194eedc0d8424ff6c5"},{"_id":"public/tags/Stream/index.html","modified":1488381820246,"shasum":"f23c09c7109f4436fc83447848f9660cddd81945"},{"_id":"public/sitemap.xml","modified":1488381820247,"shasum":"29002f7c3c96c79b857fe35213db2417c7a2c6f0"}],"Category":[{"name":"Spring","_id":"ciziguc4e0004nps6qnpzvocf"},{"name":"Java-Core","_id":"ciziguc4i0009nps6qrprcrt9"},{"name":"目标管理","_id":"ciziguc4u000snps6n6for3m5"},{"name":"生活随笔","_id":"ciziguc5b001enps62vctrlg9"},{"name":"spring","_id":"ciziguc63002bnps6oabin6lz"},{"name":"MySQL","_id":"ciziguc66002inps6d1zkemen"},{"name":"nginx","_id":"ciziguc6b002onps65rh1amfi"}],"Data":[],"Page":[],"Post":[{"title":"MySql阅读清单","_content":"\n\n\n\n## Books\n*\t《MySQL必知必会》\n*\t《高性能MySQL》《High Performance MySQL》 Download\n*\t《Understanding MySQL Internals》\n*\t《MySQL技术内幕：InnoDB存储引擎》\t\n*\t《高可用MySQL》\n*\t《深入浅出MySQL》\n\n\n\n\n\n\n## Blogs\n*\thttp://www.penglixun.com/\n\n## others\n*\thttp://mysql.taobao.org/index.php?title=%E8%B5%84%E6%96%99%E5%85%B1%E4%BA%AB#MySQL.E4.B9.A6.E7.B1.8D","source":"_drafts/MySql-Reading-List.md","raw":"---\ntitle: MySql阅读清单\ntags: MySql\ncategories: \n---\n\n\n\n\n## Books\n*\t《MySQL必知必会》\n*\t《高性能MySQL》《High Performance MySQL》 Download\n*\t《Understanding MySQL Internals》\n*\t《MySQL技术内幕：InnoDB存储引擎》\t\n*\t《高可用MySQL》\n*\t《深入浅出MySQL》\n\n\n\n\n\n\n## Blogs\n*\thttp://www.penglixun.com/\n\n## others\n*\thttp://mysql.taobao.org/index.php?title=%E8%B5%84%E6%96%99%E5%85%B1%E4%BA%AB#MySQL.E4.B9.A6.E7.B1.8D","slug":"MySql-Reading-List","published":0,"date":"2016-12-29T14:46:40.000Z","updated":"2016-12-29T14:46:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciziguc3r0000nps6vr76fs3p"},{"title":"Wiring Beans In Spring","date":"2016-01-29T16:43:26.000Z","toc":true,"_content":"\n[控制反转和依赖注入](http://martinfowler.com/articles/injection.html)是Spring的核心功能，也是其他模块的基石。Spring容器控制着bean的生命周期，并维护其之间的依赖关系。如何在容器中装配（配置）这些bean是学习Spring的基础。\n\n本文将介绍如何在Spring4.0中进行bean的装配，及每种方式的特点。\n\n<!-- more -->\n\n## 自动装配（Automatically）\n\n`@ComponentScan`：用于指定扫描路径，将所有带有注解`@Component`的类注册到ioc容器中进行管理。也可以通过XML类配置`<context:component-scan>`。\n\n* `basePackages`：当没有指定扫描的包名时，默认扫描当前配置所在的包\n* `basePackageClasses`：使用`basePackages`可能会遇到一个问题：重构包名时，扫描将会失效。那么我们可以指定扫描类所在的包。有个技巧为：*在预想扫描的包里创建一个标记类，用于标记扫描的包*。\n\n`@Component`：用于说明该类将会注册到ioc容器中。\n\n* id：当没有指定id时，id为首字母小写的类名，如：beanFactory，当类为BeanFactory时。\n* `@Named`：与`@Component`有同样的功效，它是[Dependency Injection for Java](https://jcp.org/en/jsr/detail?id=330)中的规范。*不建议使用*，因为其语义很差劲。\n\n`@AutoWired`：告诉ioc容器，帮其自动解决（某方法）的依赖关系。\n\n* 使用范围：适用于构造函数、以及其他任何函数。\n* `Inject`：同`@AutoWired`。\n\n## Java代码装配（Java-based）\n\n虽然自动装配非常的诱人，简介而高效，但有些场景却无法适用。比如，当依赖一些第三方的jar包时，我们没有源码，没有办法为他们添加类似于`@Component`的注解，那我们必须在配置中明确指定依赖关系。\n\n`Configuration`：表示此类为配置文件，其中包含将要注册到容器中的Bean。\n\n`Bean`：表示此方法将会返回一个对象，并需要将其注册到容器中进行管理。\n* id：默认id为*方法名*，当然也可以显式的指定：`name=\"foo\"`。\n* 依赖关系：可以通过调用通一个配置里的方法，或者构造函数解决（不在同一个配置项中时）。\n\n## XML文件装配（XML）\n\nXML文件配置Spring历史悠久，Spring刚面世时就是基于XML来配置bean，甚至在大多数人眼中有这样的观念：spring就是XML配置。\n\n## Java-based with xml\n\n使用java-based配置时，可以引入别的java-based配置以及xml配置：\n\n* `@Import`：引入其他java-based配置\n* `@ImportResource`：引入xml配置\n\n`注意`：这里的xml必须要携带完整的路径（包括包路径），\n如：`@ImportResource(\"classpath:/com/osceola/soundsystem/cd-config.xml\")`\n\n## Xml with java-based\n\n在使用xml配置时，同样可以引入别的xml配置和java-based配置：\n\n``` xml\n<import resource=\"config.xml\" />\n\n<bean class=\"Config\" /> <!-- 想配置bean一样将java-based类配置进来 -->\n```\n\n## 推荐\n\n`Automatically` > `Java-based` > `XML`\n","source":"_posts/wiring-beans-in-spring.md","raw":"---\ntitle: Wiring Beans In Spring\ndate: 2016-01-30 00:43:26\ntags: Wiring-Beans\ncategories: Spring\ntoc: true\n---\n\n[控制反转和依赖注入](http://martinfowler.com/articles/injection.html)是Spring的核心功能，也是其他模块的基石。Spring容器控制着bean的生命周期，并维护其之间的依赖关系。如何在容器中装配（配置）这些bean是学习Spring的基础。\n\n本文将介绍如何在Spring4.0中进行bean的装配，及每种方式的特点。\n\n<!-- more -->\n\n## 自动装配（Automatically）\n\n`@ComponentScan`：用于指定扫描路径，将所有带有注解`@Component`的类注册到ioc容器中进行管理。也可以通过XML类配置`<context:component-scan>`。\n\n* `basePackages`：当没有指定扫描的包名时，默认扫描当前配置所在的包\n* `basePackageClasses`：使用`basePackages`可能会遇到一个问题：重构包名时，扫描将会失效。那么我们可以指定扫描类所在的包。有个技巧为：*在预想扫描的包里创建一个标记类，用于标记扫描的包*。\n\n`@Component`：用于说明该类将会注册到ioc容器中。\n\n* id：当没有指定id时，id为首字母小写的类名，如：beanFactory，当类为BeanFactory时。\n* `@Named`：与`@Component`有同样的功效，它是[Dependency Injection for Java](https://jcp.org/en/jsr/detail?id=330)中的规范。*不建议使用*，因为其语义很差劲。\n\n`@AutoWired`：告诉ioc容器，帮其自动解决（某方法）的依赖关系。\n\n* 使用范围：适用于构造函数、以及其他任何函数。\n* `Inject`：同`@AutoWired`。\n\n## Java代码装配（Java-based）\n\n虽然自动装配非常的诱人，简介而高效，但有些场景却无法适用。比如，当依赖一些第三方的jar包时，我们没有源码，没有办法为他们添加类似于`@Component`的注解，那我们必须在配置中明确指定依赖关系。\n\n`Configuration`：表示此类为配置文件，其中包含将要注册到容器中的Bean。\n\n`Bean`：表示此方法将会返回一个对象，并需要将其注册到容器中进行管理。\n* id：默认id为*方法名*，当然也可以显式的指定：`name=\"foo\"`。\n* 依赖关系：可以通过调用通一个配置里的方法，或者构造函数解决（不在同一个配置项中时）。\n\n## XML文件装配（XML）\n\nXML文件配置Spring历史悠久，Spring刚面世时就是基于XML来配置bean，甚至在大多数人眼中有这样的观念：spring就是XML配置。\n\n## Java-based with xml\n\n使用java-based配置时，可以引入别的java-based配置以及xml配置：\n\n* `@Import`：引入其他java-based配置\n* `@ImportResource`：引入xml配置\n\n`注意`：这里的xml必须要携带完整的路径（包括包路径），\n如：`@ImportResource(\"classpath:/com/osceola/soundsystem/cd-config.xml\")`\n\n## Xml with java-based\n\n在使用xml配置时，同样可以引入别的xml配置和java-based配置：\n\n``` xml\n<import resource=\"config.xml\" />\n\n<bean class=\"Config\" /> <!-- 想配置bean一样将java-based类配置进来 -->\n```\n\n## 推荐\n\n`Automatically` > `Java-based` > `XML`\n","slug":"wiring-beans-in-spring","published":1,"updated":"2016-02-08T02:28:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciziguc4c0003nps6mjn5towy"},{"title":"Java中的多线程（四）：同步器","date":"2016-03-30T16:15:18.000Z","toc":true,"_content":"\n多线程编程中经常会遇到线程协调问题。比如经典的生产者-消费者模式，生产者和消费者的工作需要通过一个作业队列来协调：当队列中有作业时消费者才会从队列中取出一个作业进行消费，否则将一直处于等待状态。\n\n最基础的线程协调可以通过同步机制与`wait()`结合来实现：在某个对象中设置一个标记，当修改标记后通过`notifyAll()`来通知其他等待的线程。\n\n幸运的是Java提供一些同步器来协调线程间的控制流。同步器内部封装了一些状态，这些状态将决定执行同步器的线程是继续执行还是等待。常用的同步器有阻塞队列（BlockingQueue）、闭锁（Latch）、信号量（Semaphore）和栅栏（Barrier）。\n\n<!-- more -->\n\n## 闭锁（CountDownLatch）\n[CountDownLatch](http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html)用于实现：一个或多个线程等待，直到其他线程完成某些操作。\n\nCountDownLatch通过一个`count`来初始化，而`await()`方法将一直等待直到`count`的值变为0。CountDownLatch的状态无法重置。当需要重置功能时可以考虑使用栅栏[CyclicBarrier](http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CyclicBarrier.html)。\n\nCountDownLatch常常用作开关或者一扇门，使*所有线程在门前等待，直到门被开启*。可以通过闭锁来启动一组操作，或者等待一组操作的结束。郑州\n\n``` java\npublic class LatchTest {\n\n    class Soldier implements Runnable {\n        private final CountDownLatch gate;\n        \n        public Soldier(CountDownLatch gate) {\n            this.gate = gate;\n        }\n        \n        @Override\n        public void run() {\n            try {\n                System.out.println(\"Waiting for gate open...\");\n                gate.await();\n            } catch (InterruptedException e) {\n                return;\n            }\n            \n            fight();\n        }\n        \n        private void fight() {\n            System.out.println(\"Fight... \");\n        }\n    }\n    \n    @Test\n    public void test() throws InterruptedException {\n        \n        CountDownLatch gate = new CountDownLatch(1);\n        int soldierCount = 5;\n        \n        Executor executor = Executors.newCachedThreadPool();\n        for (int i=0; i<soldierCount; i++) {\n            executor.execute(new Soldier(gate));\n        }\n        \n        Thread.sleep(500);\n        \n        System.out.println(\"gate opened!\");\n        gate.countDown();\n        \n        Thread.sleep(500);\n    }\n\n}\n```\n\n## 栅栏（Barrier）\n[Barrier](http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CyclicBarrier.html)跟CountDownLatch类似，都能阻塞一组线程直到某个事件发生。关键区别在于：*CountDownLatch等待的是事件，count通过`countDown()`变为0的事件。而Barrier等待的是其他线程。*\n\nBarrier常常用在并行迭代算法中：将一个问题拆分成一系列相互独立的子问题。如果`await()`调用超时或者被阻塞的线程被中断，那么栅栏被认为是打破了，所有其他阻塞的线程终止并抛出`BrokenBarrierException`。\n\nCyclicBarrier的构造函数支持传递一个Runable，当成功通过栅栏时会在一个子任务线程中执行它。\n\n\n## 信号量（Semaphore）\n计数信号量用来控制*同时*访问的某个资源的操作数量或实现某种*资源池*，如数据库连接池。\n\n初始值为1的信号量可以用作互斥锁，它与内置锁类似，但不可重入。\n","source":"_posts/synchronizer-in-java-concurrency.md","raw":"---\ntitle: Java中的多线程（四）：同步器\ndate: 2016-03-31 00:15:18\ntags:\n- Concurrency\n- Thread\n- Synchronizer\ncategories: Java-Core\ntoc: true\n---\n\n多线程编程中经常会遇到线程协调问题。比如经典的生产者-消费者模式，生产者和消费者的工作需要通过一个作业队列来协调：当队列中有作业时消费者才会从队列中取出一个作业进行消费，否则将一直处于等待状态。\n\n最基础的线程协调可以通过同步机制与`wait()`结合来实现：在某个对象中设置一个标记，当修改标记后通过`notifyAll()`来通知其他等待的线程。\n\n幸运的是Java提供一些同步器来协调线程间的控制流。同步器内部封装了一些状态，这些状态将决定执行同步器的线程是继续执行还是等待。常用的同步器有阻塞队列（BlockingQueue）、闭锁（Latch）、信号量（Semaphore）和栅栏（Barrier）。\n\n<!-- more -->\n\n## 闭锁（CountDownLatch）\n[CountDownLatch](http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html)用于实现：一个或多个线程等待，直到其他线程完成某些操作。\n\nCountDownLatch通过一个`count`来初始化，而`await()`方法将一直等待直到`count`的值变为0。CountDownLatch的状态无法重置。当需要重置功能时可以考虑使用栅栏[CyclicBarrier](http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CyclicBarrier.html)。\n\nCountDownLatch常常用作开关或者一扇门，使*所有线程在门前等待，直到门被开启*。可以通过闭锁来启动一组操作，或者等待一组操作的结束。郑州\n\n``` java\npublic class LatchTest {\n\n    class Soldier implements Runnable {\n        private final CountDownLatch gate;\n        \n        public Soldier(CountDownLatch gate) {\n            this.gate = gate;\n        }\n        \n        @Override\n        public void run() {\n            try {\n                System.out.println(\"Waiting for gate open...\");\n                gate.await();\n            } catch (InterruptedException e) {\n                return;\n            }\n            \n            fight();\n        }\n        \n        private void fight() {\n            System.out.println(\"Fight... \");\n        }\n    }\n    \n    @Test\n    public void test() throws InterruptedException {\n        \n        CountDownLatch gate = new CountDownLatch(1);\n        int soldierCount = 5;\n        \n        Executor executor = Executors.newCachedThreadPool();\n        for (int i=0; i<soldierCount; i++) {\n            executor.execute(new Soldier(gate));\n        }\n        \n        Thread.sleep(500);\n        \n        System.out.println(\"gate opened!\");\n        gate.countDown();\n        \n        Thread.sleep(500);\n    }\n\n}\n```\n\n## 栅栏（Barrier）\n[Barrier](http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CyclicBarrier.html)跟CountDownLatch类似，都能阻塞一组线程直到某个事件发生。关键区别在于：*CountDownLatch等待的是事件，count通过`countDown()`变为0的事件。而Barrier等待的是其他线程。*\n\nBarrier常常用在并行迭代算法中：将一个问题拆分成一系列相互独立的子问题。如果`await()`调用超时或者被阻塞的线程被中断，那么栅栏被认为是打破了，所有其他阻塞的线程终止并抛出`BrokenBarrierException`。\n\nCyclicBarrier的构造函数支持传递一个Runable，当成功通过栅栏时会在一个子任务线程中执行它。\n\n\n## 信号量（Semaphore）\n计数信号量用来控制*同时*访问的某个资源的操作数量或实现某种*资源池*，如数据库连接池。\n\n初始值为1的信号量可以用作互斥锁，它与内置锁类似，但不可重入。\n","slug":"synchronizer-in-java-concurrency","published":1,"updated":"2016-04-30T06:46:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciziguc4h0008nps6j918gsrs"},{"title":"Java中的多线程（二）：同步机制","date":"2016-03-15T03:32:44.000Z","toc":true,"_content":"\n进程中的多个线程间往往需要通信，共同完成或维护进程的目的。线程间的通信主要通过共享数据（基础类型数据，对象引用等)，这种共享数据的方式会导致两种潜在发生的错误：线程干扰（thread interference）和内存一致性错误（memory consistency errors）。而同步（synchronization）机制应运而生，用于解决上面可能出现的错误。\n\n同步机制虽然可以解决线程干扰和内存一致性问题，但也可能带来其他问题：线程竞争（thread contention）。当多个线程尝试访问同一块资源时产出了竞争关系，有可能会导致线程被挂起或者死锁。\n\n<!-- more -->\n\n## 线程干扰\n线程干扰是指，别的线程会影响当前线程执行结果的正确性。\n举个常见的栗子：`i++`。这个自增操作对应的jvm指令大概是这样：\n\n1. 内存中获取 i 的值\n2. 对 i 执行 i+1 操作\n3. 将 i+1 写入内存\n\n如果两个线程同时对某一成员执行自增操作，考虑以下场景：两个线程同时从内存中取得相同的值，执行递增操作后，写入内存的时间发生了差异。那么后执行的线程必然覆盖提前结束线程的操作结果。\n\n``` java\nclass Counter {\n    private int count = 0;\n\n    public  void increase() {\n        for (int i=0; i<100000; i++) {\n            count++;\n        }\n    }\n    \n    public  void reduce() {\n        for (int i=0; i<100000; i++) {\n            count--;\n        }\n    }\n    \n    public int getCount() {\n        return count;\n    }\n}\n\n@Test\npublic void testInterference() throws Exception {\n    Counter counter = new Counter();\n    \n    new Thread(() -> counter.increase());\n    \n    counter.reduce();\n    \n    Thread.sleep(1000);\n    // 断言将会失败\n    assertEquals(0, counter.getCount());\n}\n```\n\n## 内存一致性问题\n每个线程有自己的栈，为了提供访问效率，一般会将进程中堆上的数据做一份缓存放在自己的栈上面。那么有可能在短暂时间内会导致一个线程的修改结果对另一个线程不可见。Java提供了[happens-before](https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.5)机制来避免内存一致性问题。\n\n### happens-before\n只有当一个写操作与读操作存在happens-before关系时，才能保证此写操作的结果对那个读操作可见。同步（synchronized）、volatile关键字、Thread.start()，Thread.join()都会建立happens-before关系。\n\n* 一个线程中，每个操作与当前线程中后面的操作存在happens-before关系。\n* 未上锁的同步区块或方法与后面的锁定区块或方法存在happens-before关系（注意：这种关系是可以传递的）\n* 一个*volatile*域的写操作与随后的读操作存在happens-before关系。\n* 一个主线程与它启动的其他线程存在happens-before关系。\n* 一个线程与成功join的其他线程存在happens-before关系。\n\n## 内部锁与监视器\n同步机制的实现是通过监视器来实现：*Java中的每个对象都有一个可以被锁定或者解锁的监视器*。任何时间段里有且只可能有一个线程拥有这个监视器的锁。任何尝试对已经锁定的监视器进行再次锁定的线程都会被阻塞（当然不包括已经含有此锁的线程），直到他们获得监视器的锁。\n\n*同步语句*会计算对象的引用，并尝试对对象的监视器进行锁定操作，直到锁定操作成功后才会执行后面的操作。当同步内容执行完毕后，又会自动对监视器进行解锁操作。\n\n当一个*同步方法*被调用时，会自动进行锁定监视器的操作，同样只有锁定操作成功后才会执行方法体内的操作。对于*实例方法*，锁定的是被调用实例的监视器。而对于*静态方法*，锁定的是被调用的`Class`对象。\n\nJava中并不会避免或者检测*死锁条件*，所以应用程序必要时需要自己避免死锁。\n\n## 同步方法\n\n方法同步的影响：\n\n* 不允许对一个对象的两个方法交替调用。也就是说当一个线程正在执行某对象的同步方法时，其他调用改方法的线程将被阻塞或挂起，直到那个正在执行的线程执行完毕。\n* 当退出同步方法时，将与随后对此方法的调用自动建立happens-before关系。保证对象状态的改变对随后的线程可见。\n\n构造方法不能用于同步，因为没有意义，为什么呢？（因为只有当前线程才能创建它）。\n\n## 同步语句\n同步方法是对整个被调用的（this）*实例*或者*Class*的监视器进行锁定，而同步语句不一定要对当前被调用的实例锁定，它可以锁定指定的对象，这将非常有帮助。比如一个类中有两个成员，foo和bar，但它们并不会同时使用。所有对它们的更新都需要同步，但并不意味着两个线程不可以交叉分别更新它们。我们可以单独对它们的监视器进行锁定，针对基本类型可以分别创建一个对象锁。\n``` java\nclass MyLock {\n    private int foo;\n    private Object lockForFoo = new Object();\n    \n    private Long bar = 0L;\n    \n    public void increaseFoo() {\n        synchronized (lockForFoo) {\n            foo++;\n        }\n    }\n    \n    public void increaseBar() {\n        synchronized (bar) {\n            bar++;\n        }\n    }\n    \n    public void print() {\n        System.out.format(\"foo=%d, bar=%d%n\", foo, bar);\n    }\n}\n\n@Test\npublic void test() throws InterruptedException {\n    MyLock lock = new MyLock();\n    \n    new Thread(() -> lock.increaseFoo()).start();;\n    new Thread(() -> lock.increaseBar()).start();;\n    \n    Thread.sleep(10);\n    lock.print();\n}\n```\n\n## 多次同步\n大家已经知道一个线程只能等待另一个线程解锁监视器后才能调用其同步方法，那如果一个同步方法中会调用另外一个同步方法会怎样？答案是可以的，该线程已经获得了这个实例的内部锁，可以再次进入别的同步方法。\n\n## 原子访问\n如上所示，`c++`在多线程环境容易导致并发问题，其中一个原因为这并不是一个原子性的操作，它被分解成3个指令来执行。对于这种基本类型的增减操作，Java提供了相关的`Atomic`原子类。\n\n原子操作，意味着要么被全部执行，要么什么都不执行。虽然原子操作可以避免线程干扰的问题，但是不是在多线程环境下就一定不会有线程安全问题呢？答案是否定的，因为可能导致内存不一致问题。这时`volatile`就派上用场了。所以在使用Atomic类是需要注意内存一致性问题。\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/synchronization-in-java-concurrency.md","raw":"---\ntitle: Java中的多线程（二）：同步机制\ndate: 2016-03-15 11:32:44\ntags:\n- Concurrency\n- Thread\n- Synchronization\ncategories: Java-Core\ntoc: true\n---\n\n进程中的多个线程间往往需要通信，共同完成或维护进程的目的。线程间的通信主要通过共享数据（基础类型数据，对象引用等)，这种共享数据的方式会导致两种潜在发生的错误：线程干扰（thread interference）和内存一致性错误（memory consistency errors）。而同步（synchronization）机制应运而生，用于解决上面可能出现的错误。\n\n同步机制虽然可以解决线程干扰和内存一致性问题，但也可能带来其他问题：线程竞争（thread contention）。当多个线程尝试访问同一块资源时产出了竞争关系，有可能会导致线程被挂起或者死锁。\n\n<!-- more -->\n\n## 线程干扰\n线程干扰是指，别的线程会影响当前线程执行结果的正确性。\n举个常见的栗子：`i++`。这个自增操作对应的jvm指令大概是这样：\n\n1. 内存中获取 i 的值\n2. 对 i 执行 i+1 操作\n3. 将 i+1 写入内存\n\n如果两个线程同时对某一成员执行自增操作，考虑以下场景：两个线程同时从内存中取得相同的值，执行递增操作后，写入内存的时间发生了差异。那么后执行的线程必然覆盖提前结束线程的操作结果。\n\n``` java\nclass Counter {\n    private int count = 0;\n\n    public  void increase() {\n        for (int i=0; i<100000; i++) {\n            count++;\n        }\n    }\n    \n    public  void reduce() {\n        for (int i=0; i<100000; i++) {\n            count--;\n        }\n    }\n    \n    public int getCount() {\n        return count;\n    }\n}\n\n@Test\npublic void testInterference() throws Exception {\n    Counter counter = new Counter();\n    \n    new Thread(() -> counter.increase());\n    \n    counter.reduce();\n    \n    Thread.sleep(1000);\n    // 断言将会失败\n    assertEquals(0, counter.getCount());\n}\n```\n\n## 内存一致性问题\n每个线程有自己的栈，为了提供访问效率，一般会将进程中堆上的数据做一份缓存放在自己的栈上面。那么有可能在短暂时间内会导致一个线程的修改结果对另一个线程不可见。Java提供了[happens-before](https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.5)机制来避免内存一致性问题。\n\n### happens-before\n只有当一个写操作与读操作存在happens-before关系时，才能保证此写操作的结果对那个读操作可见。同步（synchronized）、volatile关键字、Thread.start()，Thread.join()都会建立happens-before关系。\n\n* 一个线程中，每个操作与当前线程中后面的操作存在happens-before关系。\n* 未上锁的同步区块或方法与后面的锁定区块或方法存在happens-before关系（注意：这种关系是可以传递的）\n* 一个*volatile*域的写操作与随后的读操作存在happens-before关系。\n* 一个主线程与它启动的其他线程存在happens-before关系。\n* 一个线程与成功join的其他线程存在happens-before关系。\n\n## 内部锁与监视器\n同步机制的实现是通过监视器来实现：*Java中的每个对象都有一个可以被锁定或者解锁的监视器*。任何时间段里有且只可能有一个线程拥有这个监视器的锁。任何尝试对已经锁定的监视器进行再次锁定的线程都会被阻塞（当然不包括已经含有此锁的线程），直到他们获得监视器的锁。\n\n*同步语句*会计算对象的引用，并尝试对对象的监视器进行锁定操作，直到锁定操作成功后才会执行后面的操作。当同步内容执行完毕后，又会自动对监视器进行解锁操作。\n\n当一个*同步方法*被调用时，会自动进行锁定监视器的操作，同样只有锁定操作成功后才会执行方法体内的操作。对于*实例方法*，锁定的是被调用实例的监视器。而对于*静态方法*，锁定的是被调用的`Class`对象。\n\nJava中并不会避免或者检测*死锁条件*，所以应用程序必要时需要自己避免死锁。\n\n## 同步方法\n\n方法同步的影响：\n\n* 不允许对一个对象的两个方法交替调用。也就是说当一个线程正在执行某对象的同步方法时，其他调用改方法的线程将被阻塞或挂起，直到那个正在执行的线程执行完毕。\n* 当退出同步方法时，将与随后对此方法的调用自动建立happens-before关系。保证对象状态的改变对随后的线程可见。\n\n构造方法不能用于同步，因为没有意义，为什么呢？（因为只有当前线程才能创建它）。\n\n## 同步语句\n同步方法是对整个被调用的（this）*实例*或者*Class*的监视器进行锁定，而同步语句不一定要对当前被调用的实例锁定，它可以锁定指定的对象，这将非常有帮助。比如一个类中有两个成员，foo和bar，但它们并不会同时使用。所有对它们的更新都需要同步，但并不意味着两个线程不可以交叉分别更新它们。我们可以单独对它们的监视器进行锁定，针对基本类型可以分别创建一个对象锁。\n``` java\nclass MyLock {\n    private int foo;\n    private Object lockForFoo = new Object();\n    \n    private Long bar = 0L;\n    \n    public void increaseFoo() {\n        synchronized (lockForFoo) {\n            foo++;\n        }\n    }\n    \n    public void increaseBar() {\n        synchronized (bar) {\n            bar++;\n        }\n    }\n    \n    public void print() {\n        System.out.format(\"foo=%d, bar=%d%n\", foo, bar);\n    }\n}\n\n@Test\npublic void test() throws InterruptedException {\n    MyLock lock = new MyLock();\n    \n    new Thread(() -> lock.increaseFoo()).start();;\n    new Thread(() -> lock.increaseBar()).start();;\n    \n    Thread.sleep(10);\n    lock.print();\n}\n```\n\n## 多次同步\n大家已经知道一个线程只能等待另一个线程解锁监视器后才能调用其同步方法，那如果一个同步方法中会调用另外一个同步方法会怎样？答案是可以的，该线程已经获得了这个实例的内部锁，可以再次进入别的同步方法。\n\n## 原子访问\n如上所示，`c++`在多线程环境容易导致并发问题，其中一个原因为这并不是一个原子性的操作，它被分解成3个指令来执行。对于这种基本类型的增减操作，Java提供了相关的`Atomic`原子类。\n\n原子操作，意味着要么被全部执行，要么什么都不执行。虽然原子操作可以避免线程干扰的问题，但是不是在多线程环境下就一定不会有线程安全问题呢？答案是否定的，因为可能导致内存不一致问题。这时`volatile`就派上用场了。所以在使用Atomic类是需要注意内存一致性问题。\n\n\n\n\n\n\n\n\n\n\n","slug":"synchronization-in-java-concurrency","published":1,"updated":"2016-04-30T06:45:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciziguc4m000hnps6yfjpl7uc"},{"title":"Java中的NIO","date":"2016-03-11T08:36:02.000Z","toc":true,"_content":"java.io是面向序列化得字节流，阻塞模式工作，在java.nio中引入很多新的类，它们是面向缓存、非阻塞模式工作，并且类似线程池引入了选择器来管理管道,极大的提升的I/O性能。nio是new i/o，对传统i/o的扩展，但不是替代。\n\n<!-- more -->\n\n## 路径（Path）\n[Path](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html)是`java.nio.file`中一个重要的概念。\n\n### 什么是路径\n路径在文件系统中用于定位文件。比如：在Mac OS中`/Users/Xee/logs/sys.log`就表示定位sys.log的路径。在文件操作系统中，文件都是以树或者继承的形态分布。不同的是，在Unix系统下只有一个根root目录，而在Windows下可能会存在多个卷volume。路径的组成包含根目录、根目录到文件路径上的所有中间目录和文件名本身，它们用文件系统中的分隔符连接delimiter。不同的操作系统中分隔符也不一样，Unix中为slash`/`，如`/Users/Xee/logs/sys.log`，而在Windows中为black slash`\\`，如`C:\\home\\sally\\statusReport`。\n\n### 路径类型\n路径分为绝对路径和相对路径。绝对路径包含了根目录以及定位到具体文件所需的所有文件目录。相对目录是相对于某一个文件的路径，需要结合相对的文件才能定位到想定位的问题。\n\n### `Path`的主要方法\nPath包含很多获取有关路径信息的很多方法，包括访问路径中的元素、转化路径格式、匹配路径等。这些方法大部分为静态（static）方法，因为这些操作只是针对路径本身而不需要访问文件系统。\n\n#### 创建路径\n``` java\n    Path path1 = Paths.get(\"/tmp/foo\"); // /tmp/foo\n    Path path2 = Paths.get(System.getProperty(\"user.home\"), \"bar\"); // /Users/Xee/bar\n    Path path3 = Paths.get(URI.create(\"file:///Users/Xee/logs/\"));  // /Users/Xee/logs/\n```\n创建路径可以通过[Paths](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Paths.html)的静态方法，支持通过`String`和`URI`来创建。其实它的实现是调用`FileSystems`：\n``` java\npublic static Path get(String first, String... more) {\n    return FileSystems.getDefault().getPath(first, more);\n}\n```\n\n#### 获取路径信息\n你可以将Path的存储结构想象成一个存储着路径中所有元素的列表：索引0存储的是根元素，索引n-1存储的是需要定位的文件名，n是路径中所有元素的个数。\n``` java\nPath path = Paths.get(URI.create(\"file:///Users/Xee/logs/\"));\n\nSystem.out.format(\"toString: %s%n\", path.toString());\nSystem.out.format(\"getFileName: %s%n\", path.getFileName());\nSystem.out.format(\"getName(0): %s%n\", path.getName(0));\nSystem.out.format(\"getNameCount: %d%n\", path.getNameCount());\nSystem.out.format(\"subpath(0,2): %s%n\", path.subpath(0,2));\nSystem.out.format(\"getParent: %s%n\", path.getParent());\nSystem.out.format(\"getRoot: %s%n\", path.getRoot());\n\n/* Output：\ntoString: /Users/Xee/logs\ngetFileName: logs\ngetName(0): Users\ngetNameCount: 3\nsubpath(0,2): Users/Xee\ngetParent: /Users/Xee\ngetRoot: /\n*/\n```\n\n#### 规格化路径\n`normalize()`：很多文件系统中用`.`表示当前文件夹，`..`表示父级文件夹。\n\n#### 路径转换\n* toUri：转化可以在浏览器中访问的路径\n* toRealPath：\n** 如果是相对路径，返回绝对路径\n** 如果包含`.`、`..`等路径，返回规格化的路径\n* toAbsolutePath：返回绝度路径\n* normalize：去除被简化的路径信息，返回规格化的路径（*但不改变路径类型，原先是相对路径，则还是相对路径*）\n\n``` java\n// java文件所在路径：/Users/Xee/osceola/\n// 创建相对路径\nPath path = Paths.get(\"..\");\n\nSystem.out.format(\"toString: %s%n\", path.toString());\n\nSystem.out.format(\"toUri: %s%n\", path.toUri());\n\n// 返回真实路径，去除被简化的信息“..”\nSystem.out.format(\"toRealPath: %s%n\", path.toRealPath(LinkOption.NOFOLLOW_LINKS).toString());\n\n// 返回绝对路径，但包含简化的“..”\nSystem.out.format(\"toAbsolutePath: %s%n\", path.toAbsolutePath().toString());\n\n/* Output:\ntoString: ..\ntoUri: file:///Users/Xee/osceola/../\ntoRealPath: /Users/Xee/\ntoAbsolutePath: /Users/Xee/osceola/..\n*/\n\n```\n\n#### 解析相对路径\n``` java\nPath path = Paths.get(URI.create(\"file:///Users/Xee/logs/\"));\nSystem.out.format(\"toString: %s%n\", path.resolve(\"..\").toRealPath(NOFOLLOW_LINKS));\n\n/* Output:\ntoString: /Users/Xee\n*/\n```\n\n#### 创建相对路径\n``` java\nPath home = Paths.get(\"/Users/Xee\");\nPath sysLog = Paths.get(\"/Users/Xee/log/sys.log\");\n\nSystem.out.format(\"home_to_sysLog: %s%n\", home.relativize(sysLog));\nSystem.out.format(\"sysLog_to_home: %s%n\", sysLog.relativize(home));\n\n/* Output:\nhome_to_sysLog: log/sys.log\nsysLog_to_home: ../..\n*/\n```\n\n#### 路径比较\n`equals`，`startsWith`，`endsWith`：值得注意的是，这里比较的是*存储列表中的元素*，而不是真实路径*realPath*。\n\n#### 遍历路径中的元素\n因为Path实现了`Iterable`接口，所以可以通过迭代器遍历存储结构中的元素。\n\n## Files基本操作\n[Files](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html)包含了大量的静态方法，这些方法依赖Path实例。\n\n而实现一般是通过`path.getFileSystem().provider()`获取`FileSystemProvider`来执行具体操作。\n\n### 检查操作\n\n#### 文件存在性判断\n*注意：* \n* 文件存在与否可能有三种结果：存在，不存在 或者 未知（没有权限）。\n* 查询结果具有时效性，返回结果表示存在，但当你访问是可能不存在（已被删除）\n\n#### 文件访问权限判断\n可读性、可写性和可执行性。\n\n#### 路径定位是否同一文件\n特别是用于判断软连接定位的文件\n``` java\nif (Files.isSameFile(p1, p2)) {\n    \n}\n```\n### 删除、移动、复制\n#### 删除\n可以删除文件、目录和链接。\n\n* 如果删除的是链接，链接指向的真正文件是不会被删除的。\n* 如果删除的是目录不为空，则删除失败。\n\n#### 复制\n复制文件时值得注意的是[Path copy(Path source, Path target, CopyOption... options)](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#copy-java.nio.file.Path-java.nio.file.Path-java.nio.file.CopyOption...-)中*StandardCopyOption*选项：\n如果目标文件存在，那么复制操作失败，除非指定`REPLACE_EXISTING`选项进行覆盖。\n\n同时还支持字节流与Path之间的复制。\n\n*注意*：复制目录时，只会复制目录本身而不会递归复制。StandardCopyOption中也没有这个枚举类型。\n\n#### 移动/重命名\n*注意*：\n* 如果是在同个目录下移动，等价于*重命名*\n* 移动目录时，目录里的子文件、子目录也会随着移动（跟复制有差别，复制时不会递归复制）。当然前提是源目录和目标目录在同一个[FileStore](https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileStore.html)中：同一个卷、移动设备等。\n\n## 文件元数据（文件属性）\n文件的元数据包含在文件或者目录中，如是不是一个常规文件，还是一个目录或者一个链接。它的大小是多少，创建时间，最后修改时间，文件所属者，所属用户组和访问权限。\n\n一个文件系统的元数据通常指文件的属性。`Files`中包含了获取以及设置这些属性的方法：\n``` xml\n+----------------------------------------------+--------------------------------------------------+\n| Method                                       | Comment                                          |\n+----------------------------------------------+--------------------------------------------------+\n| size(Path)                                   | Returns the size of the specified file in bytes. |\n+----------------------------------------------+--------------------------------------------------+\n| isDirectory(Path, LinkOption)                | Returns true if the file is a directory.         |\n+----------------------------------------------+--------------------------------------------------+\n| isRegularFile(Path, LinkOption...)           | Returns true if the file is a regular file.      |\n+----------------------------------------------+--------------------------------------------------+\n| isSymbolicLink(Path)                         | Returns true if the file is a symbolic link.     |\n+----------------------------------------------+--------------------------------------------------+\n| isHidden(Path)                               | Returns true if the file is considered hidden.   |\n+----------------------------------------------+--------------------------------------------------+\n| getLastModifiedTime(Path, LinkOption...)     | Returns the specified file's last modified time. |\n+----------------------------------------------+--------------------------------------------------+\n| getOwner(Path, LinkOption...)                | Returns the owner of the file.                   |\n+----------------------------------------------+--------------------------------------------------+\n| getPosixFilePermissions(Path, LinkOption...) | Returns a file's POSIX file permissions.         |\n+----------------------------------------------+--------------------------------------------------+\n| getAttribute(Path, String, LinkOption...)    | Returns the value of a file attribute.           |\n+----------------------------------------------+--------------------------------------------------+\n```\n\n如果想要一次获取多个属性，Files也是支持的，并且效率大大优于分别取获取单个属性：\n``` xml\n+----------------------------------------------+------------------------------------------------------------+\n| Method                                       | Comment                                                    |\n+----------------------------------------------+------------------------------------------------------------+\n| readAttributes(Path, String, LinkOption...)  | The String parameter identifies the attributes to be read. |\n+----------------------------------------------+------------------------------------------------------------+\n|readAttributes(Path, Class<A>, LinkOption...) | The Class<A> parameter is the type of attributes requested.|\n+----------------------------------------------+------------------------------------------------------------+\n\n```\n\n### 基本文件属性\n``` java\nPath file = Paths.get(System.getProperty(\"user.home\"));\n        \nMap<String, Object> attributesMap = Files.readAttributes(file, \"*\");\n\nfor (Entry<String, Object> entry : attributesMap.entrySet()) {\n    System.out.println(entry.getKey() + \" = \" + entry.getValue());\n}\n\n/** Output:\nlastAccessTime = 2016-03-12T09:48:48Z\nlastModifiedTime = 2016-03-12T09:48:49Z\nsize = 2686\ncreationTime = 2015-11-27T02:23:57Z\nisSymbolicLink = false\nisRegularFile = false\nfileKey = (dev=1000004,ino=611925)\nisOther = false\nisDirectory = true\n*/\n```\n\n### 设置文件时间戳\n``` java\nPath file = Paths.get(System.getProperty(\"user.home\"));\n\nFileTime currentTime = FileTime.fromMillis(System.currentTimeMillis());\n\n// 修改“最后修改时间”\nFiles.setLastModifiedTime(file, currentTime);\n\nFileTime lastModifiedTime = (FileTime) Files.getAttribute(file, \"lastModifiedTime\");\n\n// 最后修改时间只能精确到秒\nassertNotEquals(currentTime.toMillis(), lastModifiedTime.toMillis());\nassertEquals(currentTime.to(TimeUnit.SECONDS), lastModifiedTime.to(TimeUnit.SECONDS));\n```\n\n### 其他属性获取\n* [BasicFileAttributes](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/BasicFileAttributes.html)\n* [DosFileAttributes](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/DosFileAttributes.html)\n* [PosixFileAttributes](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/PosixFileAttributes.html)\n\n### 其他属性设置\n* [BasicFileAttributeView](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/BasicFileAttributeView.html)\n* [DosFileAttributeView](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/DosFileAttributeView.html)\n* [PosixFileAttributeView](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/PosixFileAttributeView.html)\n* [AclFileAttributeView](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/AclFileAttributeView.html)\n* [UserDefinedFileAttributeView](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/UserDefinedFileAttributeView.html)\n\n## 文件的读取、修改与创建\n### OpenOption参数\nOpenOption参数是进行文件内容操作的可选参数，其中`StandardOpenOption`支持：\n\n* READ\n* WRITE\n* APPEND\n* TRUNCATE_EXISTING：只有在支持WRITE时生效\n* CREATE\n* CREATE_NEW：只有文件不存在时才创建\n* DELETE_ON_CLOSE：\n* SPARSE\n* SYNC：内容及元数据同步\n* DSYNC：仅仅内容同步\n\n### 常用操作\n主要有`readAllBytes`、`readAllLines`、`write(Path, byte[])`、`write(Path, Iterable<? extends CharSequence>`，详见下面的demo：\n\n``` java\nPath path = Paths.get(System.getProperty(\"user.home\"), \"text\");\n\n// 读取所有字节数组\nbyte[] bytes = Files.readAllBytes(path);\nByteArrayInputStream inputStream = new ByteArrayInputStream(bytes);\n\nScanner scanner = new Scanner(new BufferedReader(new InputStreamReader(inputStream)));\nwhile (scanner.hasNextLine()) {\n    System.out.println(scanner.nextLine());\n}\n\n// 读取所有行\nList<String> lines = Files.readAllLines(path);\nlines.forEach(System.out::println);\nscanner.close();\n        \n// 默认的OpenOption：CREATE，TRUNCATE_EXISTING，WRITE\nFiles.write(path, \"Hello World\".getBytes());\n\nFiles.write(path, Arrays.asList(new String[]{\"Hello World\", \"Hello NIO\"}));\n```\n\n### 面向具有缓存功能io的操作\n``` java\nPath path = Paths.get(System.getProperty(\"user.home\"), \"text\");\n\n// 创建BufferedReader\nBufferedReader reader = Files.newBufferedReader(path);\nString line = null;\nwhile ((line = reader.readLine()) != null) {\n    System.out.println(line);\n}\nreader.close();\n\nBufferedWriter write = Files.newBufferedWriter(path);\nwrite.write(\"Hello NIO\");\nwrite.close();\n```\n\n### 面向不具有缓存功能io的操作\n``` java\nPath path = Paths.get(System.getProperty(\"user.home\"), \"text\");\n\nInputStream inputStream = Files.newInputStream(path);\nScanner scanner = new Scanner(new BufferedReader(new InputStreamReader(inputStream)));\nwhile (scanner.hasNextLine()) {\n    System.out.println(scanner.nextLine());\n}\nscanner.close();\n\nOutputStream outputStream = Files.newOutputStream(path);\nPrintWriter writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\nwriter.write(\"Hello World\");\nwriter.close();\n```\n\n### 面向管道的操作\n普通流每次读取一个字符，而管道每次读取一块缓存，这也是NIO与传统IO一个重要的区别。\n\n#### 读取缓存字节\n``` java\nPath path = Paths.get(System.getProperty(\"user.home\"), \"text\");\n\nSeekableByteChannel channel = Files.newByteChannel(path);\n\nByteBuffer buffer = ByteBuffer.allocate(3);\nwhile (channel.read(buffer) > 0) {\n    buffer.flip();\n    System.out.println(Charset.forName(System.getProperty(\"file.encoding\")).decode(buffer));\n    buf.compact();\n}\n\nchannel.close();\n```\n\n#### 写入缓存字节\n管道可以读，也可以写。通过Files创建管道时默认是READ，当需要写操作是需要传入WRITE操作\n``` java\nPath path = Paths.get(System.getProperty(\"user.home\"), \"text\");\n\n// 设置可写操作\nSeekableByteChannel channel = Files.newByteChannel(path, EnumSet.of(CREATE, WRITE));\n\nByteBuffer buffer = ByteBuffer.wrap(\"Hello World\".getBytes());\nchannel.write(buffer);\nchannel.close();\n```\n\n### 创建文件\n``` java\nPath path = Paths.get(System.getProperty(\"user.home\"), \"text\");\n        \nFiles.createFile(path, asFileAttribute(fromString(\"rw-r-----\")));\n```\n\n#### 创建临时文件\n``` java\nPath file = createTempFile(null, \".xxy\");\nSystem.out.println(file);\n\nPosixFileAttributes attrbutes = readAttributes(file, PosixFileAttributes.class);\n// 默认权限为 \"rx-------\"\nSystem.out.println(attrbutes.permissions());\n```\n\n## 文件目录\n``` java\n// 系统根目录\nFileSystems.getDefault().getRootDirectories().forEach(System.out::println);\n\n// 创建目录或递归创建目录\nFiles.createDirectory(Paths.get(System.getProperty(\"user.home\"), \"tmp\"));\nFiles.createDirectories(Paths.get(System.getProperty(\"user.home\"), \"tmp/a/b/c\"));\n\n// 遍历目录内容\nFiles.newDirectoryStream(Paths.get(System.getProperty(\"user.home\"))).forEach(System.out::println);\n\n// 目录内容过滤，当然你也可以创建自己的过滤器\nFiles.newDirectoryStream(Paths.get(System.getProperty(\"user.home\")), \".py\").forEach(System.out::println);\n```\n\n## 递归遍历文件夹\n在日常应用中经常需要递归遍历某个文件夹寻找某个文件、或进行访问操作，这时可以使用Files提供的`walkFileTree`方法，不过你需要实现`FileVisitor`接口，自定义遍历时的逻辑。\n\n### FileVisitor\nFileVisitor接口定义了遍历文件树时的具体行为：访问一个文件时，访问一个目录前，访问一个目录后，以及访问出错时。\n\n访问文件树时可支持自定义深度：`walkFileTree(Path, Set<FileVisitOption>, int, FileVisitor)`\n\n### `FileVisitor`的实现\n实现具体的遍历行为时，可以通过继承`SimpleFileVisitor`，但需要注意：\n\n1. 递归删除文件时，那么就需要*在删除了目录里内容后，再删除目录本身*。\n2. 递归创建文件时，顺序则相反\n3. 递归修改文件权限时同样需要考虑，因为修改权限后，可能会导致你无法访问。\n\n### 便利流程的控制\n[FileVisitResult](https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileVisitResult.html)是FileVisitor中每个方法的返回值，包括：继续（CONTINUE），终止（TERMINATE），跳过此目录（SKIP_SUBTREE），跳过同级文件或目录（SKIP_SIBLINGS）。\n\n## 文件搜索\n搜索文件可以理解为：递归遍历文件夹，然后一一进行对文件名称匹配。由于在NIO中的核心模型为Path（传统io为File），所以NIO中同样提供了用于路径匹配的`PathMatcher`：\n``` java\npublic interface PathMatcher {\n    \n    boolean matches(Path path);\n}\n```\n\n### 路径匹配\nPathMatcher可以用过`FileSystem`的[getPathMatcher(String)](https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#getPathMatcher-java.lang.String-)方法实例化。\n\n创建PathMatcher时的语法为：`syntax:pattern`。FileSystem支持[glob](http://docs.oracle.com/javase/tutorial/essential/io/fileOps.html#glob)、[regex](http://docs.oracle.com/javase/tutorial/essential/regex/index.html)两种语法。\n\n#### glob\n* `*`表示匹配0个或多个字符（但没有跨越目录）\n* `**`表示匹配0个或多个字符（跨目录）\n* `?`表示匹配0个或1个字符\n* `\\`为转义字符，用来匹配`*`、`?`等\n* `[ ]`表示匹配一组字符中的1个字符，比如“[abc]”可以匹配“a”、“b”或者“c”。\n  常常结合`-`一起使用，表示范围。如“[a-z]”可以匹配从“a”到“z”的所有单个字符。\n  有时也会搭配`!`来使用表示取反，如[!a-c]表示可以匹配任何字符但除了“a”、“b”、“c”。\n\n  *注意：* 方括号中的`*`，`?`，`\\`不在具有上述统配意义，将匹配它们本身表示的字符。而`-`符号为第一字符，也就是不再表示范围时，也表示它本身代表的字符。\n* `{ }`表示匹配一组字符串中的任意一个，但不能嵌套使用。`,`为分隔符。\n* `.`开头的字符串视为常规的字符，不要理解为正则中的任意字符。\n\n比如我们要匹配所有java文件，可以这么来创建：\n``` java\nPathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:a.java\");\n\n// 一定要使用 getFileName\nif (matcher.matches(file.getFileName())) {\n    // TODO something\n}\n```\n需要注意的是，一定要使用`getFileName`，因为file一般表示从root到文件中的所有元素。\n\n#### regex\n参见[oracle上的教程](http://docs.oracle.com/javase/tutorial/essential/regex/index.html)。\n\n## 与`java.io.File`的比较\nJDK7发布前File是主要的I/O类，但它具有很多缺点：\n\n* 很多方法失败时不会抛出明确异常。比如文件删除失败时，你无法得知是文件不存在还是没有权限。\n* 不能友好的支持文件连接。\n* 不能全面的支持文件元数据，如Ownner，permission等。\n* 不能友好的支持递归遍历目录。\n\n### Path与File的转化\n``` java\nPath input = file.toPath();\nFiles.delete(fp);\n```\n\n其他场景的转化参见：[官方文档](http://docs.oracle.com/javase/tutorial/essential/io/legacy.html#mapping)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 参考资料\n* [http://tutorials.jenkov.com/java-nio/index.html](http://tutorials.jenkov.com/java-nio/index.html)\n\n\n\n\n","source":"_posts/nio-in-java.md","raw":"---\ntitle: Java中的NIO\ndate: 2016-03-11 16:36:02\ntags: NIO\ncategories: Java-Core\ntoc: true\n---\njava.io是面向序列化得字节流，阻塞模式工作，在java.nio中引入很多新的类，它们是面向缓存、非阻塞模式工作，并且类似线程池引入了选择器来管理管道,极大的提升的I/O性能。nio是new i/o，对传统i/o的扩展，但不是替代。\n\n<!-- more -->\n\n## 路径（Path）\n[Path](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html)是`java.nio.file`中一个重要的概念。\n\n### 什么是路径\n路径在文件系统中用于定位文件。比如：在Mac OS中`/Users/Xee/logs/sys.log`就表示定位sys.log的路径。在文件操作系统中，文件都是以树或者继承的形态分布。不同的是，在Unix系统下只有一个根root目录，而在Windows下可能会存在多个卷volume。路径的组成包含根目录、根目录到文件路径上的所有中间目录和文件名本身，它们用文件系统中的分隔符连接delimiter。不同的操作系统中分隔符也不一样，Unix中为slash`/`，如`/Users/Xee/logs/sys.log`，而在Windows中为black slash`\\`，如`C:\\home\\sally\\statusReport`。\n\n### 路径类型\n路径分为绝对路径和相对路径。绝对路径包含了根目录以及定位到具体文件所需的所有文件目录。相对目录是相对于某一个文件的路径，需要结合相对的文件才能定位到想定位的问题。\n\n### `Path`的主要方法\nPath包含很多获取有关路径信息的很多方法，包括访问路径中的元素、转化路径格式、匹配路径等。这些方法大部分为静态（static）方法，因为这些操作只是针对路径本身而不需要访问文件系统。\n\n#### 创建路径\n``` java\n    Path path1 = Paths.get(\"/tmp/foo\"); // /tmp/foo\n    Path path2 = Paths.get(System.getProperty(\"user.home\"), \"bar\"); // /Users/Xee/bar\n    Path path3 = Paths.get(URI.create(\"file:///Users/Xee/logs/\"));  // /Users/Xee/logs/\n```\n创建路径可以通过[Paths](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Paths.html)的静态方法，支持通过`String`和`URI`来创建。其实它的实现是调用`FileSystems`：\n``` java\npublic static Path get(String first, String... more) {\n    return FileSystems.getDefault().getPath(first, more);\n}\n```\n\n#### 获取路径信息\n你可以将Path的存储结构想象成一个存储着路径中所有元素的列表：索引0存储的是根元素，索引n-1存储的是需要定位的文件名，n是路径中所有元素的个数。\n``` java\nPath path = Paths.get(URI.create(\"file:///Users/Xee/logs/\"));\n\nSystem.out.format(\"toString: %s%n\", path.toString());\nSystem.out.format(\"getFileName: %s%n\", path.getFileName());\nSystem.out.format(\"getName(0): %s%n\", path.getName(0));\nSystem.out.format(\"getNameCount: %d%n\", path.getNameCount());\nSystem.out.format(\"subpath(0,2): %s%n\", path.subpath(0,2));\nSystem.out.format(\"getParent: %s%n\", path.getParent());\nSystem.out.format(\"getRoot: %s%n\", path.getRoot());\n\n/* Output：\ntoString: /Users/Xee/logs\ngetFileName: logs\ngetName(0): Users\ngetNameCount: 3\nsubpath(0,2): Users/Xee\ngetParent: /Users/Xee\ngetRoot: /\n*/\n```\n\n#### 规格化路径\n`normalize()`：很多文件系统中用`.`表示当前文件夹，`..`表示父级文件夹。\n\n#### 路径转换\n* toUri：转化可以在浏览器中访问的路径\n* toRealPath：\n** 如果是相对路径，返回绝对路径\n** 如果包含`.`、`..`等路径，返回规格化的路径\n* toAbsolutePath：返回绝度路径\n* normalize：去除被简化的路径信息，返回规格化的路径（*但不改变路径类型，原先是相对路径，则还是相对路径*）\n\n``` java\n// java文件所在路径：/Users/Xee/osceola/\n// 创建相对路径\nPath path = Paths.get(\"..\");\n\nSystem.out.format(\"toString: %s%n\", path.toString());\n\nSystem.out.format(\"toUri: %s%n\", path.toUri());\n\n// 返回真实路径，去除被简化的信息“..”\nSystem.out.format(\"toRealPath: %s%n\", path.toRealPath(LinkOption.NOFOLLOW_LINKS).toString());\n\n// 返回绝对路径，但包含简化的“..”\nSystem.out.format(\"toAbsolutePath: %s%n\", path.toAbsolutePath().toString());\n\n/* Output:\ntoString: ..\ntoUri: file:///Users/Xee/osceola/../\ntoRealPath: /Users/Xee/\ntoAbsolutePath: /Users/Xee/osceola/..\n*/\n\n```\n\n#### 解析相对路径\n``` java\nPath path = Paths.get(URI.create(\"file:///Users/Xee/logs/\"));\nSystem.out.format(\"toString: %s%n\", path.resolve(\"..\").toRealPath(NOFOLLOW_LINKS));\n\n/* Output:\ntoString: /Users/Xee\n*/\n```\n\n#### 创建相对路径\n``` java\nPath home = Paths.get(\"/Users/Xee\");\nPath sysLog = Paths.get(\"/Users/Xee/log/sys.log\");\n\nSystem.out.format(\"home_to_sysLog: %s%n\", home.relativize(sysLog));\nSystem.out.format(\"sysLog_to_home: %s%n\", sysLog.relativize(home));\n\n/* Output:\nhome_to_sysLog: log/sys.log\nsysLog_to_home: ../..\n*/\n```\n\n#### 路径比较\n`equals`，`startsWith`，`endsWith`：值得注意的是，这里比较的是*存储列表中的元素*，而不是真实路径*realPath*。\n\n#### 遍历路径中的元素\n因为Path实现了`Iterable`接口，所以可以通过迭代器遍历存储结构中的元素。\n\n## Files基本操作\n[Files](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html)包含了大量的静态方法，这些方法依赖Path实例。\n\n而实现一般是通过`path.getFileSystem().provider()`获取`FileSystemProvider`来执行具体操作。\n\n### 检查操作\n\n#### 文件存在性判断\n*注意：* \n* 文件存在与否可能有三种结果：存在，不存在 或者 未知（没有权限）。\n* 查询结果具有时效性，返回结果表示存在，但当你访问是可能不存在（已被删除）\n\n#### 文件访问权限判断\n可读性、可写性和可执行性。\n\n#### 路径定位是否同一文件\n特别是用于判断软连接定位的文件\n``` java\nif (Files.isSameFile(p1, p2)) {\n    \n}\n```\n### 删除、移动、复制\n#### 删除\n可以删除文件、目录和链接。\n\n* 如果删除的是链接，链接指向的真正文件是不会被删除的。\n* 如果删除的是目录不为空，则删除失败。\n\n#### 复制\n复制文件时值得注意的是[Path copy(Path source, Path target, CopyOption... options)](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#copy-java.nio.file.Path-java.nio.file.Path-java.nio.file.CopyOption...-)中*StandardCopyOption*选项：\n如果目标文件存在，那么复制操作失败，除非指定`REPLACE_EXISTING`选项进行覆盖。\n\n同时还支持字节流与Path之间的复制。\n\n*注意*：复制目录时，只会复制目录本身而不会递归复制。StandardCopyOption中也没有这个枚举类型。\n\n#### 移动/重命名\n*注意*：\n* 如果是在同个目录下移动，等价于*重命名*\n* 移动目录时，目录里的子文件、子目录也会随着移动（跟复制有差别，复制时不会递归复制）。当然前提是源目录和目标目录在同一个[FileStore](https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileStore.html)中：同一个卷、移动设备等。\n\n## 文件元数据（文件属性）\n文件的元数据包含在文件或者目录中，如是不是一个常规文件，还是一个目录或者一个链接。它的大小是多少，创建时间，最后修改时间，文件所属者，所属用户组和访问权限。\n\n一个文件系统的元数据通常指文件的属性。`Files`中包含了获取以及设置这些属性的方法：\n``` xml\n+----------------------------------------------+--------------------------------------------------+\n| Method                                       | Comment                                          |\n+----------------------------------------------+--------------------------------------------------+\n| size(Path)                                   | Returns the size of the specified file in bytes. |\n+----------------------------------------------+--------------------------------------------------+\n| isDirectory(Path, LinkOption)                | Returns true if the file is a directory.         |\n+----------------------------------------------+--------------------------------------------------+\n| isRegularFile(Path, LinkOption...)           | Returns true if the file is a regular file.      |\n+----------------------------------------------+--------------------------------------------------+\n| isSymbolicLink(Path)                         | Returns true if the file is a symbolic link.     |\n+----------------------------------------------+--------------------------------------------------+\n| isHidden(Path)                               | Returns true if the file is considered hidden.   |\n+----------------------------------------------+--------------------------------------------------+\n| getLastModifiedTime(Path, LinkOption...)     | Returns the specified file's last modified time. |\n+----------------------------------------------+--------------------------------------------------+\n| getOwner(Path, LinkOption...)                | Returns the owner of the file.                   |\n+----------------------------------------------+--------------------------------------------------+\n| getPosixFilePermissions(Path, LinkOption...) | Returns a file's POSIX file permissions.         |\n+----------------------------------------------+--------------------------------------------------+\n| getAttribute(Path, String, LinkOption...)    | Returns the value of a file attribute.           |\n+----------------------------------------------+--------------------------------------------------+\n```\n\n如果想要一次获取多个属性，Files也是支持的，并且效率大大优于分别取获取单个属性：\n``` xml\n+----------------------------------------------+------------------------------------------------------------+\n| Method                                       | Comment                                                    |\n+----------------------------------------------+------------------------------------------------------------+\n| readAttributes(Path, String, LinkOption...)  | The String parameter identifies the attributes to be read. |\n+----------------------------------------------+------------------------------------------------------------+\n|readAttributes(Path, Class<A>, LinkOption...) | The Class<A> parameter is the type of attributes requested.|\n+----------------------------------------------+------------------------------------------------------------+\n\n```\n\n### 基本文件属性\n``` java\nPath file = Paths.get(System.getProperty(\"user.home\"));\n        \nMap<String, Object> attributesMap = Files.readAttributes(file, \"*\");\n\nfor (Entry<String, Object> entry : attributesMap.entrySet()) {\n    System.out.println(entry.getKey() + \" = \" + entry.getValue());\n}\n\n/** Output:\nlastAccessTime = 2016-03-12T09:48:48Z\nlastModifiedTime = 2016-03-12T09:48:49Z\nsize = 2686\ncreationTime = 2015-11-27T02:23:57Z\nisSymbolicLink = false\nisRegularFile = false\nfileKey = (dev=1000004,ino=611925)\nisOther = false\nisDirectory = true\n*/\n```\n\n### 设置文件时间戳\n``` java\nPath file = Paths.get(System.getProperty(\"user.home\"));\n\nFileTime currentTime = FileTime.fromMillis(System.currentTimeMillis());\n\n// 修改“最后修改时间”\nFiles.setLastModifiedTime(file, currentTime);\n\nFileTime lastModifiedTime = (FileTime) Files.getAttribute(file, \"lastModifiedTime\");\n\n// 最后修改时间只能精确到秒\nassertNotEquals(currentTime.toMillis(), lastModifiedTime.toMillis());\nassertEquals(currentTime.to(TimeUnit.SECONDS), lastModifiedTime.to(TimeUnit.SECONDS));\n```\n\n### 其他属性获取\n* [BasicFileAttributes](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/BasicFileAttributes.html)\n* [DosFileAttributes](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/DosFileAttributes.html)\n* [PosixFileAttributes](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/PosixFileAttributes.html)\n\n### 其他属性设置\n* [BasicFileAttributeView](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/BasicFileAttributeView.html)\n* [DosFileAttributeView](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/DosFileAttributeView.html)\n* [PosixFileAttributeView](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/PosixFileAttributeView.html)\n* [AclFileAttributeView](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/AclFileAttributeView.html)\n* [UserDefinedFileAttributeView](https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/UserDefinedFileAttributeView.html)\n\n## 文件的读取、修改与创建\n### OpenOption参数\nOpenOption参数是进行文件内容操作的可选参数，其中`StandardOpenOption`支持：\n\n* READ\n* WRITE\n* APPEND\n* TRUNCATE_EXISTING：只有在支持WRITE时生效\n* CREATE\n* CREATE_NEW：只有文件不存在时才创建\n* DELETE_ON_CLOSE：\n* SPARSE\n* SYNC：内容及元数据同步\n* DSYNC：仅仅内容同步\n\n### 常用操作\n主要有`readAllBytes`、`readAllLines`、`write(Path, byte[])`、`write(Path, Iterable<? extends CharSequence>`，详见下面的demo：\n\n``` java\nPath path = Paths.get(System.getProperty(\"user.home\"), \"text\");\n\n// 读取所有字节数组\nbyte[] bytes = Files.readAllBytes(path);\nByteArrayInputStream inputStream = new ByteArrayInputStream(bytes);\n\nScanner scanner = new Scanner(new BufferedReader(new InputStreamReader(inputStream)));\nwhile (scanner.hasNextLine()) {\n    System.out.println(scanner.nextLine());\n}\n\n// 读取所有行\nList<String> lines = Files.readAllLines(path);\nlines.forEach(System.out::println);\nscanner.close();\n        \n// 默认的OpenOption：CREATE，TRUNCATE_EXISTING，WRITE\nFiles.write(path, \"Hello World\".getBytes());\n\nFiles.write(path, Arrays.asList(new String[]{\"Hello World\", \"Hello NIO\"}));\n```\n\n### 面向具有缓存功能io的操作\n``` java\nPath path = Paths.get(System.getProperty(\"user.home\"), \"text\");\n\n// 创建BufferedReader\nBufferedReader reader = Files.newBufferedReader(path);\nString line = null;\nwhile ((line = reader.readLine()) != null) {\n    System.out.println(line);\n}\nreader.close();\n\nBufferedWriter write = Files.newBufferedWriter(path);\nwrite.write(\"Hello NIO\");\nwrite.close();\n```\n\n### 面向不具有缓存功能io的操作\n``` java\nPath path = Paths.get(System.getProperty(\"user.home\"), \"text\");\n\nInputStream inputStream = Files.newInputStream(path);\nScanner scanner = new Scanner(new BufferedReader(new InputStreamReader(inputStream)));\nwhile (scanner.hasNextLine()) {\n    System.out.println(scanner.nextLine());\n}\nscanner.close();\n\nOutputStream outputStream = Files.newOutputStream(path);\nPrintWriter writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\nwriter.write(\"Hello World\");\nwriter.close();\n```\n\n### 面向管道的操作\n普通流每次读取一个字符，而管道每次读取一块缓存，这也是NIO与传统IO一个重要的区别。\n\n#### 读取缓存字节\n``` java\nPath path = Paths.get(System.getProperty(\"user.home\"), \"text\");\n\nSeekableByteChannel channel = Files.newByteChannel(path);\n\nByteBuffer buffer = ByteBuffer.allocate(3);\nwhile (channel.read(buffer) > 0) {\n    buffer.flip();\n    System.out.println(Charset.forName(System.getProperty(\"file.encoding\")).decode(buffer));\n    buf.compact();\n}\n\nchannel.close();\n```\n\n#### 写入缓存字节\n管道可以读，也可以写。通过Files创建管道时默认是READ，当需要写操作是需要传入WRITE操作\n``` java\nPath path = Paths.get(System.getProperty(\"user.home\"), \"text\");\n\n// 设置可写操作\nSeekableByteChannel channel = Files.newByteChannel(path, EnumSet.of(CREATE, WRITE));\n\nByteBuffer buffer = ByteBuffer.wrap(\"Hello World\".getBytes());\nchannel.write(buffer);\nchannel.close();\n```\n\n### 创建文件\n``` java\nPath path = Paths.get(System.getProperty(\"user.home\"), \"text\");\n        \nFiles.createFile(path, asFileAttribute(fromString(\"rw-r-----\")));\n```\n\n#### 创建临时文件\n``` java\nPath file = createTempFile(null, \".xxy\");\nSystem.out.println(file);\n\nPosixFileAttributes attrbutes = readAttributes(file, PosixFileAttributes.class);\n// 默认权限为 \"rx-------\"\nSystem.out.println(attrbutes.permissions());\n```\n\n## 文件目录\n``` java\n// 系统根目录\nFileSystems.getDefault().getRootDirectories().forEach(System.out::println);\n\n// 创建目录或递归创建目录\nFiles.createDirectory(Paths.get(System.getProperty(\"user.home\"), \"tmp\"));\nFiles.createDirectories(Paths.get(System.getProperty(\"user.home\"), \"tmp/a/b/c\"));\n\n// 遍历目录内容\nFiles.newDirectoryStream(Paths.get(System.getProperty(\"user.home\"))).forEach(System.out::println);\n\n// 目录内容过滤，当然你也可以创建自己的过滤器\nFiles.newDirectoryStream(Paths.get(System.getProperty(\"user.home\")), \".py\").forEach(System.out::println);\n```\n\n## 递归遍历文件夹\n在日常应用中经常需要递归遍历某个文件夹寻找某个文件、或进行访问操作，这时可以使用Files提供的`walkFileTree`方法，不过你需要实现`FileVisitor`接口，自定义遍历时的逻辑。\n\n### FileVisitor\nFileVisitor接口定义了遍历文件树时的具体行为：访问一个文件时，访问一个目录前，访问一个目录后，以及访问出错时。\n\n访问文件树时可支持自定义深度：`walkFileTree(Path, Set<FileVisitOption>, int, FileVisitor)`\n\n### `FileVisitor`的实现\n实现具体的遍历行为时，可以通过继承`SimpleFileVisitor`，但需要注意：\n\n1. 递归删除文件时，那么就需要*在删除了目录里内容后，再删除目录本身*。\n2. 递归创建文件时，顺序则相反\n3. 递归修改文件权限时同样需要考虑，因为修改权限后，可能会导致你无法访问。\n\n### 便利流程的控制\n[FileVisitResult](https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileVisitResult.html)是FileVisitor中每个方法的返回值，包括：继续（CONTINUE），终止（TERMINATE），跳过此目录（SKIP_SUBTREE），跳过同级文件或目录（SKIP_SIBLINGS）。\n\n## 文件搜索\n搜索文件可以理解为：递归遍历文件夹，然后一一进行对文件名称匹配。由于在NIO中的核心模型为Path（传统io为File），所以NIO中同样提供了用于路径匹配的`PathMatcher`：\n``` java\npublic interface PathMatcher {\n    \n    boolean matches(Path path);\n}\n```\n\n### 路径匹配\nPathMatcher可以用过`FileSystem`的[getPathMatcher(String)](https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#getPathMatcher-java.lang.String-)方法实例化。\n\n创建PathMatcher时的语法为：`syntax:pattern`。FileSystem支持[glob](http://docs.oracle.com/javase/tutorial/essential/io/fileOps.html#glob)、[regex](http://docs.oracle.com/javase/tutorial/essential/regex/index.html)两种语法。\n\n#### glob\n* `*`表示匹配0个或多个字符（但没有跨越目录）\n* `**`表示匹配0个或多个字符（跨目录）\n* `?`表示匹配0个或1个字符\n* `\\`为转义字符，用来匹配`*`、`?`等\n* `[ ]`表示匹配一组字符中的1个字符，比如“[abc]”可以匹配“a”、“b”或者“c”。\n  常常结合`-`一起使用，表示范围。如“[a-z]”可以匹配从“a”到“z”的所有单个字符。\n  有时也会搭配`!`来使用表示取反，如[!a-c]表示可以匹配任何字符但除了“a”、“b”、“c”。\n\n  *注意：* 方括号中的`*`，`?`，`\\`不在具有上述统配意义，将匹配它们本身表示的字符。而`-`符号为第一字符，也就是不再表示范围时，也表示它本身代表的字符。\n* `{ }`表示匹配一组字符串中的任意一个，但不能嵌套使用。`,`为分隔符。\n* `.`开头的字符串视为常规的字符，不要理解为正则中的任意字符。\n\n比如我们要匹配所有java文件，可以这么来创建：\n``` java\nPathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:a.java\");\n\n// 一定要使用 getFileName\nif (matcher.matches(file.getFileName())) {\n    // TODO something\n}\n```\n需要注意的是，一定要使用`getFileName`，因为file一般表示从root到文件中的所有元素。\n\n#### regex\n参见[oracle上的教程](http://docs.oracle.com/javase/tutorial/essential/regex/index.html)。\n\n## 与`java.io.File`的比较\nJDK7发布前File是主要的I/O类，但它具有很多缺点：\n\n* 很多方法失败时不会抛出明确异常。比如文件删除失败时，你无法得知是文件不存在还是没有权限。\n* 不能友好的支持文件连接。\n* 不能全面的支持文件元数据，如Ownner，permission等。\n* 不能友好的支持递归遍历目录。\n\n### Path与File的转化\n``` java\nPath input = file.toPath();\nFiles.delete(fp);\n```\n\n其他场景的转化参见：[官方文档](http://docs.oracle.com/javase/tutorial/essential/io/legacy.html#mapping)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 参考资料\n* [http://tutorials.jenkov.com/java-nio/index.html](http://tutorials.jenkov.com/java-nio/index.html)\n\n\n\n\n","slug":"nio-in-java","published":1,"updated":"2016-03-14T15:21:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciziguc4q000nnps6iiqgsa41"},{"title":"我的二〇一五","date":"2016-01-11T15:47:00.000Z","toc":true,"_content":"\n2015就这样过去了，而且是已经过去了11天。一直想着要认真制定下新年计划，然后记录下来，因为方向是什么比当下在做什么更重要。前几天却因为博客迟迟没有迁移过来而纠结年度计划记录在哪里... 现在博客基本达到了自己想要的样子，也该把年度计划给落地了。\n\n有人说，没有回顾的计划都是自欺欺人。貌似很有稻梨，于是就静静地坐下来回顾这匆匆过去的又一年。\n\n<!-- more -->\n\n## 引子\n\n其实我2015年是没有做年度计划的。\n\n只记得那个2014年的最后一个晚上，心潮澎湃地说要跨年，新年第一天一定不能贪睡。于是第二天就起了个早直奔[宝石山](https://zh.wikipedia.org/zh-cn/%E5%AE%9D%E7%9F%B3%E5%B1%B1)看日出，无奈在高架上错过西湖大道的出口不得不到下个出口掉头重新上高架... 更无奈的是再次错过保俶路的停车场... 于是整个行程就耽误了半个多小时，上山的时候看见别人已经开始下山了。但却丝毫没有影响我的心情，因为我还是来了。站在[保俶塔](https://zh.wikipedia.org/zh-cn/%E4%BF%9D%E4%BF%B6%E5%A1%94)旁边的小山上，望着苏堤倾斜的穿过整个西湖，心中在想：我的2015应该如何度过。\n\n然后最后还是没有产出一些像样的新年计划，只是在脑海中时不时浮现出那些清晰又模糊的计划或者目标。\n\n## 回顾\n\n现在还能回忆起或者顺利地回忆起过去的一年，功劳归功于[随手记](http://www.feidee.com/money/)。因为某些原因，去年的记账还是坚持了下来（除去1、2月份，春节过后开始的）。以每个月的开销为主线，不免想起很多无从想起的事情。\n\n* *个人感情*\n  将近一年的感情告一段落。离开是为了成全让对方遇到更好的彼此。坚信每一个人都有自己的优点和缺点，也肯定会有另外一个人来欣赏你、包容你然后陪你走到最后。所以没有走到最后只是因为彼此还不是那个对的人。不后悔遇见，只愿你找到那个合适的他。\n\n* *身体健康*\n  拖了很久，终于还是把种牙提上了日程并且经过3个月的折腾可以正常吃饭了（虽然早已不习惯，早年不用右边吃饭了...），这算今年蛮大的收获之一吧，因为有这个想法已经将近一年了。\n  健身卡一张，健身次数 *<8* 次，游泳次数 *<10* 次：后面因为某些原因（狗狗、感情等因素），被搁浅了...\n\n* *财务收支*\n  春节过后坚持记账，对自己的支出有了明确的认识。而收入明年需要跟上。\n  不完全统计全年支出[25W+]()，其中生活开销[11W+]()（以上数据均不包含1、2月份...）\n  在收支平衡上比上一年有进步。*这点应该是2015的最大收获吧。*\n\n* *远足旅行*\n  4月份港澳游，10月份台湾行：也算把我天朝的三个未接壤的地方给去了。收获良多，感受他乡风情的同时，更加内心的目标更加清晰，坚定。\n  大于12次杭州周边游：最喜欢的是[德清·莫干山](https://zh.wikipedia.org/zh-cn/%E8%8E%AB%E5%B9%B2%E5%B1%B1)，最失望的是[半山·仙人谷]()\n\n* *阅读清单*\n  买了很多书、读了很多书但全部读完且印象深刻的有[《慢慢來 人生就會不一樣》](http://www.books.com.tw/products/0010675560)、[《跳槽法則》](http://www.books.com.tw/products/0010687284)（两本书都是从台湾带回来的）。\n  两个书架已经快装不下，上周末去宜家买了个书架，书架促销性价比极高（开森ing...）。\n\n* *休闲娱乐*\n  电影院：12+\n  聚餐/下馆子：48+\n\n* *个人成长*\n  相对前两年成长较明显的一年，但还不够，因为原本也没有年度计划，此处不展开详说。\n  这应该算是2015第二大欣慰的地方吧：渐渐明白自己努力的方向，深感时间不够用，越深入越发现自己需要掌握的东西越多。\n\n* *数码装备*\n  [Air](http://www.apple.com/cn/macbook-air/)升级到[Pro](http://www.apple.com/cn/macbook-pro/)。陪伴了自己4年多的小A退出了舞台，希望小P在其之上更助自己一臂之力。\n  入手[HiFi](https://en.wikipedia.org/wiki/High_fidelity)，使用次数 *<10+* 次。\n  入手[RT-AC68U](https://www.asus.com/us/Networking/RTAC68U/)，实现家中路由[科学上网](https://zh.wikipedia.org/zh-cn/%E7%AA%81%E7%A0%B4%E7%BD%91%E7%BB%9C%E5%AE%A1%E6%9F%A5)，全家终端自由访问[Facebook](https://www.facebook.com/)。\n\n* *陪伴家人*\n  春节在家中待了 *3* 天，每月平均通话：*30* 分钟\n  平均带闹闹外出远足次数：*1* 次/月\n  *这是2015做得最差的地方*\n\n* *英语学习*\n  学习次数 *<10*，呵呵了...\n\n## 总结\n\n如果2015年可以重来，你选择怎么度过（扯蛋，所以叫如果）。\n\n捡重点，具体落实到2016年计划中：\n\n1. 个人成长：制定详细的学习计划（月计划），加强深度，分模块各个击破。\n2. 阅读清单：同上\n3. 身体健康：身体是自己的，看着办\n4. 英语学习：这个没得商量\n5. 财务收支：节流，暂不开源\n6. 陪伴家人：重点\n7. 其他：视情况待定","source":"_posts/my-2015.md","raw":"---\ntitle: 我的二〇一五\ndate: 2016-01-11 23:47:00\ntags: \n- 个人计划\ncategories: 目标管理\ntoc: true\n---\n\n2015就这样过去了，而且是已经过去了11天。一直想着要认真制定下新年计划，然后记录下来，因为方向是什么比当下在做什么更重要。前几天却因为博客迟迟没有迁移过来而纠结年度计划记录在哪里... 现在博客基本达到了自己想要的样子，也该把年度计划给落地了。\n\n有人说，没有回顾的计划都是自欺欺人。貌似很有稻梨，于是就静静地坐下来回顾这匆匆过去的又一年。\n\n<!-- more -->\n\n## 引子\n\n其实我2015年是没有做年度计划的。\n\n只记得那个2014年的最后一个晚上，心潮澎湃地说要跨年，新年第一天一定不能贪睡。于是第二天就起了个早直奔[宝石山](https://zh.wikipedia.org/zh-cn/%E5%AE%9D%E7%9F%B3%E5%B1%B1)看日出，无奈在高架上错过西湖大道的出口不得不到下个出口掉头重新上高架... 更无奈的是再次错过保俶路的停车场... 于是整个行程就耽误了半个多小时，上山的时候看见别人已经开始下山了。但却丝毫没有影响我的心情，因为我还是来了。站在[保俶塔](https://zh.wikipedia.org/zh-cn/%E4%BF%9D%E4%BF%B6%E5%A1%94)旁边的小山上，望着苏堤倾斜的穿过整个西湖，心中在想：我的2015应该如何度过。\n\n然后最后还是没有产出一些像样的新年计划，只是在脑海中时不时浮现出那些清晰又模糊的计划或者目标。\n\n## 回顾\n\n现在还能回忆起或者顺利地回忆起过去的一年，功劳归功于[随手记](http://www.feidee.com/money/)。因为某些原因，去年的记账还是坚持了下来（除去1、2月份，春节过后开始的）。以每个月的开销为主线，不免想起很多无从想起的事情。\n\n* *个人感情*\n  将近一年的感情告一段落。离开是为了成全让对方遇到更好的彼此。坚信每一个人都有自己的优点和缺点，也肯定会有另外一个人来欣赏你、包容你然后陪你走到最后。所以没有走到最后只是因为彼此还不是那个对的人。不后悔遇见，只愿你找到那个合适的他。\n\n* *身体健康*\n  拖了很久，终于还是把种牙提上了日程并且经过3个月的折腾可以正常吃饭了（虽然早已不习惯，早年不用右边吃饭了...），这算今年蛮大的收获之一吧，因为有这个想法已经将近一年了。\n  健身卡一张，健身次数 *<8* 次，游泳次数 *<10* 次：后面因为某些原因（狗狗、感情等因素），被搁浅了...\n\n* *财务收支*\n  春节过后坚持记账，对自己的支出有了明确的认识。而收入明年需要跟上。\n  不完全统计全年支出[25W+]()，其中生活开销[11W+]()（以上数据均不包含1、2月份...）\n  在收支平衡上比上一年有进步。*这点应该是2015的最大收获吧。*\n\n* *远足旅行*\n  4月份港澳游，10月份台湾行：也算把我天朝的三个未接壤的地方给去了。收获良多，感受他乡风情的同时，更加内心的目标更加清晰，坚定。\n  大于12次杭州周边游：最喜欢的是[德清·莫干山](https://zh.wikipedia.org/zh-cn/%E8%8E%AB%E5%B9%B2%E5%B1%B1)，最失望的是[半山·仙人谷]()\n\n* *阅读清单*\n  买了很多书、读了很多书但全部读完且印象深刻的有[《慢慢來 人生就會不一樣》](http://www.books.com.tw/products/0010675560)、[《跳槽法則》](http://www.books.com.tw/products/0010687284)（两本书都是从台湾带回来的）。\n  两个书架已经快装不下，上周末去宜家买了个书架，书架促销性价比极高（开森ing...）。\n\n* *休闲娱乐*\n  电影院：12+\n  聚餐/下馆子：48+\n\n* *个人成长*\n  相对前两年成长较明显的一年，但还不够，因为原本也没有年度计划，此处不展开详说。\n  这应该算是2015第二大欣慰的地方吧：渐渐明白自己努力的方向，深感时间不够用，越深入越发现自己需要掌握的东西越多。\n\n* *数码装备*\n  [Air](http://www.apple.com/cn/macbook-air/)升级到[Pro](http://www.apple.com/cn/macbook-pro/)。陪伴了自己4年多的小A退出了舞台，希望小P在其之上更助自己一臂之力。\n  入手[HiFi](https://en.wikipedia.org/wiki/High_fidelity)，使用次数 *<10+* 次。\n  入手[RT-AC68U](https://www.asus.com/us/Networking/RTAC68U/)，实现家中路由[科学上网](https://zh.wikipedia.org/zh-cn/%E7%AA%81%E7%A0%B4%E7%BD%91%E7%BB%9C%E5%AE%A1%E6%9F%A5)，全家终端自由访问[Facebook](https://www.facebook.com/)。\n\n* *陪伴家人*\n  春节在家中待了 *3* 天，每月平均通话：*30* 分钟\n  平均带闹闹外出远足次数：*1* 次/月\n  *这是2015做得最差的地方*\n\n* *英语学习*\n  学习次数 *<10*，呵呵了...\n\n## 总结\n\n如果2015年可以重来，你选择怎么度过（扯蛋，所以叫如果）。\n\n捡重点，具体落实到2016年计划中：\n\n1. 个人成长：制定详细的学习计划（月计划），加强深度，分模块各个击破。\n2. 阅读清单：同上\n3. 身体健康：身体是自己的，看着办\n4. 英语学习：这个没得商量\n5. 财务收支：节流，暂不开源\n6. 陪伴家人：重点\n7. 其他：视情况待定","slug":"my-2015","published":1,"updated":"2016-01-12T16:15:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciziguc4t000rnps6yk3uuozi"},{"title":"Java中的多线程（三）：活跃度","date":"2016-03-15T17:58:19.000Z","toc":true,"_content":"\n一个并发程序的及时执行能力叫做活跃度（liveness）。活跃度问题一般包括死锁（deadlock）、饥饿（starvation）和活锁（liveness）。\n\n<!-- more -->\n\n## 死锁（deadlock)\n死锁，指两个或更多的线程被永久阻塞，等待彼此进行解锁。\n\n## 饥饿（starvation）\n饥饿，指某个线程长时间内无法获得资源而处于阻塞状态，这种现象常常是由于其他“贪婪”线程长时间占用资源导致。\n\n## 活锁（livelock）\n活锁，指一个线程的操作或响应其他线程，而其他线程又会响应另外线程，这时候可能导致活锁。活锁同样会导致程序无法进行，但跟死锁不同的是，它并没有阻塞\n\n## 守护区块（guarded）\n线程间经常需要协调他们的活动。最常用的协调习惯就是守护区块：该区块轮询一个条件，直到满足后才会执行。\n\n最常见的错误用法为：\n``` java\nclass Guarded {\n\n    private boolean flag = false;\n    \n    public void run() {\n        // 等待\n        while(!flag){\n            System.out.println(\"waiting...\");\n        }\n        \n        System.out.println(\"Run done!\");\n    }\n    \n    public void activate() {\n        flag = true;\n    }\n}\n\npublic void testGuarded() {\n    Guarded guarded = new Guarded();\n    \n    new Thread(() -> guarded.run()).start();\n    new Thread(() -> guarded.activate()).start();\n}\n```\n上面的程序也会正常运行，但是开销是巨大的，应该那个轮询会一直进行打印“waiting...”。正确的做法是通过“等待-通知”模式：\n``` java\nclass Guarded {\n\n    private boolean flag = false;\n    \n    public synchronized void run() throws InterruptedException {\n        while(!flag){\n            System.out.println(\"waiting...\");\n\n            // 等待\n            wait();\n        }\n        \n        System.out.println(\"Run done!\");\n    }\n    \n    public synchronized void activate() throws InterruptedException {\n        flag = true;\n        \n        // 通知\n        notify();\n        System.out.println(\"notify...\");\n    }\n}\n```\n`wait()`常常与*synchronized方法*一起使用，用来获取内部锁。当*wait*方法被调用时，这个线程会挂起并*释放内部锁*。当然其他线程同样可以调用此同步方法，获得内部锁并再次执行*wait*然后将自己挂起。当将来有个线程执行`nitifyAll()`时将会通知之前*所有*被挂起的线程。\n\n*注意*：nitifyAll并不会*同时*唤醒所有等待中的线程，因为毕竟内部锁（监视锁）只有一把，有且只有一个线程获得，然后执行剩下的操作，待退出同步方法时释放内部锁。所以应该说是其他线程依次被唤醒，但没有固定的顺序，依赖CPU的算法。（当然，也可以通过公平锁来根据线程的等待时间来依次给予内部锁，后面会讲到）\n\n## 生产者与消费者问题\n``` java\nclass Drop {\n    private static final String DONE = \"Done\";\n    \n    private String message;\n    // 注意这里的初始化\n    private boolean empty = true;\n    \n    public synchronized String take() {\n        while (empty) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n            }\n        }\n        \n        empty = true;\n        notifyAll();\n        return message;\n    }\n    \n    public synchronized void put(String message) {\n        while (!empty) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        this.message = message;\n        empty = false;\n        notify();\n    }\n}\n\nclass Producer implements Runnable {\n    String dataForProduct = \"simply retrieves the messages and prints them out\";\n    Random random = new Random();\n    \n    Drop drop;\n    Producer(Drop drop) {\n        this.drop = drop;\n    }\n    \n    @Override\n    public void run() {\n        for (String message : dataForProduct.split(\" \")) {\n            drop.put(message);\n            System.out.println(\"Product data: \" + message);\n            \n            try {\n                Thread.sleep(random.nextInt(500));\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        \n        drop.put(Drop.DONE);\n    }\n}\n\nclass Consumer implements Runnable {\n    Drop drop;\n    Consumer(Drop drop) {\n        this.drop = drop;\n    }\n    \n    @Override\n    public void run() {\n        for (String message = drop.take(); !message.equals(Drop.DONE); message = drop.take()) {\n            System.out.println(\"Received data : \" + message);\n        }\n    }\n}\n\n@Test\npublic void test() throws InterruptedException {\n    Drop drop = new Drop();\n    \n    new Thread(new Producer(drop)).start();\n    new Thread(new Consumer(drop)).start();\n    \n    Thread.sleep(3000);\n}\n```\n\n\n\n","source":"_posts/liveness-in-java-concurrency.md","raw":"---\ntitle: Java中的多线程（三）：活跃度\ndate: 2016-03-16 01:58:19\ntags: \n- Concurrency\n- Thread\n- Liveness\ncategories: Java-Core\ntoc: true\n---\n\n一个并发程序的及时执行能力叫做活跃度（liveness）。活跃度问题一般包括死锁（deadlock）、饥饿（starvation）和活锁（liveness）。\n\n<!-- more -->\n\n## 死锁（deadlock)\n死锁，指两个或更多的线程被永久阻塞，等待彼此进行解锁。\n\n## 饥饿（starvation）\n饥饿，指某个线程长时间内无法获得资源而处于阻塞状态，这种现象常常是由于其他“贪婪”线程长时间占用资源导致。\n\n## 活锁（livelock）\n活锁，指一个线程的操作或响应其他线程，而其他线程又会响应另外线程，这时候可能导致活锁。活锁同样会导致程序无法进行，但跟死锁不同的是，它并没有阻塞\n\n## 守护区块（guarded）\n线程间经常需要协调他们的活动。最常用的协调习惯就是守护区块：该区块轮询一个条件，直到满足后才会执行。\n\n最常见的错误用法为：\n``` java\nclass Guarded {\n\n    private boolean flag = false;\n    \n    public void run() {\n        // 等待\n        while(!flag){\n            System.out.println(\"waiting...\");\n        }\n        \n        System.out.println(\"Run done!\");\n    }\n    \n    public void activate() {\n        flag = true;\n    }\n}\n\npublic void testGuarded() {\n    Guarded guarded = new Guarded();\n    \n    new Thread(() -> guarded.run()).start();\n    new Thread(() -> guarded.activate()).start();\n}\n```\n上面的程序也会正常运行，但是开销是巨大的，应该那个轮询会一直进行打印“waiting...”。正确的做法是通过“等待-通知”模式：\n``` java\nclass Guarded {\n\n    private boolean flag = false;\n    \n    public synchronized void run() throws InterruptedException {\n        while(!flag){\n            System.out.println(\"waiting...\");\n\n            // 等待\n            wait();\n        }\n        \n        System.out.println(\"Run done!\");\n    }\n    \n    public synchronized void activate() throws InterruptedException {\n        flag = true;\n        \n        // 通知\n        notify();\n        System.out.println(\"notify...\");\n    }\n}\n```\n`wait()`常常与*synchronized方法*一起使用，用来获取内部锁。当*wait*方法被调用时，这个线程会挂起并*释放内部锁*。当然其他线程同样可以调用此同步方法，获得内部锁并再次执行*wait*然后将自己挂起。当将来有个线程执行`nitifyAll()`时将会通知之前*所有*被挂起的线程。\n\n*注意*：nitifyAll并不会*同时*唤醒所有等待中的线程，因为毕竟内部锁（监视锁）只有一把，有且只有一个线程获得，然后执行剩下的操作，待退出同步方法时释放内部锁。所以应该说是其他线程依次被唤醒，但没有固定的顺序，依赖CPU的算法。（当然，也可以通过公平锁来根据线程的等待时间来依次给予内部锁，后面会讲到）\n\n## 生产者与消费者问题\n``` java\nclass Drop {\n    private static final String DONE = \"Done\";\n    \n    private String message;\n    // 注意这里的初始化\n    private boolean empty = true;\n    \n    public synchronized String take() {\n        while (empty) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n            }\n        }\n        \n        empty = true;\n        notifyAll();\n        return message;\n    }\n    \n    public synchronized void put(String message) {\n        while (!empty) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        this.message = message;\n        empty = false;\n        notify();\n    }\n}\n\nclass Producer implements Runnable {\n    String dataForProduct = \"simply retrieves the messages and prints them out\";\n    Random random = new Random();\n    \n    Drop drop;\n    Producer(Drop drop) {\n        this.drop = drop;\n    }\n    \n    @Override\n    public void run() {\n        for (String message : dataForProduct.split(\" \")) {\n            drop.put(message);\n            System.out.println(\"Product data: \" + message);\n            \n            try {\n                Thread.sleep(random.nextInt(500));\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        \n        drop.put(Drop.DONE);\n    }\n}\n\nclass Consumer implements Runnable {\n    Drop drop;\n    Consumer(Drop drop) {\n        this.drop = drop;\n    }\n    \n    @Override\n    public void run() {\n        for (String message = drop.take(); !message.equals(Drop.DONE); message = drop.take()) {\n            System.out.println(\"Received data : \" + message);\n        }\n    }\n}\n\n@Test\npublic void test() throws InterruptedException {\n    Drop drop = new Drop();\n    \n    new Thread(new Producer(drop)).start();\n    new Thread(new Consumer(drop)).start();\n    \n    Thread.sleep(3000);\n}\n```\n\n\n\n","slug":"liveness-in-java-concurrency","published":1,"updated":"2016-04-30T06:45:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciziguc4w000wnps6doakz953"},{"title":"Java8中的Lambda表达式","date":"2016-02-04T16:43:08.000Z","toc":true,"_content":"\nLambda表达式是Java8引进的新特性，用一句话概括为：*更紧凑的表达仅有一个方法的接口实例*。\n\n<!-- more -->\n\n## Lambda表达式如何而来\n\n我们在日常编程中经常会遇到只有一个方法的接口，如`Runnable`，只有一个`void run()`方法。在Java8之前是不支持接口中的方法带有默认实现的，所以在Java8中，Lambda表达式更准确得讲为：*更紧凑的表达仅有一个抽象方法的接口实例*，因为Jaba8中可以有[默认实现的方法](http://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html)和[静态方法](http://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html#static)。\n\n特别地，在使用策略模式时，经常会使用匿名类来实现某个接口：\n\n``` java\npublic interface Operation {\n    int calculate(int a, int b);\n}\n\npublic static int calculate(int a, int b, Operation operator) {\n    return operator.calculate(a, b);\n}\n\npublic static void main(String[] args) {\n    System.out.println(\"1 + 2 = \" + calculate(1, 2, new Operation(){\n\n        @Override\n        public int calculate(int a, int b) {\n            return a + b;\n        }\n    }));\n}\n```\n\n而在引入Lambda表达式之后，上面的例子就可改写为：\n\n``` java\npublic static void main(String[] args) {\n    System.out.println(\"1 + 2 = \" + calculate(1, 2, (a, b) -> a + b));\n}\n```\n\n较之前的匿名类而言，更加简洁、直观、紧凑。\n\n## Lambda表达式的语法\n\n一个Lambda表达式由以下几部分组成：\n\n* 一个在闭合圆括号中用逗号分隔的参数列表。\n  如：`calculate(1, 3, (int a, int b) -> a + b)`。\n  *Note*：在Lambda表达式中，*可以省略数据类型*。此外，*如果仅有一个参数时，也可以将圆括号省略*：`a -> a.foo()`。\n\n* `->`\n\n* 表达体：一个单独的表达式 或者 区块。\n  如：`a > 0 && b >0` 或者 `{ return a > 0 && b > 0; }`。当然，如果返回值为`void`时，完全没必要写成后者形式。\n\n## JDK对Lambda表达式的支持\n\nJava8中引入注释[FunctionalInterface](http://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html)，用于标识功能性接口[](http://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html#package.description)。\n\n在`java.util.function`包中提供了大量的通用功能性接口：`Function`、`Consumer`、`Predicate`：\n\n* `Function`：`R apply(T t)`\n* `Consumer`：`void accept(T t)`\n* `Predicate`：`boolean test(T t)`\n* `Supplier`：`T get()`\n\n还包括一些指定数据类型的`ToIntFunction`、`LongConsumer`等。\n\n使用JDK中提供的标准接口可以将上例改写为：\n\n``` java\npublic static int calculate(int a, int b, ToIntBiFunction<Integer, Integer> operator) {\n    return operator.applyAsInt(a, b);\n}\n\npublic static void main(String[] args) {\n    System.out.println(\"1 + 2 = \" + calculate(1, 2, (a, b) -> a + b));\n}\n```\n\n## Lambda表达式的目标类型\n\nJava编译器会通过调用时的上下文或者Lambda表达式的位置来决定其表达式的类型。\n\n例如，当你自己定义一个相同功能的功能性接口进行使用时：\n\n``` java\npublic static int calculate(int a, int b, Operation operator) {\n    return operator.calculate(a, b);\n}\n```\n\n`(a, b) -> a + b)`的类型为`Operation`，当你使用JDK提供的标准接口时类型为：`ToIntBiFunction`。\n\n### 目标类型和方法参数\n\n比如下面两个可调用的方法：\n\n``` java\nvoid invoke(Runnable r) {\n    r.run();\n}\n\n<T> T invoke(Callable<T> c) {\n    return c.call();\n}\n```\n\n当执行 `String s = invoke(() -> \"done\");` 时，调用的方法为 `invoke(Callable<T> c)`，因为这个方法返回了值。所有Lambda表达式的类型为`Callable<T>`。\n\n## 本地变量的访问\n\nLambda表达式中并不会产生一个新的局部变量，所以你不能再表达式的参数列表中包含上一次的局部变量，但是你可以在表达体中直接使用这些的变量。\n\n当然，同内部类、匿名类一样，这些被Lambda表达式使用的变量必须是`final`类型，否则编译器会提示你：\n\n> local variables referenced from a lambda expression must be final or effectively final。\n\n``` java\npublic static void main(String[] args) {\n    // Lambda expression's parameter a cannot redeclare another local variable  \n    // defined in an enclosing scope.\n    // int a = 0;\n    \n    final int c = 3;\n    System.out.println(\"1 + 2 = \" + calculate(1, 2, (a, b) -> a + b + c));\n}\n```\n\n## 方法引用\n\n还是上面的例子：计算两个数字之和。`java.lang.Math`中提供了相关api：\n\n```\npublic final class Math {\n\n    public static int addExact(int x, int y) {\n        int r = x + y;\n\n        if (((x ^ r) & (y ^ r)) < 0) {\n            throw new ArithmeticException(\"integer overflow\");\n        }\n        return r;\n    }\n}\n```\n\n所以上述例子可以改写为：\n\n``` java\nSystem.out.println(\"1 + 2 = \" + calculate(1, 3, \n        new ToIntBiFunction<Integer, Integer>() {\n    \n            @Override\n            public int applyAsInt(Integer t, Integer u) {\n                return Math.addExact(t, u);\n            }\n        }));\n```\n\n此处的功能接口中实际上调用的是`addExact`方法，Java8中支持方法的引用，可以写得更简洁 ：\n\n``` java\nSystem.out.println(\"1 + 2 = \" + calculate(1, 3, Math::addExact));\n```\n\n\n\n\n\n\n\n\n","source":"_posts/lambda-in-java8.md","raw":"---\ntitle: Java8中的Lambda表达式\ndate: 2016-02-05 00:43:08\ntags: \n- Lambda\n- Java8\ncategories: Java-Core\ntoc: true\n---\n\nLambda表达式是Java8引进的新特性，用一句话概括为：*更紧凑的表达仅有一个方法的接口实例*。\n\n<!-- more -->\n\n## Lambda表达式如何而来\n\n我们在日常编程中经常会遇到只有一个方法的接口，如`Runnable`，只有一个`void run()`方法。在Java8之前是不支持接口中的方法带有默认实现的，所以在Java8中，Lambda表达式更准确得讲为：*更紧凑的表达仅有一个抽象方法的接口实例*，因为Jaba8中可以有[默认实现的方法](http://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html)和[静态方法](http://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html#static)。\n\n特别地，在使用策略模式时，经常会使用匿名类来实现某个接口：\n\n``` java\npublic interface Operation {\n    int calculate(int a, int b);\n}\n\npublic static int calculate(int a, int b, Operation operator) {\n    return operator.calculate(a, b);\n}\n\npublic static void main(String[] args) {\n    System.out.println(\"1 + 2 = \" + calculate(1, 2, new Operation(){\n\n        @Override\n        public int calculate(int a, int b) {\n            return a + b;\n        }\n    }));\n}\n```\n\n而在引入Lambda表达式之后，上面的例子就可改写为：\n\n``` java\npublic static void main(String[] args) {\n    System.out.println(\"1 + 2 = \" + calculate(1, 2, (a, b) -> a + b));\n}\n```\n\n较之前的匿名类而言，更加简洁、直观、紧凑。\n\n## Lambda表达式的语法\n\n一个Lambda表达式由以下几部分组成：\n\n* 一个在闭合圆括号中用逗号分隔的参数列表。\n  如：`calculate(1, 3, (int a, int b) -> a + b)`。\n  *Note*：在Lambda表达式中，*可以省略数据类型*。此外，*如果仅有一个参数时，也可以将圆括号省略*：`a -> a.foo()`。\n\n* `->`\n\n* 表达体：一个单独的表达式 或者 区块。\n  如：`a > 0 && b >0` 或者 `{ return a > 0 && b > 0; }`。当然，如果返回值为`void`时，完全没必要写成后者形式。\n\n## JDK对Lambda表达式的支持\n\nJava8中引入注释[FunctionalInterface](http://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html)，用于标识功能性接口[](http://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html#package.description)。\n\n在`java.util.function`包中提供了大量的通用功能性接口：`Function`、`Consumer`、`Predicate`：\n\n* `Function`：`R apply(T t)`\n* `Consumer`：`void accept(T t)`\n* `Predicate`：`boolean test(T t)`\n* `Supplier`：`T get()`\n\n还包括一些指定数据类型的`ToIntFunction`、`LongConsumer`等。\n\n使用JDK中提供的标准接口可以将上例改写为：\n\n``` java\npublic static int calculate(int a, int b, ToIntBiFunction<Integer, Integer> operator) {\n    return operator.applyAsInt(a, b);\n}\n\npublic static void main(String[] args) {\n    System.out.println(\"1 + 2 = \" + calculate(1, 2, (a, b) -> a + b));\n}\n```\n\n## Lambda表达式的目标类型\n\nJava编译器会通过调用时的上下文或者Lambda表达式的位置来决定其表达式的类型。\n\n例如，当你自己定义一个相同功能的功能性接口进行使用时：\n\n``` java\npublic static int calculate(int a, int b, Operation operator) {\n    return operator.calculate(a, b);\n}\n```\n\n`(a, b) -> a + b)`的类型为`Operation`，当你使用JDK提供的标准接口时类型为：`ToIntBiFunction`。\n\n### 目标类型和方法参数\n\n比如下面两个可调用的方法：\n\n``` java\nvoid invoke(Runnable r) {\n    r.run();\n}\n\n<T> T invoke(Callable<T> c) {\n    return c.call();\n}\n```\n\n当执行 `String s = invoke(() -> \"done\");` 时，调用的方法为 `invoke(Callable<T> c)`，因为这个方法返回了值。所有Lambda表达式的类型为`Callable<T>`。\n\n## 本地变量的访问\n\nLambda表达式中并不会产生一个新的局部变量，所以你不能再表达式的参数列表中包含上一次的局部变量，但是你可以在表达体中直接使用这些的变量。\n\n当然，同内部类、匿名类一样，这些被Lambda表达式使用的变量必须是`final`类型，否则编译器会提示你：\n\n> local variables referenced from a lambda expression must be final or effectively final。\n\n``` java\npublic static void main(String[] args) {\n    // Lambda expression's parameter a cannot redeclare another local variable  \n    // defined in an enclosing scope.\n    // int a = 0;\n    \n    final int c = 3;\n    System.out.println(\"1 + 2 = \" + calculate(1, 2, (a, b) -> a + b + c));\n}\n```\n\n## 方法引用\n\n还是上面的例子：计算两个数字之和。`java.lang.Math`中提供了相关api：\n\n```\npublic final class Math {\n\n    public static int addExact(int x, int y) {\n        int r = x + y;\n\n        if (((x ^ r) & (y ^ r)) < 0) {\n            throw new ArithmeticException(\"integer overflow\");\n        }\n        return r;\n    }\n}\n```\n\n所以上述例子可以改写为：\n\n``` java\nSystem.out.println(\"1 + 2 = \" + calculate(1, 3, \n        new ToIntBiFunction<Integer, Integer>() {\n    \n            @Override\n            public int applyAsInt(Integer t, Integer u) {\n                return Math.addExact(t, u);\n            }\n        }));\n```\n\n此处的功能接口中实际上调用的是`addExact`方法，Java8中支持方法的引用，可以写得更简洁 ：\n\n``` java\nSystem.out.println(\"1 + 2 = \" + calculate(1, 3, Math::addExact));\n```\n\n\n\n\n\n\n\n\n","slug":"lambda-in-java8","published":1,"updated":"2016-02-08T02:30:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciziguc500012nps6bfd1swnq"},{"title":"深入理解NIO中的Channel","date":"2016-03-13T02:16:44.000Z","toc":true,"_content":"\n{% blockquote %}\nA nexus for I/O operations.\n{% endblockquote %}\n\n\n管道（[Channel](https://docs.oracle.com/javase/8/docs/api/java/nio/channels/Channel.html)）是NIO中非常重要的概念，它直接面向缓存块，并且支持多并发环境，极大提升了I/O效率。本文将深入探讨Channel的使用及实现。\n\n<!-- more -->\n\n## Channel是如何出现的\nMark Reinhold在[JSR-51](https://www.jcp.org/en/jsr/detail?id=51#2)中提出：是时候在Java平台中提供一些*新的*、*性能提升*的I/O API了：\n\n* The scalable I/O API will make it easier to write production-quality web and application servers that scale well to thousands of open connections and can easily take advantage of multiple processors;\n* The fast buffered binary I/O API will make it easier to write high-performance, I/O-intensive programs that manipulate streams or files of binary data;\n* The fast buffered character I/O API will simplify the efficient handling of character streams and files; it will also bring regular expressions and a compact notation for formatted output to the Java platform, putting it on a par with other popular platforms such as Perl;\n* The character-set converter API will give developers direct access the platform's built-in character-set converters and will also provide for the easy \"plugging in\" of new converters;\n\nJSR-51是在JDK1.4中实现的，Channel就是其中一个非常重要的概念。\n\n## 什么是Channel\nChannel是用来连接硬件设备、文件、network socket或者具有读写操作的是实体。\nChannel的状态有两种，要么打开状态，要么已被关闭。当Channel被创建时被打开，一旦被关闭代表*永久*处于关闭状态。Channel状态可以通过`isOpen`方法来检测。\n\n## Channel的类图结构\n\n* ReadableByteChannel：可读Channel\n  ScatteringByteChannel：支持偏移读取（感觉设计过渡）\n* WritableByteChannel：可写Channel\n  GatheringByteChannel：支持偏移写入（感觉设计过渡）\n* InterruptibleChannel：可异步终端Channel\n* ByteChannel：可读写的字节Channel\n* SeekableByteChannel：继承于字节Channel，可获取/设置Channel当前的位置、当前连体实体的大小\n\n![Channel Class Diagram](../images/Channel-class.png)\n\n## nio中的缓存（Buffer）\n熟悉Channel的同学会发现它的读写操作都依赖`ByteBuffer`，可见Buffered在NIO中的重要性不言而喻。\n\n### 基本属性\n专为基本数据类型设计的缓存，主要有以下3个基本属性：\n\n* 容量（capacity）：缓存中元素的多少，非负且不可变。\n* 哨兵（limit）：首个不可读或者不可写的元素索引值，非负且不会大于缓存容量。\n* 指针（position）：下一个应该被读取或写入的索引值，非负且不会大于哨兵值。\n* 重置标记位（mark）：reset辅助属性，不一定被定义，被定义时非负却不会大于指针（大于指针时将被视为无效）。\n\n### 基本操作\n\n* `clear`：哨兵（limit）设置为容器大小，并将指针（position）设置为0。\n* `flip`：哨兵（limit）设置为当前位置position，并将指针（position）设置为0。\n* `rewind`：哨兵(limit)不变，将指针（position）设置为0。\n\n后面两个方法比较绕，可以从以下角度理解：\n\n#### 深入理解flip、rewind\n\n* 哨兵（limit）：用于控制读取/写入缓存数据而设计的终止符，\n* 指针（position）：用于控制读取/写入缓存而设计的起始符。\n* 写入缓存时：`position = position + n`：n代表缓存大小。\n* 读取缓存时：`position = limit`，读取的缓存块为：`[old_position, limit)`\n* 两者都可以通过方法自行设定，方便随机读取\n* `flip`：只不过是官方提供的快捷api，方便读取从缓存块起始位置到刚刚写入位置的所有内容，也就是写入后读取前。\n* `rewind`：方便读取缓存中所有数据（可能会有脏数据）\n* `clear`：写入数据是充分利用缓存块大小，limit不设置也可以，但效率可能会下降\n  比如上一次读取到容量一半时调用`flip`方法，此时limit=capacity，以后写入数据时只会写入一半容量的数据。\n\n#### byte与Buffer之间的转化\n``` java\nByteBuffer buffer = ByteBuffer.wrap(\"Hello World\".getBytes());\n```\n### 线程安全问题\nBuffer具有线程安全问题，在多线程下需要使用同步机制。\n\n## Channel的创建与使用\n通常通过Files的`newByteChanne`方法来实例化，不过返回类型为`SeekableByteChannel`。而在默认的文件系统中，它的实现为`FileSystemProvider.newByteChannel`，所以你可以将其转化为`FileChannel`来使用。\n\n另外还可以使用`FileChannel.open`来创建。\n\n","source":"_posts/in-depth-understanding-of-channel-in-nio.md","raw":"---\ntitle: 深入理解NIO中的Channel\ndate: 2016-03-13 10:16:44\ntags:\n- NIO\n- Channel\ncategories: Java-Core\ntoc: true\n---\n\n{% blockquote %}\nA nexus for I/O operations.\n{% endblockquote %}\n\n\n管道（[Channel](https://docs.oracle.com/javase/8/docs/api/java/nio/channels/Channel.html)）是NIO中非常重要的概念，它直接面向缓存块，并且支持多并发环境，极大提升了I/O效率。本文将深入探讨Channel的使用及实现。\n\n<!-- more -->\n\n## Channel是如何出现的\nMark Reinhold在[JSR-51](https://www.jcp.org/en/jsr/detail?id=51#2)中提出：是时候在Java平台中提供一些*新的*、*性能提升*的I/O API了：\n\n* The scalable I/O API will make it easier to write production-quality web and application servers that scale well to thousands of open connections and can easily take advantage of multiple processors;\n* The fast buffered binary I/O API will make it easier to write high-performance, I/O-intensive programs that manipulate streams or files of binary data;\n* The fast buffered character I/O API will simplify the efficient handling of character streams and files; it will also bring regular expressions and a compact notation for formatted output to the Java platform, putting it on a par with other popular platforms such as Perl;\n* The character-set converter API will give developers direct access the platform's built-in character-set converters and will also provide for the easy \"plugging in\" of new converters;\n\nJSR-51是在JDK1.4中实现的，Channel就是其中一个非常重要的概念。\n\n## 什么是Channel\nChannel是用来连接硬件设备、文件、network socket或者具有读写操作的是实体。\nChannel的状态有两种，要么打开状态，要么已被关闭。当Channel被创建时被打开，一旦被关闭代表*永久*处于关闭状态。Channel状态可以通过`isOpen`方法来检测。\n\n## Channel的类图结构\n\n* ReadableByteChannel：可读Channel\n  ScatteringByteChannel：支持偏移读取（感觉设计过渡）\n* WritableByteChannel：可写Channel\n  GatheringByteChannel：支持偏移写入（感觉设计过渡）\n* InterruptibleChannel：可异步终端Channel\n* ByteChannel：可读写的字节Channel\n* SeekableByteChannel：继承于字节Channel，可获取/设置Channel当前的位置、当前连体实体的大小\n\n![Channel Class Diagram](../images/Channel-class.png)\n\n## nio中的缓存（Buffer）\n熟悉Channel的同学会发现它的读写操作都依赖`ByteBuffer`，可见Buffered在NIO中的重要性不言而喻。\n\n### 基本属性\n专为基本数据类型设计的缓存，主要有以下3个基本属性：\n\n* 容量（capacity）：缓存中元素的多少，非负且不可变。\n* 哨兵（limit）：首个不可读或者不可写的元素索引值，非负且不会大于缓存容量。\n* 指针（position）：下一个应该被读取或写入的索引值，非负且不会大于哨兵值。\n* 重置标记位（mark）：reset辅助属性，不一定被定义，被定义时非负却不会大于指针（大于指针时将被视为无效）。\n\n### 基本操作\n\n* `clear`：哨兵（limit）设置为容器大小，并将指针（position）设置为0。\n* `flip`：哨兵（limit）设置为当前位置position，并将指针（position）设置为0。\n* `rewind`：哨兵(limit)不变，将指针（position）设置为0。\n\n后面两个方法比较绕，可以从以下角度理解：\n\n#### 深入理解flip、rewind\n\n* 哨兵（limit）：用于控制读取/写入缓存数据而设计的终止符，\n* 指针（position）：用于控制读取/写入缓存而设计的起始符。\n* 写入缓存时：`position = position + n`：n代表缓存大小。\n* 读取缓存时：`position = limit`，读取的缓存块为：`[old_position, limit)`\n* 两者都可以通过方法自行设定，方便随机读取\n* `flip`：只不过是官方提供的快捷api，方便读取从缓存块起始位置到刚刚写入位置的所有内容，也就是写入后读取前。\n* `rewind`：方便读取缓存中所有数据（可能会有脏数据）\n* `clear`：写入数据是充分利用缓存块大小，limit不设置也可以，但效率可能会下降\n  比如上一次读取到容量一半时调用`flip`方法，此时limit=capacity，以后写入数据时只会写入一半容量的数据。\n\n#### byte与Buffer之间的转化\n``` java\nByteBuffer buffer = ByteBuffer.wrap(\"Hello World\".getBytes());\n```\n### 线程安全问题\nBuffer具有线程安全问题，在多线程下需要使用同步机制。\n\n## Channel的创建与使用\n通常通过Files的`newByteChanne`方法来实例化，不过返回类型为`SeekableByteChannel`。而在默认的文件系统中，它的实现为`FileSystemProvider.newByteChannel`，所以你可以将其转化为`FileChannel`来使用。\n\n另外还可以使用`FileChannel.open`来创建。\n\n","slug":"in-depth-understanding-of-channel-in-nio","published":1,"updated":"2016-04-16T07:25:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciziguc550018nps65ozjuk2j"},{"title":"Hello World","date":"2016-01-10T03:44:08.000Z","toc":true,"_content":"\n国际惯例：`Hello World`\n\n折腾了许久，从 [wordpress](https://wordpress.com/) 到 [jekyll](http://jekyllrb.com/) ，以及国人开发的 [farbox](https://www.farbox.com/)... 待最近静下来梳理思路时问自己：*为何折腾，有没有必要，初衷又是什么。*\n\n屡清楚之后选择了 [hexo](https://hexo.io)。\n\n<!-- more -->\n\n##  初衷\n\n*\t记录生活、工作中的点点滴滴\n    其实起因是工作中的一个小需求：有个页面需要反向代理到别的团队，鉴于业务统计原因，页面中的链接必须是我们的域名，同时别人的页面还可正常访问。\n    于是就将这个`nginx`文本替换的工单提给了PE（由PE统一处理，我们没有权限... ），结果PE吭哧吭哧半天没搞定，对`substitutions_filter_module`不熟悉，最后被告知“*自己申请权限去改，改好了由他审批发布*”。\n\n    本来就对`niginx`感兴趣，一直没有时间折腾，索性就折腾一把。自己看文档，拉代码，编译，安装，测试。整个过程还是还是蛮有意思的，也遇到了各种问题。之后就在想，能否将这些分析问题、解决问题的思路和方法记录一下，备案的同时也给别人某种程度上的参考。\n\n*\t适合程序员方式的记录\n    之前在本地都在使用[Ulysess](http://www.ulyssesapp.com)，一款专注于写作的软件，支持`Markdown`、`Dropbox`同步、多种文档格式的输出等。\n\n*   可托管于Github\n    无须担心备份等问题。\n\n*   极简\n    记录，分享。包括呈现方式，抛弃华丽的外表，不忘初心，分享内容而非炫酷的各种Blog效果。\n\n## 框架选择\n\n最后选择[hexo](https://hexo.io)的原因也很简单，其官方定义\n\n>   A fast, simple & powerful blog framework\n\n*   速度\n    基于Node.js，支持多进程，几百篇文章几秒搞定\n\n*   简单\n    ``` bash\n    # 创建一条日志\n    hexo n \"Hell World\"\n\n    # 发布\n    hexo g\n\n    # 部署\n    hexo d\n    ```\n    几条简单的命令就可完成全部过程。\n\n*   易扩展\n    已经有很多成熟的插件，比如同时部署到Github和Gitcafe等\n\n## 模板选择\n\n[maupassant](https://github.com/pagecho/maupassant)，简约但不简单。 官方定义：\n\n> A simple template with great performance on different devices.\n\n已支持的平台：[Typecho](https://github.com/pagecho/maupassant/), [Octopress](https://github.com/pagecho/mewpassant/), [Farbox](https://github.com/pagecho/Maupassant-farbox), [Wordpress](https://github.com/iMuFeng/maupassant), [Ghost]( https://github.com/LjxPrime/maupassant), [Hexo](https://github.com/tufu9441/maupassant-hexo)。\n\n## 参考资料\n\n*   [hexo你的博客](http://ibruce.info/2013/11/22/hexo-your-blog/)\n*   [大道至简——Hexo简洁主题推荐](https://www.haomwei.com/technology/maupassant-hexo.html)\n*   [NexT - an elegant theme for hexo](http://theme-next.iissnan.com/)\n\n\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2016-01-10 11:44:08\ntags: \ncategories: 生活随笔\ntoc: true\n---\n\n国际惯例：`Hello World`\n\n折腾了许久，从 [wordpress](https://wordpress.com/) 到 [jekyll](http://jekyllrb.com/) ，以及国人开发的 [farbox](https://www.farbox.com/)... 待最近静下来梳理思路时问自己：*为何折腾，有没有必要，初衷又是什么。*\n\n屡清楚之后选择了 [hexo](https://hexo.io)。\n\n<!-- more -->\n\n##  初衷\n\n*\t记录生活、工作中的点点滴滴\n    其实起因是工作中的一个小需求：有个页面需要反向代理到别的团队，鉴于业务统计原因，页面中的链接必须是我们的域名，同时别人的页面还可正常访问。\n    于是就将这个`nginx`文本替换的工单提给了PE（由PE统一处理，我们没有权限... ），结果PE吭哧吭哧半天没搞定，对`substitutions_filter_module`不熟悉，最后被告知“*自己申请权限去改，改好了由他审批发布*”。\n\n    本来就对`niginx`感兴趣，一直没有时间折腾，索性就折腾一把。自己看文档，拉代码，编译，安装，测试。整个过程还是还是蛮有意思的，也遇到了各种问题。之后就在想，能否将这些分析问题、解决问题的思路和方法记录一下，备案的同时也给别人某种程度上的参考。\n\n*\t适合程序员方式的记录\n    之前在本地都在使用[Ulysess](http://www.ulyssesapp.com)，一款专注于写作的软件，支持`Markdown`、`Dropbox`同步、多种文档格式的输出等。\n\n*   可托管于Github\n    无须担心备份等问题。\n\n*   极简\n    记录，分享。包括呈现方式，抛弃华丽的外表，不忘初心，分享内容而非炫酷的各种Blog效果。\n\n## 框架选择\n\n最后选择[hexo](https://hexo.io)的原因也很简单，其官方定义\n\n>   A fast, simple & powerful blog framework\n\n*   速度\n    基于Node.js，支持多进程，几百篇文章几秒搞定\n\n*   简单\n    ``` bash\n    # 创建一条日志\n    hexo n \"Hell World\"\n\n    # 发布\n    hexo g\n\n    # 部署\n    hexo d\n    ```\n    几条简单的命令就可完成全部过程。\n\n*   易扩展\n    已经有很多成熟的插件，比如同时部署到Github和Gitcafe等\n\n## 模板选择\n\n[maupassant](https://github.com/pagecho/maupassant)，简约但不简单。 官方定义：\n\n> A simple template with great performance on different devices.\n\n已支持的平台：[Typecho](https://github.com/pagecho/maupassant/), [Octopress](https://github.com/pagecho/mewpassant/), [Farbox](https://github.com/pagecho/Maupassant-farbox), [Wordpress](https://github.com/iMuFeng/maupassant), [Ghost]( https://github.com/LjxPrime/maupassant), [Hexo](https://github.com/tufu9441/maupassant-hexo)。\n\n## 参考资料\n\n*   [hexo你的博客](http://ibruce.info/2013/11/22/hexo-your-blog/)\n*   [大道至简——Hexo简洁主题推荐](https://www.haomwei.com/technology/maupassant-hexo.html)\n*   [NexT - an elegant theme for hexo](http://theme-next.iissnan.com/)\n\n\n","slug":"hello-world","published":1,"updated":"2016-01-10T16:25:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciziguc5a001dnps61xaz1dgw"},{"title":"Java中的多线程（五）：ThreadPoolExecutor框架源码解析","date":"2016-04-07T09:07:43.000Z","toc":true,"_content":"\n启动线程任务最简单的方式是：为每个任务都创建一个线程（per-task）。在没有超出服务器处理能力时，这种方法既可以提升响应速度、又可以提升吞吐量。\n\n而在实际应用中，这种*thread-per-task*存在缺陷，特别是需要创建大量的线程时：\n\n* 线程创建的开销：线程的创建与关闭不是“免费”的\n* 资源消耗量：活动的线程会消耗系统资源\n\n所以，在一定范围内，增加线程可以提高系统的吞吐量。但一旦超过这个范围，再创建更多的线程只会增加系统开销，并有可能导致应用程序崩溃。所以应该限制你的应用程序可以创建的线程数量，确保线程数达到这个极限时，程序也不至于耗尽所有资源。于是线程池应运而生。\n\n<!-- more -->\n\n## ThreadPoolExecutor\nJava中内置的线程池，主要通过`Executors`的静态工厂方法创建不同类型的线程池，如：\n``` java\npublic class Executors {\n\n    public static ExecutorService newSingleThreadExecutor() {}\n\n    public static ExecutorService newFixedThreadPool(int nThreads) {}\n\n    public static ExecutorService newCachedThreadPool() {}\n}\n```\n\n## 相关类设计\n### Executor\n用于提交任务的接口：将任务的提交与任务执行细节隔离。\n``` java\npublic interface Executor {\n\n    void execute(Runnable command);\n}\n```\n\n### ExecutorService\n线程状态/生命周期的管理接口：提交任务、关闭线程池、查询线程池状态等。\n``` java\npublic interface ExecutorService extends Executor {\n    \n    void shutdown();\n\n    List<Runnable> shutdownNow();\n\n    boolean isShutdown();\n\n    boolean isTerminated();\n\n    <T> Future<T> submit(Callable<T> task);\n\n    <T> Future<T> submit(Runnable task, T result);\n}\n```\n\n## 基本结构\n* corePoolSize：最小的活跃线程数\n* maximumPoolSize：最大的处理作业线程数，受限于`CAPACITY`\n* workers：线程池中所有的工作线程\n* workQueue：阻塞（缓存）队列，向工作的线程传递任务\n* ctl：线程池状态(AtomicInteger)，按二进制的位数切分后包含两部分：`runState|workerCount`\n  * workerCount：活跃的线程数，范围(2^29)-1，占据ctl的前28位\n  * runState：线程池状态包括运行、正在关闭等，由剩下的4位组成\n    * RUNNING：接受新的任务，并且处理队列中的任务\n    * SHUTDOWN：不再接受新的任务，但是会处理完队列中任务\n    * STOP：不再接受新的任务，也不会处理队列中的任务，同时会中断正在执行的任务\n    * TIDYING：所有任务被终止，workerCount=0。会调用`terminated()`方法\n    * TERMINATED：`terminated()`方法执行完毕\n    以上这些状态是可比较的，依次递增\n\n## 线程池中主要原理/机制\n\n### 任务的执行机制\n线程的执行机制主要在`execute`方法中，任务的提交其实是封装线程后，再执行：\n``` java\npublic <T> Future<T> submit(Runnable task, T result) {\n    if (task == null) throw new NullPointerException();\n    // 构造Future\n    RunnableFuture<T> ftask = newTaskFor(task, result);\n\n    // 执行\n    execute(ftask);\n    return ftask;\n}\n```\n当一个线程被提交后，线程池的工作机制为：\n\n1. 如果当前工作的线程数小于设置的核心线程数，则新建一个线程执行此任务\n2. 如果工作的线程数已满足核心线程数，则将任务放入用于存放待执行任务的队列中（后续会被处理）\n3. 如果缓存队列已满，则新建一个线程执行此任务（此时工作线程数*大于*核心线程数）\n\n``` java\npublic void execute(Runnable command) {\n    if (command == null)\n        throw new NullPointerException();\n\n    int c = ctl.get();\n    if (workerCountOf(c) < corePoolSize) { // 如果工作线程小于核心线程池数量\n        if (addWorker(command, true)) // 创建一个新的核心线程来处理当前任务\n            return;\n        c = ctl.get();\n    }\n    if (isRunning(c) && workQueue.offer(command)) { // 如果线程池还在运行中，将任务添加到缓存队列\n        int recheck = ctl.get(); // 添加到缓存队列后，仍然需要二次检查\n        if (! isRunning(recheck) && remove(command)) // 如果线程池关闭，删除刚刚添加的任务\n            reject(command); // 如果成功删除，则执行任务拒绝流程\n        else if (workerCountOf(recheck) == 0) // 如果没有在工作的线程，需要启动一个线程来队列中任务\n            addWorker(null, false); // 创建一个线程来处理刚刚被加入到队列的任务\n    }\n    else if (!addWorker(command, false)) // 如果缓存队列已满，创建一个新的线程来处理当前任务\n        reject(command);\n}\n```\n#### 线程池状态二次校验\n将任务放入缓存队列后对线程池状态有一个二次校验：如果线程池已经关闭，那么将其从队列中剔除，并且直接执行拒绝流程。当然没有这块判断，这个任务最终也不会被执行，只是反馈被延迟了。\n\n### 线程的新增机制\n`addWorker`方法至关重要，因为增加工作线程总是伴随着任务的提交，新建的线程需要立刻用于执行被提交的任务：\n\n1. 首先检查线程池状态：排除明显不需要再创建线程的场景，如线程池已经关闭则不再接受新的任务，或者正在关闭时，队列中的任务已经为空\n2. 然后检查线程上限，然后增加线程池中工作线程的数量\n3. 最后获取线程池锁，新增工作线程，*并将其启动*\n\n``` java\n// 参数core在判断工作线程上限时使用:\n// true:表示上限为核心线程数, false:表示上限为最大线程数.\nprivate boolean addWorker(Runnable firstTask, boolean core) {\n    retry:\n    for (;;) {\n        int c = ctl.get();\n        int rs = runStateOf(c);\n\n        // Check if queue empty only if necessary.\n        // 线程池非运行状态下：\n        // 1. 非正在关闭状态：不再增加工作线程，因为已经在强制关闭或已经关闭\n        // 2. task!=null：不再接受新的任务，但可能会创建新的线程来处理队列中任务\n        // 3. 缓存队列为空：不需要线程线程，因为没有需要处理的任务了\n        if (rs >= SHUTDOWN &&\n            ! (rs == SHUTDOWN &&\n               firstTask == null &&\n               ! workQueue.isEmpty()))\n            return false;\n\n        // 更新工作线程数量：\n        // 1. 更新机制：CAS(CompareAndSet)，确保是当前线程执行了更新\n        // 2. 如果线程池运行状态发生变更，需要重新获取线程池状态：ctl\n        for (;;) {\n            int wc = workerCountOf(c);\n\n            // 工作线程数量的上限判断\n            if (wc >= CAPACITY ||\n                wc >= (core ? corePoolSize : maximumPoolSize))\n                return false;\n\n            // 如果工作线程数量“更加”成功（n=>n+1），则跳出retry，去创建线程\n            if (compareAndIncrementWorkerCount(c))\n                break retry;\n\n            c = ctl.get();  // Re-read ctl\n            if (runStateOf(c) != rs)\n                continue retry; 线程池运行状态发生变更，需要重新获取线程池状态：ctl\n            // else CAS failed due to workerCount change; retry inner loop\n        }\n    }\n\n    boolean workerStarted = false;\n    boolean workerAdded = false;\n    Worker w = null;\n    try {\n        w = new Worker(firstTask);\n        final Thread t = w.thread;\n        if (t != null) {\n            final ReentrantLock mainLock = this.mainLock;\n            mainLock.lock();\n            try {\n                // Recheck while holding lock.\n                // Back out on ThreadFactory failure or if\n                // shut down before lock acquired.\n                int rs = runStateOf(ctl.get());\n\n                // 需要创建新线程的场景：\n                // 1. 运行状态\n                // 2. 正在关闭并且该线程是用来处理缓存队列中任务(task=null) \n                if (rs < SHUTDOWN ||\n                    (rs == SHUTDOWN && firstTask == null)) {\n                    if (t.isAlive()) // precheck that t is startable\n                        throw new IllegalThreadStateException();\n                    workers.add(w);\n                    int s = workers.size();\n                    if (s > largestPoolSize)\n                        largestPoolSize = s;\n                    workerAdded = true;\n                }\n            } finally {\n                mainLock.unlock();\n            }\n            if (workerAdded) {\n                t.start();\n                workerStarted = true;\n            }\n        }\n    } finally {\n        if (! workerStarted)\n            addWorkerFailed(w);\n    }\n    return workerStarted;\n}\n```\n\n#### 状态变量的变化没有上锁\n1. 因为线程池的状态变量已为线程安全的，也就没有通过外部锁去控制它变化的原子性，这样将有很大的灵活性，多个线程在检查线程池状态时不存在竞争关系。但这也要求：在修改状态变量ctl时必须保证同时只有一个线程去修改它，因为它的检查与修改不具有原子性。这里用的是jvm底层`CAS-check and set`机制\n2. 工作线程也没有上锁，所以工作线程变更时需要获取外部锁\n\n### 工作线程worker的运行机制\n内部类`Worker`实现了`Runnable`，也是一个任务，run方法委托给了外部的`runWorker`。\n\n* 工作线程被启动后总是先运行第一个任务（也就是初始化工作线程时的任务）\n* 如果第一个任务任务为`null`，则*循环*从缓存缓存队列中获取任务，直到队列为空\n* 每次获取任务后，要检查线程池状态，必要时（线程池已关闭）及时中断该工作线程\n* 缓存队列为空后，执行线程组退出流程：统计已完成的任务数量等\n\n``` java\nprivate final class Worker extends AbstractQueuedSynchronizer implements Runnable {\n    public void run() {\n        runWorker(this);\n    }\n}\n\nfinal void runWorker(Worker w) {\n    Thread wt = Thread.currentThread();\n    Runnable task = w.firstTask;\n    w.firstTask = null;\n    w.unlock(); // allow interrupts\n    // 防止工作线程处理队列中任务时发生异常，预设标记值\n    boolean completedAbruptly = true;\n    try {\n        // 循环获取任务\n        while (task != null || (task = getTask()) != null) {\n            w.lock();\n            // If pool is stopping, ensure thread is interrupted;\n            // if not, ensure thread is not interrupted.  This\n            // requires a recheck in second case to deal with\n            // shutdownNow race while clearing interrupt\n            // 每次执行任务时，都需要检查线程池状态，及时中断当前线程\n            if ((runStateAtLeast(ctl.get(), STOP) ||\n                 (Thread.interrupted() &&\n                  runStateAtLeast(ctl.get(), STOP))) &&\n                !wt.isInterrupted())\n                wt.interrupt();\n            try {\n                beforeExecute(wt, task);\n                Throwable thrown = null;\n                try {\n                    task.run();\n                } catch (RuntimeException x) {\n                    thrown = x; throw x;\n                } catch (Error x) {\n                    thrown = x; throw x;\n                } catch (Throwable x) {\n                    thrown = x; throw new Error(x);\n                } finally {\n                    afterExecute(task, thrown);\n                }\n            } finally {\n                task = null;\n                w.completedTasks++;\n                w.unlock();\n            }\n        }\n        completedAbruptly = false; // 改工作线程工作正常，没有发生异常\n    } finally {\n        // 缓存队列中已经没有任务，则可以退出了：修改线程池相关状态\n        processWorkerExit(w, completedAbruptly);\n    }\n}\n```\n\n### 获取缓存队列中任务\n1. 检查线程池状态：如果线程池正在关闭却队列已经为空，或者线程池已关闭，修改工作线程数量，因为当前线程会自然运行结束\n2. 维护核心线程数量：超过核心线程后需要停掉该线程（此时已经完成工作线程的第一个任务）\n\n``` java\nprivate Runnable getTask() {\n    boolean timedOut = false; // Did the last poll() time out?\n\n    for (;;) {\n        int c = ctl.get();\n        int rs = runStateOf(c);\n\n        // Check if queue empty only if necessary.\n        // 如果线程池正在关闭却队列已经为空，或者线程池已关闭，修改工作线程数量\n        // 当前线程会自然运行结束\n        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {\n            decrementWorkerCount(); // CAS机制\n            return null;\n        }\n\n        int wc = workerCountOf(c);\n\n        // Are workers subject to culling?\n        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;\n\n        // 此处用于维护核心线程数量\n        if ((wc > maximumPoolSize || (timed && timedOut))\n            && (wc > 1 || workQueue.isEmpty())) {\n            if (compareAndDecrementWorkerCount(c))\n                return null;\n            continue;\n        }\n\n        try {\n            Runnable r = timed ?\n                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                workQueue.take();\n            if (r != null)\n                return r;\n            timedOut = true;\n        } catch (InterruptedException retry) {\n            timedOut = false;\n        }\n    }\n}\n```\n\n#### 任务的获取与工作线程间的“协议”\n* 当线程池关闭时，获取任务方法将返回`null`，并关闭工作线程。\n* 当工作线程执行完首个任务后，再次获取任务时将 *维护核心工作线程数量*\n\n#### 工作线程退出流程\n1. 统计线程池已完成任务数量（需要获取mainLock）\n2. 在工作线程组中剔除当前线程\n3. 尝试终止线程池\n4. \n\n``` java\nprivate void processWorkerExit(Worker w, boolean completedAbruptly) {\n    // 如果当前工作线程异常，需要修正工作线程数量\n    // 因为正常情形下（队列为空后），getTask方法发现队列为空时，已经修改了工作线程数量\n    if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted\n        decrementWorkerCount();\n\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        completedTaskCount += w.completedTasks;\n        workers.remove(w);\n    } finally {\n        mainLock.unlock();\n    }\n\n    // 尝试终止线程池\n    tryTerminate();\n\n    int c = ctl.get();\n\n    // 如果线程池没有被关闭，则需要维持最小的工作线程数:\n    // 允许核心工作线超时，最小数量为0，否则最小数量为预测值corePoolSize\n    // 特例：如果最小数量为0，但队列又不为空，那修正为1（因为总要有工作的线程吧）\n    if (runStateLessThan(c, STOP)) {\n        if (!completedAbruptly) { // 当前工作线程正常退出时，需要判断是否有足够多的核心工作线程\n            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;\n            if (min == 0 && ! workQueue.isEmpty())\n                min = 1;\n            if (workerCountOf(c) >= min)\n                return; // replacement not needed\n        }\n\n        // 线程池没有关闭 且 工作线程数量小于核心工作线程数，则需要再重新启动一个线程，保持核心工作线程数\n        addWorker(null, false); // 线程补足\n    }\n}\n```\n如果线程池没有被关闭，则需要维持最小的工作线程数：允许核心工作线超时，最小数量为0，否则最小数量为预测值corePoolSize。\n*特例*：如果此时最小数量为0，但队列不为空（有可能执行完队列中任务的同时，有并发线程提交了任务），那么修正为1（因为总要有工作的线程吧）\n\n\n## 总结\n\n* 时刻检查线程池状态：\n* 状态的深刻要理解，因为线程池状态的检查无处不在，也需要时刻检查：\n  * SHUTDOWN：不再接受新的任务（不再创建工作线程），但需要依次执行队列中任务*（特别是工作线程发生异常时，需要保证至少有1个工作线程去完成队列中任务，必须时还需重新创建工作线程）*\n  * STOP：不再处理任务，立刻中断所有工作线程\n* CAS（campare and set）机制与原子性：\n  为了提高系统活跃度，整个框架总是先获取线程池状态：`c=ctl.get()`，然后循环`for(;;)`进行*compareAndSet*操作，确保*当前一系列操作的原子性*没有被破坏\n* mainLock：工作线程workers、已完成任务数量completedTaskCount均是非线程安全的，通过`ReentrantLock`保证其线程安全\n\n\n","source":"_posts/executor-in-java-concurrency.md","raw":"---\ntitle: Java中的多线程（五）：ThreadPoolExecutor框架源码解析\ndate: 2016-04-07 17:07:43\ntags: \n- Concurrency\n- ThreadPool\ncategories: Java-Core\ntoc: true\n---\n\n启动线程任务最简单的方式是：为每个任务都创建一个线程（per-task）。在没有超出服务器处理能力时，这种方法既可以提升响应速度、又可以提升吞吐量。\n\n而在实际应用中，这种*thread-per-task*存在缺陷，特别是需要创建大量的线程时：\n\n* 线程创建的开销：线程的创建与关闭不是“免费”的\n* 资源消耗量：活动的线程会消耗系统资源\n\n所以，在一定范围内，增加线程可以提高系统的吞吐量。但一旦超过这个范围，再创建更多的线程只会增加系统开销，并有可能导致应用程序崩溃。所以应该限制你的应用程序可以创建的线程数量，确保线程数达到这个极限时，程序也不至于耗尽所有资源。于是线程池应运而生。\n\n<!-- more -->\n\n## ThreadPoolExecutor\nJava中内置的线程池，主要通过`Executors`的静态工厂方法创建不同类型的线程池，如：\n``` java\npublic class Executors {\n\n    public static ExecutorService newSingleThreadExecutor() {}\n\n    public static ExecutorService newFixedThreadPool(int nThreads) {}\n\n    public static ExecutorService newCachedThreadPool() {}\n}\n```\n\n## 相关类设计\n### Executor\n用于提交任务的接口：将任务的提交与任务执行细节隔离。\n``` java\npublic interface Executor {\n\n    void execute(Runnable command);\n}\n```\n\n### ExecutorService\n线程状态/生命周期的管理接口：提交任务、关闭线程池、查询线程池状态等。\n``` java\npublic interface ExecutorService extends Executor {\n    \n    void shutdown();\n\n    List<Runnable> shutdownNow();\n\n    boolean isShutdown();\n\n    boolean isTerminated();\n\n    <T> Future<T> submit(Callable<T> task);\n\n    <T> Future<T> submit(Runnable task, T result);\n}\n```\n\n## 基本结构\n* corePoolSize：最小的活跃线程数\n* maximumPoolSize：最大的处理作业线程数，受限于`CAPACITY`\n* workers：线程池中所有的工作线程\n* workQueue：阻塞（缓存）队列，向工作的线程传递任务\n* ctl：线程池状态(AtomicInteger)，按二进制的位数切分后包含两部分：`runState|workerCount`\n  * workerCount：活跃的线程数，范围(2^29)-1，占据ctl的前28位\n  * runState：线程池状态包括运行、正在关闭等，由剩下的4位组成\n    * RUNNING：接受新的任务，并且处理队列中的任务\n    * SHUTDOWN：不再接受新的任务，但是会处理完队列中任务\n    * STOP：不再接受新的任务，也不会处理队列中的任务，同时会中断正在执行的任务\n    * TIDYING：所有任务被终止，workerCount=0。会调用`terminated()`方法\n    * TERMINATED：`terminated()`方法执行完毕\n    以上这些状态是可比较的，依次递增\n\n## 线程池中主要原理/机制\n\n### 任务的执行机制\n线程的执行机制主要在`execute`方法中，任务的提交其实是封装线程后，再执行：\n``` java\npublic <T> Future<T> submit(Runnable task, T result) {\n    if (task == null) throw new NullPointerException();\n    // 构造Future\n    RunnableFuture<T> ftask = newTaskFor(task, result);\n\n    // 执行\n    execute(ftask);\n    return ftask;\n}\n```\n当一个线程被提交后，线程池的工作机制为：\n\n1. 如果当前工作的线程数小于设置的核心线程数，则新建一个线程执行此任务\n2. 如果工作的线程数已满足核心线程数，则将任务放入用于存放待执行任务的队列中（后续会被处理）\n3. 如果缓存队列已满，则新建一个线程执行此任务（此时工作线程数*大于*核心线程数）\n\n``` java\npublic void execute(Runnable command) {\n    if (command == null)\n        throw new NullPointerException();\n\n    int c = ctl.get();\n    if (workerCountOf(c) < corePoolSize) { // 如果工作线程小于核心线程池数量\n        if (addWorker(command, true)) // 创建一个新的核心线程来处理当前任务\n            return;\n        c = ctl.get();\n    }\n    if (isRunning(c) && workQueue.offer(command)) { // 如果线程池还在运行中，将任务添加到缓存队列\n        int recheck = ctl.get(); // 添加到缓存队列后，仍然需要二次检查\n        if (! isRunning(recheck) && remove(command)) // 如果线程池关闭，删除刚刚添加的任务\n            reject(command); // 如果成功删除，则执行任务拒绝流程\n        else if (workerCountOf(recheck) == 0) // 如果没有在工作的线程，需要启动一个线程来队列中任务\n            addWorker(null, false); // 创建一个线程来处理刚刚被加入到队列的任务\n    }\n    else if (!addWorker(command, false)) // 如果缓存队列已满，创建一个新的线程来处理当前任务\n        reject(command);\n}\n```\n#### 线程池状态二次校验\n将任务放入缓存队列后对线程池状态有一个二次校验：如果线程池已经关闭，那么将其从队列中剔除，并且直接执行拒绝流程。当然没有这块判断，这个任务最终也不会被执行，只是反馈被延迟了。\n\n### 线程的新增机制\n`addWorker`方法至关重要，因为增加工作线程总是伴随着任务的提交，新建的线程需要立刻用于执行被提交的任务：\n\n1. 首先检查线程池状态：排除明显不需要再创建线程的场景，如线程池已经关闭则不再接受新的任务，或者正在关闭时，队列中的任务已经为空\n2. 然后检查线程上限，然后增加线程池中工作线程的数量\n3. 最后获取线程池锁，新增工作线程，*并将其启动*\n\n``` java\n// 参数core在判断工作线程上限时使用:\n// true:表示上限为核心线程数, false:表示上限为最大线程数.\nprivate boolean addWorker(Runnable firstTask, boolean core) {\n    retry:\n    for (;;) {\n        int c = ctl.get();\n        int rs = runStateOf(c);\n\n        // Check if queue empty only if necessary.\n        // 线程池非运行状态下：\n        // 1. 非正在关闭状态：不再增加工作线程，因为已经在强制关闭或已经关闭\n        // 2. task!=null：不再接受新的任务，但可能会创建新的线程来处理队列中任务\n        // 3. 缓存队列为空：不需要线程线程，因为没有需要处理的任务了\n        if (rs >= SHUTDOWN &&\n            ! (rs == SHUTDOWN &&\n               firstTask == null &&\n               ! workQueue.isEmpty()))\n            return false;\n\n        // 更新工作线程数量：\n        // 1. 更新机制：CAS(CompareAndSet)，确保是当前线程执行了更新\n        // 2. 如果线程池运行状态发生变更，需要重新获取线程池状态：ctl\n        for (;;) {\n            int wc = workerCountOf(c);\n\n            // 工作线程数量的上限判断\n            if (wc >= CAPACITY ||\n                wc >= (core ? corePoolSize : maximumPoolSize))\n                return false;\n\n            // 如果工作线程数量“更加”成功（n=>n+1），则跳出retry，去创建线程\n            if (compareAndIncrementWorkerCount(c))\n                break retry;\n\n            c = ctl.get();  // Re-read ctl\n            if (runStateOf(c) != rs)\n                continue retry; 线程池运行状态发生变更，需要重新获取线程池状态：ctl\n            // else CAS failed due to workerCount change; retry inner loop\n        }\n    }\n\n    boolean workerStarted = false;\n    boolean workerAdded = false;\n    Worker w = null;\n    try {\n        w = new Worker(firstTask);\n        final Thread t = w.thread;\n        if (t != null) {\n            final ReentrantLock mainLock = this.mainLock;\n            mainLock.lock();\n            try {\n                // Recheck while holding lock.\n                // Back out on ThreadFactory failure or if\n                // shut down before lock acquired.\n                int rs = runStateOf(ctl.get());\n\n                // 需要创建新线程的场景：\n                // 1. 运行状态\n                // 2. 正在关闭并且该线程是用来处理缓存队列中任务(task=null) \n                if (rs < SHUTDOWN ||\n                    (rs == SHUTDOWN && firstTask == null)) {\n                    if (t.isAlive()) // precheck that t is startable\n                        throw new IllegalThreadStateException();\n                    workers.add(w);\n                    int s = workers.size();\n                    if (s > largestPoolSize)\n                        largestPoolSize = s;\n                    workerAdded = true;\n                }\n            } finally {\n                mainLock.unlock();\n            }\n            if (workerAdded) {\n                t.start();\n                workerStarted = true;\n            }\n        }\n    } finally {\n        if (! workerStarted)\n            addWorkerFailed(w);\n    }\n    return workerStarted;\n}\n```\n\n#### 状态变量的变化没有上锁\n1. 因为线程池的状态变量已为线程安全的，也就没有通过外部锁去控制它变化的原子性，这样将有很大的灵活性，多个线程在检查线程池状态时不存在竞争关系。但这也要求：在修改状态变量ctl时必须保证同时只有一个线程去修改它，因为它的检查与修改不具有原子性。这里用的是jvm底层`CAS-check and set`机制\n2. 工作线程也没有上锁，所以工作线程变更时需要获取外部锁\n\n### 工作线程worker的运行机制\n内部类`Worker`实现了`Runnable`，也是一个任务，run方法委托给了外部的`runWorker`。\n\n* 工作线程被启动后总是先运行第一个任务（也就是初始化工作线程时的任务）\n* 如果第一个任务任务为`null`，则*循环*从缓存缓存队列中获取任务，直到队列为空\n* 每次获取任务后，要检查线程池状态，必要时（线程池已关闭）及时中断该工作线程\n* 缓存队列为空后，执行线程组退出流程：统计已完成的任务数量等\n\n``` java\nprivate final class Worker extends AbstractQueuedSynchronizer implements Runnable {\n    public void run() {\n        runWorker(this);\n    }\n}\n\nfinal void runWorker(Worker w) {\n    Thread wt = Thread.currentThread();\n    Runnable task = w.firstTask;\n    w.firstTask = null;\n    w.unlock(); // allow interrupts\n    // 防止工作线程处理队列中任务时发生异常，预设标记值\n    boolean completedAbruptly = true;\n    try {\n        // 循环获取任务\n        while (task != null || (task = getTask()) != null) {\n            w.lock();\n            // If pool is stopping, ensure thread is interrupted;\n            // if not, ensure thread is not interrupted.  This\n            // requires a recheck in second case to deal with\n            // shutdownNow race while clearing interrupt\n            // 每次执行任务时，都需要检查线程池状态，及时中断当前线程\n            if ((runStateAtLeast(ctl.get(), STOP) ||\n                 (Thread.interrupted() &&\n                  runStateAtLeast(ctl.get(), STOP))) &&\n                !wt.isInterrupted())\n                wt.interrupt();\n            try {\n                beforeExecute(wt, task);\n                Throwable thrown = null;\n                try {\n                    task.run();\n                } catch (RuntimeException x) {\n                    thrown = x; throw x;\n                } catch (Error x) {\n                    thrown = x; throw x;\n                } catch (Throwable x) {\n                    thrown = x; throw new Error(x);\n                } finally {\n                    afterExecute(task, thrown);\n                }\n            } finally {\n                task = null;\n                w.completedTasks++;\n                w.unlock();\n            }\n        }\n        completedAbruptly = false; // 改工作线程工作正常，没有发生异常\n    } finally {\n        // 缓存队列中已经没有任务，则可以退出了：修改线程池相关状态\n        processWorkerExit(w, completedAbruptly);\n    }\n}\n```\n\n### 获取缓存队列中任务\n1. 检查线程池状态：如果线程池正在关闭却队列已经为空，或者线程池已关闭，修改工作线程数量，因为当前线程会自然运行结束\n2. 维护核心线程数量：超过核心线程后需要停掉该线程（此时已经完成工作线程的第一个任务）\n\n``` java\nprivate Runnable getTask() {\n    boolean timedOut = false; // Did the last poll() time out?\n\n    for (;;) {\n        int c = ctl.get();\n        int rs = runStateOf(c);\n\n        // Check if queue empty only if necessary.\n        // 如果线程池正在关闭却队列已经为空，或者线程池已关闭，修改工作线程数量\n        // 当前线程会自然运行结束\n        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {\n            decrementWorkerCount(); // CAS机制\n            return null;\n        }\n\n        int wc = workerCountOf(c);\n\n        // Are workers subject to culling?\n        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;\n\n        // 此处用于维护核心线程数量\n        if ((wc > maximumPoolSize || (timed && timedOut))\n            && (wc > 1 || workQueue.isEmpty())) {\n            if (compareAndDecrementWorkerCount(c))\n                return null;\n            continue;\n        }\n\n        try {\n            Runnable r = timed ?\n                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                workQueue.take();\n            if (r != null)\n                return r;\n            timedOut = true;\n        } catch (InterruptedException retry) {\n            timedOut = false;\n        }\n    }\n}\n```\n\n#### 任务的获取与工作线程间的“协议”\n* 当线程池关闭时，获取任务方法将返回`null`，并关闭工作线程。\n* 当工作线程执行完首个任务后，再次获取任务时将 *维护核心工作线程数量*\n\n#### 工作线程退出流程\n1. 统计线程池已完成任务数量（需要获取mainLock）\n2. 在工作线程组中剔除当前线程\n3. 尝试终止线程池\n4. \n\n``` java\nprivate void processWorkerExit(Worker w, boolean completedAbruptly) {\n    // 如果当前工作线程异常，需要修正工作线程数量\n    // 因为正常情形下（队列为空后），getTask方法发现队列为空时，已经修改了工作线程数量\n    if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted\n        decrementWorkerCount();\n\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        completedTaskCount += w.completedTasks;\n        workers.remove(w);\n    } finally {\n        mainLock.unlock();\n    }\n\n    // 尝试终止线程池\n    tryTerminate();\n\n    int c = ctl.get();\n\n    // 如果线程池没有被关闭，则需要维持最小的工作线程数:\n    // 允许核心工作线超时，最小数量为0，否则最小数量为预测值corePoolSize\n    // 特例：如果最小数量为0，但队列又不为空，那修正为1（因为总要有工作的线程吧）\n    if (runStateLessThan(c, STOP)) {\n        if (!completedAbruptly) { // 当前工作线程正常退出时，需要判断是否有足够多的核心工作线程\n            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;\n            if (min == 0 && ! workQueue.isEmpty())\n                min = 1;\n            if (workerCountOf(c) >= min)\n                return; // replacement not needed\n        }\n\n        // 线程池没有关闭 且 工作线程数量小于核心工作线程数，则需要再重新启动一个线程，保持核心工作线程数\n        addWorker(null, false); // 线程补足\n    }\n}\n```\n如果线程池没有被关闭，则需要维持最小的工作线程数：允许核心工作线超时，最小数量为0，否则最小数量为预测值corePoolSize。\n*特例*：如果此时最小数量为0，但队列不为空（有可能执行完队列中任务的同时，有并发线程提交了任务），那么修正为1（因为总要有工作的线程吧）\n\n\n## 总结\n\n* 时刻检查线程池状态：\n* 状态的深刻要理解，因为线程池状态的检查无处不在，也需要时刻检查：\n  * SHUTDOWN：不再接受新的任务（不再创建工作线程），但需要依次执行队列中任务*（特别是工作线程发生异常时，需要保证至少有1个工作线程去完成队列中任务，必须时还需重新创建工作线程）*\n  * STOP：不再处理任务，立刻中断所有工作线程\n* CAS（campare and set）机制与原子性：\n  为了提高系统活跃度，整个框架总是先获取线程池状态：`c=ctl.get()`，然后循环`for(;;)`进行*compareAndSet*操作，确保*当前一系列操作的原子性*没有被破坏\n* mainLock：工作线程workers、已完成任务数量completedTaskCount均是非线程安全的，通过`ReentrantLock`保证其线程安全\n\n\n","slug":"executor-in-java-concurrency","published":1,"updated":"2016-04-30T06:56:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciziguc5c001gnps6gze0i52b"},{"title":"Java应用中的数据库访问","date":"2016-01-24T05:56:04.000Z","toc":true,"_content":"\n\n早起对数据库的访问，都是直接调用数据库厂商提供的专有API。[ODBC(Open Database Connectivity)](https://zh.wikipedia.org/zh-cn/ODBC)是微软开放服务结构（WOSA，Windows Open Service Architecture）中有关数据库的一部分，提供了Windows下统一的数据库访问方式。使用者只需要调用ODBC API，由ODBC驱动程序将调用请求转化为对特定数据库的调用请求。\n\nJava语言问世后，Sun公司与1996年推出了[JDBC(Java Database Connectivity)](https://zh.wikipedia.org/zh-cn/Java%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5)，提供了对数据库访问的统一方式。JDBC是一套标准的访问关系数据库的Java类库，同时为数据库厂商提供了一个标准的API，让厂商为自己的数据库产品提供相应的JDBC驱动程序。应用程序调用JDBC API，由JDBC驱动程序（具体数据库厂商的实现层）处理与数据库的通信，从而使应用程序与具体数据库产品解耦。\n\n<!-- more -->\n\n## 加载注册数据库驱动\n\n### Drive接口\n\n`javax.sql.Driver`是所有JDBC驱动程序需要实现的接口。\n\n其中，`connect(url, info)`方法用于建立到数据到的连接。而在实际的应用程序中，不需要直接调用此方法，而是通过JDBC驱动程序管理器`DriverManager`注册相应的驱动程序，使用驱动管理器来建立数据库连接。\n\n### 加载注册JDBC驱动\n\n加载JDBC驱动通过`Class.forName(String className)`在CLASSPATH中定位、加载驱动类。\n\n注册JDBC驱动实例则是通过`Driver.registerDriver(Driver driver)`来完成。通常，不需要我们亲自去注册，因为实现了`Driver`的驱动类都包含一个静态区，调用驱动管理器的静态方法来注册自己的一个实例。\n\n``` java\npublic class Driver extends NonRegisteringDriver implements java.sql.Driver {\n\n    static {\n        try {\n            java.sql.DriverManager.registerDriver(new Driver());\n        } catch (SQLException E) {\n            throw new RuntimeException(\"Can't register driver!\");\n        }\n    }\n\n    public Driver() throws SQLException {\n        // Required for Class.forName().newInstance()\n    }\n}\n```\n\n## 建立到数据库的连接\n\n通过`DriverManager.getConnection(String url, String user, String password)`建立到数据库的连接（代理给相应的驱动程序）\n\n### JDBC URL\n\n`jdbc:subprotocol:subname`：\n\n* 协议：jdbc，唯一允许的协议\n* 子协议：标识一个数据库驱动程序，如mysql、sqlserver\n* 子名称：与具体数据库驱动有关，如mysql中：jdbc:mysql://localhost:3306/database\n\n## 数据库访问\n\n数据库访问通过建立的连接的来访问，有3种方式`Statement`、`PreparedStatement`、`CallableStatement`。\n\n### Statement\n\n用于执行静态的SQL语句，通过`Connection.createStatement()`来创建。\n\n``` java\npublic interface Statement {\n    /** 执行查询语句 */\n    ResultSet executeQuery(String sql) throws SQLException;\n\n    /** 用于执行INSERT、UPDATE、DELETE等语句 */\n    int executeUpdate(String sql) throws SQLException;\n\n    /** 通过`addBatch()`批量添加sql命令，然后一起执行 */\n    int[] executeBatch() throws SQLException;\n}\n```\n\n### ResultSet\n\n`ResultSet`以*逻辑表格*封装了数据库执行结果，由数据库厂商来实现。\n\n``` java\npublic interface ResultSet {\n    /** 将游标移动到下一行，如果该行有数据返回`true`，否则返回`false` */\n    boolean next() throws SQLException;\n\n    /** 通过索引（1开始）查看某列数据 **/\n    String getString(int columnIndex) throws SQLException;\n\n    /** 通过列名称查看某列数据 **/\n    String getString(String columnLabel) throws SQLException;\n}\n```\n\n### PreparedStatement\n\nsql语句在执行以前需要预编译，包括语句分析、代码优化等。如果仅仅是参数不同的sql语句，可以使用`PreparedStatement`。\n\n### ResultSetMetaData\n\n用于描述数据库表结构的元数据， `ResultSet.getMetaData()`\n\n## 事务处理\n\n* 脏读（dirty read）\n  一个事务对数据进行了修改，但没有提交，与此同时另外一个事务读取了被修改的数据。如若前一个事务发生回滚，那么后一个事务读取的数据也就是无效数据。\n* 不可重复读（non-repeatable read）\n  一个事务读取了一行数据，在事务结束以前另外一个事务对这行数据进行了修改，那么当前一个事务再次读取那部分数据时，得到了不同的数据。\n* 幻读（phantom read）\n  一个事务查询某条件下的数据，事务结束之前另外一个事务又插入一些满足条件的数据，那么当第一个事务再次查询时发现数据多出几行。\n\n### `Connection`中关于事务隔离级别的常量\n\n``` java\npublic interface Connection {\n    /** 不支持事务 */\n    int TRANSACTION_NONE             = 0;\n\n    /** 允许脏读 */\n    int TRANSACTION_READ_UNCOMMITTED = 1;\n\n    /** 不允许脏读，但允许不可重复我和幻读 */\n    int TRANSACTION_READ_COMMITTED   = 2;\n\n    /** 不允许脏读、不可重复读，但允许幻读 */\n    int TRANSACTION_REPEATABLE_READ  = 4;\n\n    /** 脏读、不可重复读、幻读均不允许 */\n    int TRANSACTION_SERIALIZABLE     = 8;\n}\n```\n\nmysql默认级别为：`TRANSACTION_READ_COMMITTED`, 禁止脏读、不可重复读。\n\n而事务默认为*自动提交*，可通过`Connection.setAutoCommit(false)`来重置，自行提交（commit）或回滚（rollback）。\n\n## JDBC数据源和连接池\n\n对数据库的访问除了加载、实例化驱动程序并通过驱动程序管理器获得连接外，还可通过`DataSource`来实现（由数据库厂商实现）。\n\n### 什么是连接池\n\n建立数据库连接的成本是很大的，并且一个数据库服务器能够同时建立的连接数是有限的。在web应用中可能同时会有成千上万个访问数据库的请求，如果为每个请求创建一个数据库连接，性能将急剧下降。为了能够*重复利用数据库连接*，提高对请求的响应时间和服务器性能，于是诞生了数据库连接池。\n\n数据库连接池预先建立了一些数据库连接，然后保存到连接池中，当有访问数据库的请求时，从池中取出一个闲置的连接对象完成对数据的访问，请求结束后将连接对象放回池中。\n\n调用物理连接的`close`方法将关闭连接，而连接池的连接的`close`方法为释放连接对象放回连接池中。\n\n大部分servlet容器都支持基于JNDI的数据库连接池的配置，如[Tomcat](http://tomcat.apache.org/tomcat-9.0-doc/jndi-datasource-examples-howto.html)，[Jetty](http://www.eclipse.org/jetty/documentation/current/jndi-datasource-examples.html)。\n\n### 连接池实现\n\n* [Apache Commons DBCP](http://commons.apache.org/proper/commons-dbcp/)\n* [c3p0](http://sourceforge.net/projects/c3p0/)\n* [bonecp](https://github.com/wwadge/bonecp)\n\n\n","source":"_posts/database-access-in-java.md","raw":"---\ntitle: Java应用中的数据库访问\ndate: 2016-01-24 13:56:04\ntags: JDBC\ncategories:\ntoc: true\n---\n\n\n早起对数据库的访问，都是直接调用数据库厂商提供的专有API。[ODBC(Open Database Connectivity)](https://zh.wikipedia.org/zh-cn/ODBC)是微软开放服务结构（WOSA，Windows Open Service Architecture）中有关数据库的一部分，提供了Windows下统一的数据库访问方式。使用者只需要调用ODBC API，由ODBC驱动程序将调用请求转化为对特定数据库的调用请求。\n\nJava语言问世后，Sun公司与1996年推出了[JDBC(Java Database Connectivity)](https://zh.wikipedia.org/zh-cn/Java%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5)，提供了对数据库访问的统一方式。JDBC是一套标准的访问关系数据库的Java类库，同时为数据库厂商提供了一个标准的API，让厂商为自己的数据库产品提供相应的JDBC驱动程序。应用程序调用JDBC API，由JDBC驱动程序（具体数据库厂商的实现层）处理与数据库的通信，从而使应用程序与具体数据库产品解耦。\n\n<!-- more -->\n\n## 加载注册数据库驱动\n\n### Drive接口\n\n`javax.sql.Driver`是所有JDBC驱动程序需要实现的接口。\n\n其中，`connect(url, info)`方法用于建立到数据到的连接。而在实际的应用程序中，不需要直接调用此方法，而是通过JDBC驱动程序管理器`DriverManager`注册相应的驱动程序，使用驱动管理器来建立数据库连接。\n\n### 加载注册JDBC驱动\n\n加载JDBC驱动通过`Class.forName(String className)`在CLASSPATH中定位、加载驱动类。\n\n注册JDBC驱动实例则是通过`Driver.registerDriver(Driver driver)`来完成。通常，不需要我们亲自去注册，因为实现了`Driver`的驱动类都包含一个静态区，调用驱动管理器的静态方法来注册自己的一个实例。\n\n``` java\npublic class Driver extends NonRegisteringDriver implements java.sql.Driver {\n\n    static {\n        try {\n            java.sql.DriverManager.registerDriver(new Driver());\n        } catch (SQLException E) {\n            throw new RuntimeException(\"Can't register driver!\");\n        }\n    }\n\n    public Driver() throws SQLException {\n        // Required for Class.forName().newInstance()\n    }\n}\n```\n\n## 建立到数据库的连接\n\n通过`DriverManager.getConnection(String url, String user, String password)`建立到数据库的连接（代理给相应的驱动程序）\n\n### JDBC URL\n\n`jdbc:subprotocol:subname`：\n\n* 协议：jdbc，唯一允许的协议\n* 子协议：标识一个数据库驱动程序，如mysql、sqlserver\n* 子名称：与具体数据库驱动有关，如mysql中：jdbc:mysql://localhost:3306/database\n\n## 数据库访问\n\n数据库访问通过建立的连接的来访问，有3种方式`Statement`、`PreparedStatement`、`CallableStatement`。\n\n### Statement\n\n用于执行静态的SQL语句，通过`Connection.createStatement()`来创建。\n\n``` java\npublic interface Statement {\n    /** 执行查询语句 */\n    ResultSet executeQuery(String sql) throws SQLException;\n\n    /** 用于执行INSERT、UPDATE、DELETE等语句 */\n    int executeUpdate(String sql) throws SQLException;\n\n    /** 通过`addBatch()`批量添加sql命令，然后一起执行 */\n    int[] executeBatch() throws SQLException;\n}\n```\n\n### ResultSet\n\n`ResultSet`以*逻辑表格*封装了数据库执行结果，由数据库厂商来实现。\n\n``` java\npublic interface ResultSet {\n    /** 将游标移动到下一行，如果该行有数据返回`true`，否则返回`false` */\n    boolean next() throws SQLException;\n\n    /** 通过索引（1开始）查看某列数据 **/\n    String getString(int columnIndex) throws SQLException;\n\n    /** 通过列名称查看某列数据 **/\n    String getString(String columnLabel) throws SQLException;\n}\n```\n\n### PreparedStatement\n\nsql语句在执行以前需要预编译，包括语句分析、代码优化等。如果仅仅是参数不同的sql语句，可以使用`PreparedStatement`。\n\n### ResultSetMetaData\n\n用于描述数据库表结构的元数据， `ResultSet.getMetaData()`\n\n## 事务处理\n\n* 脏读（dirty read）\n  一个事务对数据进行了修改，但没有提交，与此同时另外一个事务读取了被修改的数据。如若前一个事务发生回滚，那么后一个事务读取的数据也就是无效数据。\n* 不可重复读（non-repeatable read）\n  一个事务读取了一行数据，在事务结束以前另外一个事务对这行数据进行了修改，那么当前一个事务再次读取那部分数据时，得到了不同的数据。\n* 幻读（phantom read）\n  一个事务查询某条件下的数据，事务结束之前另外一个事务又插入一些满足条件的数据，那么当第一个事务再次查询时发现数据多出几行。\n\n### `Connection`中关于事务隔离级别的常量\n\n``` java\npublic interface Connection {\n    /** 不支持事务 */\n    int TRANSACTION_NONE             = 0;\n\n    /** 允许脏读 */\n    int TRANSACTION_READ_UNCOMMITTED = 1;\n\n    /** 不允许脏读，但允许不可重复我和幻读 */\n    int TRANSACTION_READ_COMMITTED   = 2;\n\n    /** 不允许脏读、不可重复读，但允许幻读 */\n    int TRANSACTION_REPEATABLE_READ  = 4;\n\n    /** 脏读、不可重复读、幻读均不允许 */\n    int TRANSACTION_SERIALIZABLE     = 8;\n}\n```\n\nmysql默认级别为：`TRANSACTION_READ_COMMITTED`, 禁止脏读、不可重复读。\n\n而事务默认为*自动提交*，可通过`Connection.setAutoCommit(false)`来重置，自行提交（commit）或回滚（rollback）。\n\n## JDBC数据源和连接池\n\n对数据库的访问除了加载、实例化驱动程序并通过驱动程序管理器获得连接外，还可通过`DataSource`来实现（由数据库厂商实现）。\n\n### 什么是连接池\n\n建立数据库连接的成本是很大的，并且一个数据库服务器能够同时建立的连接数是有限的。在web应用中可能同时会有成千上万个访问数据库的请求，如果为每个请求创建一个数据库连接，性能将急剧下降。为了能够*重复利用数据库连接*，提高对请求的响应时间和服务器性能，于是诞生了数据库连接池。\n\n数据库连接池预先建立了一些数据库连接，然后保存到连接池中，当有访问数据库的请求时，从池中取出一个闲置的连接对象完成对数据的访问，请求结束后将连接对象放回池中。\n\n调用物理连接的`close`方法将关闭连接，而连接池的连接的`close`方法为释放连接对象放回连接池中。\n\n大部分servlet容器都支持基于JNDI的数据库连接池的配置，如[Tomcat](http://tomcat.apache.org/tomcat-9.0-doc/jndi-datasource-examples-howto.html)，[Jetty](http://www.eclipse.org/jetty/documentation/current/jndi-datasource-examples.html)。\n\n### 连接池实现\n\n* [Apache Commons DBCP](http://commons.apache.org/proper/commons-dbcp/)\n* [c3p0](http://sourceforge.net/projects/c3p0/)\n* [bonecp](https://github.com/wwadge/bonecp)\n\n\n","slug":"database-access-in-java","published":1,"updated":"2016-02-08T01:56:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciziguc5h001lnps69e2r85id"},{"title":"Servlet3.0中配置DispatcherServlet","date":"2016-01-15T16:08:30.000Z","toc":true,"_content":"\n大家都知道`DispatcherServelt`是 *spring-mvc* 中的前端控制器。按照传统的方式，可以在`web.xml`中配置这个 *servlet* 。\n\n而在 *Servlet 3.0* 以后，支持通过注解配置 *servlet*、*listener*、*filter*等，同时也支持以注解方式配置*servlet container*，达到与配置`web.xml`一样的效果。\n\n这篇文章主要介绍下*如何在Servlet 3.0下以 Java-Code 配置Servlet Container以及Dispatcher Servlet*。\n\n<!-- more -->\n\n## 传统web.xml中定义Servlet\n\n通过`web.xml`来配置一个web应用时，一般是这样子的：\n\n``` xml code.1-web.xml\n<web-app xmlns=\"http://java.sun.com/xml/ns/javaee\" version=\"2.5\">\n    <servlet>\n        <servlet-name>dispatcher</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value>/WEB-INF/spring/dispatcher-config.xml</param-value>\n        </init-param>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n\n    <servlet-mapping>\n        <servlet-name>dispatcher</servlet-name>\n        <url-pattern>/</url-pattern>\n    </servlet-mapping>\n</web-app>\n```\n\n## ServletContainerInitializer\n\nServlet 3.0中，定义了一个接口：`javax.servlet.ServletContainerInitializer`，在Servlet 3.0下，将会在 *classpath* 下寻找该接口的实现，然后以此来配置Servlet Container。\n\n> Implementations of this interface may be annotated with `HandlesTypes`, in order to receive (at their `onStartup` method) the Set of application classes that implement, extend, or have been annotated with the class types specified by the annotation. \n\n> Implementations of this interface must be declared by a JAR file resource located inside the `META-INF/services` directory and named for the fully qualified class name of this interface, and will be discovered using the runtime's service provider lookup mechanism or a container specific mechanism that is semantically equivalent to it.\n\n通过其注释不难得知：\n\n1. 被`@HandlesTypes`注解的接口的 *实现* 将被以参数的方式传给其方法 `onStartup`\n2. 具体实现必须在JAR包的Spring中的 *META-INF/services* 下声明其实现。它的运行时发现机制其实是通过`ServiceLoader`实现的，具体参考官方文档[Service Provider](http://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html#Service_Provider)\n\n## SpringServletContainerInitializer\n\n### provider声明\n\n在 *spring-web* 包下的 *META-INF/services* 中定义有：\n\n``` properties code.2-javax.servlet.ServletContainerInitializer\norg.springframework.web.SpringServletContainerInitializer\n```\n\n### 接口定义\n\n``` java SpringServletContainerInitializer.java\n@HandlesTypes(WebApplicationInitializer.class)\npublic class SpringServletContainerInitializer implements ServletContainerInitializer {\n    \n    @Override\n    public void onStartup(Set<Class<?>> webAppInitializerClasses, ServletContext servletContext) throws ServletException {\n\n    }\n\n}\n```\n\n### onStartup 具体实现\n\n``` java code.3-SpringServletContainerInitializer.onStartup\nList<WebApplicationInitializer> initializers = new LinkedList<WebApplicationInitializer>();\n\nif (webAppInitializerClasses != null) {\n    for (Class<?> waiClass : webAppInitializerClasses) {\n\n        // servlet container传入的参数均为具体实现，而非接口或抽象类\n        if (!waiClass.isInterface() && !Modifier.isAbstract(waiClass.getModifiers())\n            && WebApplicationInitializer.class.isAssignableFrom(waiClass)) {\n\n            try {\n                initializers.add((WebApplicationInitializer) waiClass.newInstance());\n            }\n            catch (Throwable ex) {\n                throw new ServletException(\"Failed to instantiate WebApplicationInitializer class\", ex);\n            }\n        }\n    }\n}\n\n...\n\n// 初始化 Servlet Context\nfor (WebApplicationInitializer initializer : initializers) {\n    initializer.onStartup(servletContext);\n}\n```\n\n## 通过java code初始化Servlet Context\n\n初始化 *Servlet Context* 的工作其实是委托给了`WebApplicationInitializer`的实现类，那么我们就可以自定义其实现过程，如：\n\n``` java code.4-MyWebAppInitializer.java\npublic class MyWebAppInitializer implements WebApplicationInitializer {\n    \n    @Override\n    public void onStartup(ServletContext container) {\n        XmlWebApplicationContext appContext = new XmlWebApplicationContext();\n        appContext.setConfigLocation(\"/WEB-INF/spring/dispatcher-config.xml\");\n\n        ServletRegistration.Dynamic dispatcher = \n        container.addServlet(\"dispatcher\", new DispatcherServlet(appContext));\n\n        dispatcher.setLoadOnStartup(1);\n        dispatcher.addMapping(\"/\");\n    }\n\n}\n```\n\n这样，我们就完全取代了`web.xml`。但是，还是`/WEB-INF/spring/dispatcher-config.xml`还是XML配置，能否也用 *Java-Code* 替代呢？\n\n答案是肯定的，因为Spring 3.0就支持通过注解`@Configuration`来实现以往通过XML形式配置的工作了：\n\n``` java code.5-MyWebAppInitializer.java\npublic class MyWebAppInitializer implements WebApplicationInitializer {\n\n    @Override\n    public void onStartup(ServletContext container) {\n        // Create the 'root' Spring application context\n        AnnotationConfigWebApplicationContext rootContext =\n        new AnnotationConfigWebApplicationContext();\n        rootContext.register(AppConfig.class);\n\n        // Manage the lifecycle of the root application context\n        container.addListener(new ContextLoaderListener(rootContext));\n\n        // Create the dispatcher servlet's Spring application context\n        AnnotationConfigWebApplicationContext dispatcherContext =\n        new AnnotationConfigWebApplicationContext();\n        dispatcherContext.register(DispatcherConfig.class);\n\n        // Register and map the dispatcher servlet\n        ServletRegistration.Dynamic dispatcher =\n        container.addServlet(\"dispatcher\", new DispatcherServlet(dispatcherContext));\n        dispatcher.setLoadOnStartup(1);\n        dispatcher.addMapping(\"/\");\n    }\n\n }\n```\n\n以上的demo仅为简单实现，那么Spring中又是如何设计的呢？\n\n## Spring中如何设计\n\n分析`code.5`，其实变化的、需要用户具体指定的内容有3块：\n\n1. rootConfig：根容器配置\n2. dispatcherConfig：dispatcher配置\n3. mapping：dispatcherServlet匹配规则\n\n* AbstractContextLoaderInitializer\n\n``` java code.6-AbstractContextLoaderInitializer.java\npublic abstract class AbstractContextLoaderInitializer implements WebApplicationInitializer {\n    \n    @Override\n    public void onStartup(ServletContext servletContext) throws ServletException {\n        registerContextLoaderListener(servletContext);\n    }\n\n    protected void registerContextLoaderListener(ServletContext servletContext) {\n        WebApplicationContext rootAppContext = createRootApplicationContext();\n        \n        // 注册root ApplicationContext\n    }\n\n    protected abstract WebApplicationContext createRootApplicationContext();\n\n    protected ApplicationContextInitializer<?>[] getRootApplicationContextInitializers() {\n        return null;\n    }\n\n}\n```\n\n* AbstractDispatcherServletInitializer\n\n``` java code.7-AbstractDispatcherServletInitializer.java\npublic abstract class AbstractDispatcherServletInitializer extends AbstractContextLoaderInitializer {\n   \n    @Override\n    public void onStartup(ServletContext servletContext) throws ServletException {\n        super.onStartup(servletContext);\n\n        registerDispatcherServlet(servletContext);\n    }\n\n    protected void registerDispatcherServlet(ServletContext servletContext) {\n        WebApplicationContext servletAppContext = createServletApplicationContext();\n\n        ...\n    } \n\n    protected abstract WebApplicationContext createServletApplicationContext();\n\n    protected ApplicationContextInitializer<?>[] getServletApplicationContextInitializers() {\n        return null;\n    }\n\n    protected void customizeRegistration(ServletRegistration.Dynamic registration) {\n    }\n\n    // 用户自定义Url匹配规则\n    protected abstract String[] getServletMappings();\n\n}\n```\n\n* AbstractAnnotationConfigDispatcherServletInitializer\n\n``` java code.8-AbstractAnnotationConfigDispatcherServletInitializer.java\npublic abstract class AbstractAnnotationConfigDispatcherServletInitializer\n        extends AbstractDispatcherServletInitializer {\n\n    @Override\n    protected WebApplicationContext createRootApplicationContext() {\n        // create root ApplicationContext\n    }\n\n    @Override\n    protected WebApplicationContext createServletApplicationContext() {\n        // create servlet ApplicationContext\n    }\n\n    // 指定root ApplicationContext配置文件\n    protected abstract Class<?>[] getRootConfigClasses();\n\n    // 指定servlet ApplicationContext配置文件\n    protected abstract Class<?>[] getServletConfigClasses();\n\n}\n```\n\n## 最终配置\n\n``` java code.9-WebAppInitializer.java\npublic class WebAppInitializer \n    extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n    @Override\n    protected Class<?>[] getRootConfigClasses() {\n        return new Class<?>[] { RootConfig.class };\n    }\n\n    @Override\n    protected Class<?>[] getServletConfigClasses() {\n        return new Class<?>[] { WebConfig.class };\n    }\n\n    @Override\n    protected String[] getServletMappings() {\n        return new String[] { \"/\" };\n    }\n\n}\n```\n\n\n\n\n\n\n\n","source":"_posts/config-diapatcher-servlet-with-servlet3.0.md","raw":"---\ntitle: Servlet3.0中配置DispatcherServlet\ndate: 2016-01-16 00:08:30\ntags: Srping-MVC\ncategories: Spring\ntoc: true\n---\n\n大家都知道`DispatcherServelt`是 *spring-mvc* 中的前端控制器。按照传统的方式，可以在`web.xml`中配置这个 *servlet* 。\n\n而在 *Servlet 3.0* 以后，支持通过注解配置 *servlet*、*listener*、*filter*等，同时也支持以注解方式配置*servlet container*，达到与配置`web.xml`一样的效果。\n\n这篇文章主要介绍下*如何在Servlet 3.0下以 Java-Code 配置Servlet Container以及Dispatcher Servlet*。\n\n<!-- more -->\n\n## 传统web.xml中定义Servlet\n\n通过`web.xml`来配置一个web应用时，一般是这样子的：\n\n``` xml code.1-web.xml\n<web-app xmlns=\"http://java.sun.com/xml/ns/javaee\" version=\"2.5\">\n    <servlet>\n        <servlet-name>dispatcher</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value>/WEB-INF/spring/dispatcher-config.xml</param-value>\n        </init-param>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n\n    <servlet-mapping>\n        <servlet-name>dispatcher</servlet-name>\n        <url-pattern>/</url-pattern>\n    </servlet-mapping>\n</web-app>\n```\n\n## ServletContainerInitializer\n\nServlet 3.0中，定义了一个接口：`javax.servlet.ServletContainerInitializer`，在Servlet 3.0下，将会在 *classpath* 下寻找该接口的实现，然后以此来配置Servlet Container。\n\n> Implementations of this interface may be annotated with `HandlesTypes`, in order to receive (at their `onStartup` method) the Set of application classes that implement, extend, or have been annotated with the class types specified by the annotation. \n\n> Implementations of this interface must be declared by a JAR file resource located inside the `META-INF/services` directory and named for the fully qualified class name of this interface, and will be discovered using the runtime's service provider lookup mechanism or a container specific mechanism that is semantically equivalent to it.\n\n通过其注释不难得知：\n\n1. 被`@HandlesTypes`注解的接口的 *实现* 将被以参数的方式传给其方法 `onStartup`\n2. 具体实现必须在JAR包的Spring中的 *META-INF/services* 下声明其实现。它的运行时发现机制其实是通过`ServiceLoader`实现的，具体参考官方文档[Service Provider](http://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html#Service_Provider)\n\n## SpringServletContainerInitializer\n\n### provider声明\n\n在 *spring-web* 包下的 *META-INF/services* 中定义有：\n\n``` properties code.2-javax.servlet.ServletContainerInitializer\norg.springframework.web.SpringServletContainerInitializer\n```\n\n### 接口定义\n\n``` java SpringServletContainerInitializer.java\n@HandlesTypes(WebApplicationInitializer.class)\npublic class SpringServletContainerInitializer implements ServletContainerInitializer {\n    \n    @Override\n    public void onStartup(Set<Class<?>> webAppInitializerClasses, ServletContext servletContext) throws ServletException {\n\n    }\n\n}\n```\n\n### onStartup 具体实现\n\n``` java code.3-SpringServletContainerInitializer.onStartup\nList<WebApplicationInitializer> initializers = new LinkedList<WebApplicationInitializer>();\n\nif (webAppInitializerClasses != null) {\n    for (Class<?> waiClass : webAppInitializerClasses) {\n\n        // servlet container传入的参数均为具体实现，而非接口或抽象类\n        if (!waiClass.isInterface() && !Modifier.isAbstract(waiClass.getModifiers())\n            && WebApplicationInitializer.class.isAssignableFrom(waiClass)) {\n\n            try {\n                initializers.add((WebApplicationInitializer) waiClass.newInstance());\n            }\n            catch (Throwable ex) {\n                throw new ServletException(\"Failed to instantiate WebApplicationInitializer class\", ex);\n            }\n        }\n    }\n}\n\n...\n\n// 初始化 Servlet Context\nfor (WebApplicationInitializer initializer : initializers) {\n    initializer.onStartup(servletContext);\n}\n```\n\n## 通过java code初始化Servlet Context\n\n初始化 *Servlet Context* 的工作其实是委托给了`WebApplicationInitializer`的实现类，那么我们就可以自定义其实现过程，如：\n\n``` java code.4-MyWebAppInitializer.java\npublic class MyWebAppInitializer implements WebApplicationInitializer {\n    \n    @Override\n    public void onStartup(ServletContext container) {\n        XmlWebApplicationContext appContext = new XmlWebApplicationContext();\n        appContext.setConfigLocation(\"/WEB-INF/spring/dispatcher-config.xml\");\n\n        ServletRegistration.Dynamic dispatcher = \n        container.addServlet(\"dispatcher\", new DispatcherServlet(appContext));\n\n        dispatcher.setLoadOnStartup(1);\n        dispatcher.addMapping(\"/\");\n    }\n\n}\n```\n\n这样，我们就完全取代了`web.xml`。但是，还是`/WEB-INF/spring/dispatcher-config.xml`还是XML配置，能否也用 *Java-Code* 替代呢？\n\n答案是肯定的，因为Spring 3.0就支持通过注解`@Configuration`来实现以往通过XML形式配置的工作了：\n\n``` java code.5-MyWebAppInitializer.java\npublic class MyWebAppInitializer implements WebApplicationInitializer {\n\n    @Override\n    public void onStartup(ServletContext container) {\n        // Create the 'root' Spring application context\n        AnnotationConfigWebApplicationContext rootContext =\n        new AnnotationConfigWebApplicationContext();\n        rootContext.register(AppConfig.class);\n\n        // Manage the lifecycle of the root application context\n        container.addListener(new ContextLoaderListener(rootContext));\n\n        // Create the dispatcher servlet's Spring application context\n        AnnotationConfigWebApplicationContext dispatcherContext =\n        new AnnotationConfigWebApplicationContext();\n        dispatcherContext.register(DispatcherConfig.class);\n\n        // Register and map the dispatcher servlet\n        ServletRegistration.Dynamic dispatcher =\n        container.addServlet(\"dispatcher\", new DispatcherServlet(dispatcherContext));\n        dispatcher.setLoadOnStartup(1);\n        dispatcher.addMapping(\"/\");\n    }\n\n }\n```\n\n以上的demo仅为简单实现，那么Spring中又是如何设计的呢？\n\n## Spring中如何设计\n\n分析`code.5`，其实变化的、需要用户具体指定的内容有3块：\n\n1. rootConfig：根容器配置\n2. dispatcherConfig：dispatcher配置\n3. mapping：dispatcherServlet匹配规则\n\n* AbstractContextLoaderInitializer\n\n``` java code.6-AbstractContextLoaderInitializer.java\npublic abstract class AbstractContextLoaderInitializer implements WebApplicationInitializer {\n    \n    @Override\n    public void onStartup(ServletContext servletContext) throws ServletException {\n        registerContextLoaderListener(servletContext);\n    }\n\n    protected void registerContextLoaderListener(ServletContext servletContext) {\n        WebApplicationContext rootAppContext = createRootApplicationContext();\n        \n        // 注册root ApplicationContext\n    }\n\n    protected abstract WebApplicationContext createRootApplicationContext();\n\n    protected ApplicationContextInitializer<?>[] getRootApplicationContextInitializers() {\n        return null;\n    }\n\n}\n```\n\n* AbstractDispatcherServletInitializer\n\n``` java code.7-AbstractDispatcherServletInitializer.java\npublic abstract class AbstractDispatcherServletInitializer extends AbstractContextLoaderInitializer {\n   \n    @Override\n    public void onStartup(ServletContext servletContext) throws ServletException {\n        super.onStartup(servletContext);\n\n        registerDispatcherServlet(servletContext);\n    }\n\n    protected void registerDispatcherServlet(ServletContext servletContext) {\n        WebApplicationContext servletAppContext = createServletApplicationContext();\n\n        ...\n    } \n\n    protected abstract WebApplicationContext createServletApplicationContext();\n\n    protected ApplicationContextInitializer<?>[] getServletApplicationContextInitializers() {\n        return null;\n    }\n\n    protected void customizeRegistration(ServletRegistration.Dynamic registration) {\n    }\n\n    // 用户自定义Url匹配规则\n    protected abstract String[] getServletMappings();\n\n}\n```\n\n* AbstractAnnotationConfigDispatcherServletInitializer\n\n``` java code.8-AbstractAnnotationConfigDispatcherServletInitializer.java\npublic abstract class AbstractAnnotationConfigDispatcherServletInitializer\n        extends AbstractDispatcherServletInitializer {\n\n    @Override\n    protected WebApplicationContext createRootApplicationContext() {\n        // create root ApplicationContext\n    }\n\n    @Override\n    protected WebApplicationContext createServletApplicationContext() {\n        // create servlet ApplicationContext\n    }\n\n    // 指定root ApplicationContext配置文件\n    protected abstract Class<?>[] getRootConfigClasses();\n\n    // 指定servlet ApplicationContext配置文件\n    protected abstract Class<?>[] getServletConfigClasses();\n\n}\n```\n\n## 最终配置\n\n``` java code.9-WebAppInitializer.java\npublic class WebAppInitializer \n    extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n    @Override\n    protected Class<?>[] getRootConfigClasses() {\n        return new Class<?>[] { RootConfig.class };\n    }\n\n    @Override\n    protected Class<?>[] getServletConfigClasses() {\n        return new Class<?>[] { WebConfig.class };\n    }\n\n    @Override\n    protected String[] getServletMappings() {\n        return new String[] { \"/\" };\n    }\n\n}\n```\n\n\n\n\n\n\n\n","slug":"config-diapatcher-servlet-with-servlet3.0","published":1,"updated":"2016-02-08T02:33:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciziguc5k001onps6tas1ys08"},{"title":"Mac下高效地使用Eclipse","date":"2016-01-17T11:04:43.000Z","toc":true,"_content":"\n{% blockquote 孔子，论语·卫灵公 %}\n工欲善其事，必先利其器。\n{% endblockquote %}\n\n[Eclipse](http://www.eclipse.org/)想必是很多同学每天接触的IDE，那么熟练使用eclipse中的快捷键，对每天coding效率的提升将会带来显著的提示。\n\n<!-- more -->\n\n## 文件与工程管理\n`command`+`N`：新建文件/工程\n`command`+`shift`+`R`：快速打开文件，支持`?`、`*`匹配\n`command`+`I`：打开文件属性\n`option`+`I`：打开文件属性\n`command`+`S`：保存当前文件\n`command`+`shift`+`S`：保存所有文件\n`command`+`W`：关闭当前文件\n`command`+`shift`+`W`：关闭所有文件\n`F5`：从本地文件系统刷新资源\n\n## 编辑窗口\n`command`+`shift`+`[`：返回上一个编辑的文件\n`command`+`shift`+`]`：返回下一个编辑的文件\n`control`+`M`：最大化/最小化当前窗口\n`command`+`E`：在打开的文件列表中切换\n`command`+`L`：跳至指定行\n\n## 编辑文件\n`command`+`C`：复制\n`command`+`X`：剪切\n`command`+`V`：黏贴\n`command`+`Z`：取消上步操作\n`command`+`shift`+`Z`：重新执行上步被取消的操作\n`command`+`D`：删除当前这一行\n`option`+`Arrow Up`/`Arrow Down`：向上/向下*移动*当前行或者当前选择的区块\n`command`+`option`+`Arrow Up`/`Arrow Down`：向上/向下*复制*当前行或者当前选择的区块\n`command`+`delete`：删除上一个单词\n`shift`+`enter`：在下一行插入编辑\n`command`+`shift`+`enter`：在上一行插入编辑\n`command`+`shift`+`X`：将选择区块全部变为大写\n`command`+`shift`+`Y`：将选择区块全部变为小写\n\n## 搜索和替换\n`command`+`F`：打开*查找和替换*对话框\n`control`+`H`：在工作区间中搜索（java、task、file等）\n`control`+`J`：输入内容后，*正向*查找字符串\n`command`+`shift`+`J`：输入内容后，*反向*查找字符串\n\n## 代码编辑\n`command`+`I`：修正当前选择区块的缩进\n`command`+`shift`+`F`：格式化代码\n`command`+`/`：注释/取消注释当前行\n`command`+`control`+`/`：添加块注释`/* ... */`\n`command`+`control`+`\\`：取消块注释\n`command`+`option`+`J`：增加元素注释`/** ... *`\n`command`+`1`：快速修复\n`command`+`shift`+`M`：增加`import`\n`command`+`shift`+`O`：组织包`import`\n`option`+`/`：代码提示\n\n## 代码信息\n`command`+`O`：快速查看代码结构\n`command`+`T`：快速查看类型继承\n`command`+`shift`+`T`：搜索查看类\n`F2`：查看类、方法、变量注释说明\n`F3`：跳至类、方法、变量声明处\n`F4`：在类型继承窗口（视图）中打开\n`control`+`option`+`H`：查看类、方法调用层次\n`command`+`shift`+`U`：在当前类中查找表达式出现的地方\n`command`+move over method：打开方法声明或则实现\n\n## 重构\n`control`+`option`+`R`：类、方法、变量等重命名\n`control`+`option`+`V`：方法移动\n`control`+`option`+`M`：抽取方法\n`control`+`option`+`L`：抽取本地变量\n`control`+`option`+`I`：内联收拢变量\n\n## 调试与运行\n`command`+`F11`：Run\n`shift`+`command`+`B`：设置断点\n`F5`：单步进入\n`F6`：下一行\n`F7`：跳出，进行下一步\n`F8`：调至下一个断点\n\n## 参考资料\n\n[Eclipse Shortcuts ](http://www.shortcutworld.com/en/win/Eclipse.html)\n[玩转Eclipse — 快捷键设置及汇总](http://blog.csdn.net/jmyue/article/details/16960199)\n[Working Efficiently with JUnit in Eclipse](http://www.codeaffine.com/2012/11/26/working-efficiently-with-junit-in-eclipse-2/)\n\n","source":"_posts/coding-effectively-with-eclipse-on-mac.md","raw":"---\ntitle: Mac下高效地使用Eclipse\ndate: 2016-01-17 19:04:43\ntags: Eclipse\ncategories:\ntoc: true\n---\n\n{% blockquote 孔子，论语·卫灵公 %}\n工欲善其事，必先利其器。\n{% endblockquote %}\n\n[Eclipse](http://www.eclipse.org/)想必是很多同学每天接触的IDE，那么熟练使用eclipse中的快捷键，对每天coding效率的提升将会带来显著的提示。\n\n<!-- more -->\n\n## 文件与工程管理\n`command`+`N`：新建文件/工程\n`command`+`shift`+`R`：快速打开文件，支持`?`、`*`匹配\n`command`+`I`：打开文件属性\n`option`+`I`：打开文件属性\n`command`+`S`：保存当前文件\n`command`+`shift`+`S`：保存所有文件\n`command`+`W`：关闭当前文件\n`command`+`shift`+`W`：关闭所有文件\n`F5`：从本地文件系统刷新资源\n\n## 编辑窗口\n`command`+`shift`+`[`：返回上一个编辑的文件\n`command`+`shift`+`]`：返回下一个编辑的文件\n`control`+`M`：最大化/最小化当前窗口\n`command`+`E`：在打开的文件列表中切换\n`command`+`L`：跳至指定行\n\n## 编辑文件\n`command`+`C`：复制\n`command`+`X`：剪切\n`command`+`V`：黏贴\n`command`+`Z`：取消上步操作\n`command`+`shift`+`Z`：重新执行上步被取消的操作\n`command`+`D`：删除当前这一行\n`option`+`Arrow Up`/`Arrow Down`：向上/向下*移动*当前行或者当前选择的区块\n`command`+`option`+`Arrow Up`/`Arrow Down`：向上/向下*复制*当前行或者当前选择的区块\n`command`+`delete`：删除上一个单词\n`shift`+`enter`：在下一行插入编辑\n`command`+`shift`+`enter`：在上一行插入编辑\n`command`+`shift`+`X`：将选择区块全部变为大写\n`command`+`shift`+`Y`：将选择区块全部变为小写\n\n## 搜索和替换\n`command`+`F`：打开*查找和替换*对话框\n`control`+`H`：在工作区间中搜索（java、task、file等）\n`control`+`J`：输入内容后，*正向*查找字符串\n`command`+`shift`+`J`：输入内容后，*反向*查找字符串\n\n## 代码编辑\n`command`+`I`：修正当前选择区块的缩进\n`command`+`shift`+`F`：格式化代码\n`command`+`/`：注释/取消注释当前行\n`command`+`control`+`/`：添加块注释`/* ... */`\n`command`+`control`+`\\`：取消块注释\n`command`+`option`+`J`：增加元素注释`/** ... *`\n`command`+`1`：快速修复\n`command`+`shift`+`M`：增加`import`\n`command`+`shift`+`O`：组织包`import`\n`option`+`/`：代码提示\n\n## 代码信息\n`command`+`O`：快速查看代码结构\n`command`+`T`：快速查看类型继承\n`command`+`shift`+`T`：搜索查看类\n`F2`：查看类、方法、变量注释说明\n`F3`：跳至类、方法、变量声明处\n`F4`：在类型继承窗口（视图）中打开\n`control`+`option`+`H`：查看类、方法调用层次\n`command`+`shift`+`U`：在当前类中查找表达式出现的地方\n`command`+move over method：打开方法声明或则实现\n\n## 重构\n`control`+`option`+`R`：类、方法、变量等重命名\n`control`+`option`+`V`：方法移动\n`control`+`option`+`M`：抽取方法\n`control`+`option`+`L`：抽取本地变量\n`control`+`option`+`I`：内联收拢变量\n\n## 调试与运行\n`command`+`F11`：Run\n`shift`+`command`+`B`：设置断点\n`F5`：单步进入\n`F6`：下一行\n`F7`：跳出，进行下一步\n`F8`：调至下一个断点\n\n## 参考资料\n\n[Eclipse Shortcuts ](http://www.shortcutworld.com/en/win/Eclipse.html)\n[玩转Eclipse — 快捷键设置及汇总](http://blog.csdn.net/jmyue/article/details/16960199)\n[Working Efficiently with JUnit in Eclipse](http://www.codeaffine.com/2012/11/26/working-efficiently-with-junit-in-eclipse-2/)\n\n","slug":"coding-effectively-with-eclipse-on-mac","published":1,"updated":"2016-01-24T13:14:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciziguc5p001snps6zxxc61tm"},{"title":"Java中的输入/输出流","date":"2016-02-15T02:46:17.000Z","toc":true,"_content":"流（Stream）是java中输入和输出经常涉及也是最简单的概念。Java中存在各种各样的流，字符流、字节流、缓存流、基本数据流、对象流等。Java持久化中谈及的序列化与反序列化同样离不开流（将整个对象写入流中，并可以从流中获取整个对象）。\n\n<!-- more -->\n\n## 字节流（InputSteam）\n常见的有`FileInputSteam`，主要用于读取原生的字节流，如图片。如果想要读取关于字符的字节流可以使用`FileReader`。\n\n## 字符流（Reader）\n\n### `Reader`\n所有的字符流都继承于Reader，它包含一个同步锁`lock`，默认是将自己作为一锁。\n``` java\npublic abstract class Reader implements Readable, Closeable {\n    \n    // 用于同步流\n    protected Object lock;\n\n    protected Reader() {\n        this.lock = this;\n    }\n\n    protected Reader(Object lock) {\n        if (lock == null) {\n            throw new NullPointerException();\n        }\n        this.lock = lock;\n    }\n}\n```\n\n### `InputStreamReader`\nInputStreamReader是从字节流到字符流的桥连接。它读取字节并将其编码成相应[字符集](https://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html)的字符。字符集可以用指定的名称、或具体的字符集对象或者系统默认的字符集。\n\n其实现是通过`StreamDecoder`的forInputStreamReader方法进行编码。`read()`方法同样委托给`StreamDecoder`。\n\n### `FileReader`\n继承于In继承putStreamReader，其实现是通过`FileInputSteam`创建字节流然后通过桥连接构造`StreamDecoder`，其读方法均由`InputStreamReader`实现（委托给`StreamDecoder`）。\n\n``` java\npublic class InputStreamReader extends Reader {\n\n    public InputStreamReader(InputStream in) {\n        super(in);\n        try {\n            sd = StreamDecoder.forInputStreamReader(in, this, (String)null); // check lock object\n        } catch (UnsupportedEncodingException e) {\n            // The default encoding should always be available\n            throw new Error(e);\n        }\n    }\n\n    public int read() throws IOException {\n        return sd.read();\n    }\n}\n\npublic class FileReader extends InputStreamReader {\n\n    public FileReader(String fileName) throws FileNotFoundException {\n        super(new FileInputStream(fileName));\n    }\n}\n```\n\n## 缓冲流（Buffered Stream）\n对于无缓冲的I/O操作，每次写或者读请求都会直接作用于操作系统，如硬盘访问、网络访问等代价非常昂贵的操作。 缓冲流的引入就是为了提升常规I/O操作的效率。\n\n缓冲输入流是从一块缓冲的内容中读取数据，只有当缓冲区没有数据时才会调用操作系统的API获取一整块的数据，然后放入缓冲区以供程序读取。同样，缓冲输出流每次向缓冲区写入数据，只有当缓冲区被写满后才会调用操作系统的API将数据真正写入目标位置。\n\n* [BufferedInputStream](https://docs.oracle.com/javase/8/docs/api/java/io/BufferedInputStream.html)、[BufferedOutputStream](https://docs.oracle.com/javase/8/docs/api/java/io/BufferedOutputStream.html)：用于创建缓冲的字节流\n** 分别继承于`FilterInputStream`和`FilterOutputStream`，本身字节流成员。\n** 必须使用字节流构造，并可以指定缓存区大小。\n\n* [BufferedReader](https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html)、[BufferedWriter](https://docs.oracle.com/javase/8/docs/api/java/io/BufferedWriter.html)：用于创建缓冲的字符流\n\n\n## Scanning\n[Scanner](https://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html)，一个文本扫描工具，使用正则表达式解析基本数据类型和`String`类型。`Scanner`可以使用分隔符将输入数据分割成诸多片段，默认的分隔符为*whitespace*（参见[Character.isWhitespace](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isWhitespace-char-))。可以使用不同`next`方法将这些片段转化成不同的数据类型。\n\n### 构成方法：\n* 字符流：`Readable`接口。比如继承于`Reader`的所有类，`FileReader`等。\n* 字节流：`InputStream`，支持自定义charset。其实现是将*字节流转化为字符流*，使用字符流构造。\n    ``` java\n    public Scanner(InputStream source) {\n        this(new InputStreamReader(source), WHITESPACE_PATTERN);\n    }\n    ```\n* 字节可读管道：`ReadableByteChannel`，比如对应文件的管道`FileChannel`。\n* 文件：`File`，支持自定义charset。其实现是构造`FileInputStream`，获取文件管道`FileChannel`，然后使用字节可读管道构造。\n* 文件路径：`Path`，支持自定义charset。其实现是获取文件的字节流，然后构造字符流。\n* 字符串：`String`。其实现是构造`StringReader`，然后构造字符流。\n\n### 主要方法\n* `hasNext、next`：不仅支持基础类型，还支持`BigDecimal`、`BigInteger`以及`nextLine`。这两个方法都会阻塞（block）等待输入。\n* `useDelimiter`：自定义分隔符。\n* `reset`：重置分隔符为*whitespace*。\n\n## [PrintStream](https://docs.oracle.com/javase/8/docs/api/java/io/PrintStream.html)\n* 异常：不会抛`IOException`，但是内部会有相应的标记，可以通过`checkError`来检查。\n* 自动flush：当写入一个字节数组、或者调用`println`方法、或者写入换行符`\\n`时会自动flush。\n\n*注意*： 通过*PrintStream*打印的字符均会根据平台默认的字符编码被转成字节。\n\n### 构造方法：\n支持字节流、文件、文件名进行构造。使用字节流构造时，可自定义是否自动flush，默认为`false`。使用文件名或文件时，不可自定义，默认也为`false`。\n\n相应的，用于处理字符的类为[PrintWriter](https://docs.oracle.com/javase/8/docs/api/java/io/PrintWriter.html)。一般情况下直接使用`PrintWriter`。\n\n### 主要方法\n* `format(String format, Object... args)`\n  类似C语言，格式化输入源数据。具体语法参考[Formatter](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax)。\n\n## [PrintWriter](https://docs.oracle.com/javase/8/docs/api/java/io/PrintWriter.html)\n跟`PrintStream`类似，也是用于格式化输出。并且实现了所有`PrintStream`的方法。但自动flush时有点不同：不再直接检查被写入的是否为换行符`\\n`，而是检查是否为当前平台的换行符。\n\n支持字节流（OutStream）、字符流（Writer）、文件名、文件（File）进行构造。特别的，除了字节流构造意外，其他实现均为会转化成缓存字符流（`BufferedWriter`）。\n\n## 标准流\n标准输入流：`System.in`。\n标准输出流：`System.out`，`System.error`。\n\n因为历史原因，这些标准流均为*字节流*，而非字符流。需要转化时可以通过`InputStreamReader`进行转化，如：\n\n``` java\nInputStreamReader cin = new InputStreamReader(System.in) \n```\n\n## Console\n`Console`是更强大的标准流，同时提供了输入流和输出流，并且是字符流。还有一个安全特性是针对密码输入时设计。\n\n* 无public构造函数：使用时，通过System获取，`System.console()`。\n* readPassword：返回一个字符（char）数组，不再使用时可以将其重写置空，从内存中删除。\n\n## 数据流（DataStream）\n对输入/输出字节流的包装，方便程序中输入/输出基本类型以及String。\n\n因为DataStream操作的是字节流，所以在使用时可以使用缓存流`BufferedInputStream`和`BufferedOutputStream`。\n\n\n与其他流不同的地方是检测输入结束的条件，它是通过catch`EOFException`，而不是检测返回值，参见一下具体实现：\n\n``` java\npublic final byte readByte() throws IOException {\n    int ch = in.read();\n    if (ch < 0)\n        throw new EOFException();\n    return (byte)(ch);\n}\n```\n\n## 对象流（Object Stream）\n对象流包括`ObjectInputSteam`和`ObjectOutputStream`，实现的接口分别为`ObjectInput`和`ObjectOutput`（继承于数据流接口`DataInput`）。这也意味着在数据流中所有基本数据类型相关的方法，在对象流中都有相应的实现。\n\n`ObjectInputSteam`用来反序列化那些用`ObjectOutputStream`序列化的基本数据类型和对象。而`ObjectOutputStream`则是一种将对象持久化的方法。\n\n### 复杂对象的输入流与输出流\n* 当一个对象引用了其他对象时，其所有引用都会被写入流中。\n* 当多个对象引用了同一个对象时，被引用的对象在流中只会存在一份。\n\n\n\n\n","source":"_posts/basic-IO-in-java.md","raw":"---\ntitle: Java中的输入/输出流\ndate: 2016-02-15 10:46:17\ntags: IO\ncategories: Java-Core\ntoc: true\n---\n流（Stream）是java中输入和输出经常涉及也是最简单的概念。Java中存在各种各样的流，字符流、字节流、缓存流、基本数据流、对象流等。Java持久化中谈及的序列化与反序列化同样离不开流（将整个对象写入流中，并可以从流中获取整个对象）。\n\n<!-- more -->\n\n## 字节流（InputSteam）\n常见的有`FileInputSteam`，主要用于读取原生的字节流，如图片。如果想要读取关于字符的字节流可以使用`FileReader`。\n\n## 字符流（Reader）\n\n### `Reader`\n所有的字符流都继承于Reader，它包含一个同步锁`lock`，默认是将自己作为一锁。\n``` java\npublic abstract class Reader implements Readable, Closeable {\n    \n    // 用于同步流\n    protected Object lock;\n\n    protected Reader() {\n        this.lock = this;\n    }\n\n    protected Reader(Object lock) {\n        if (lock == null) {\n            throw new NullPointerException();\n        }\n        this.lock = lock;\n    }\n}\n```\n\n### `InputStreamReader`\nInputStreamReader是从字节流到字符流的桥连接。它读取字节并将其编码成相应[字符集](https://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html)的字符。字符集可以用指定的名称、或具体的字符集对象或者系统默认的字符集。\n\n其实现是通过`StreamDecoder`的forInputStreamReader方法进行编码。`read()`方法同样委托给`StreamDecoder`。\n\n### `FileReader`\n继承于In继承putStreamReader，其实现是通过`FileInputSteam`创建字节流然后通过桥连接构造`StreamDecoder`，其读方法均由`InputStreamReader`实现（委托给`StreamDecoder`）。\n\n``` java\npublic class InputStreamReader extends Reader {\n\n    public InputStreamReader(InputStream in) {\n        super(in);\n        try {\n            sd = StreamDecoder.forInputStreamReader(in, this, (String)null); // check lock object\n        } catch (UnsupportedEncodingException e) {\n            // The default encoding should always be available\n            throw new Error(e);\n        }\n    }\n\n    public int read() throws IOException {\n        return sd.read();\n    }\n}\n\npublic class FileReader extends InputStreamReader {\n\n    public FileReader(String fileName) throws FileNotFoundException {\n        super(new FileInputStream(fileName));\n    }\n}\n```\n\n## 缓冲流（Buffered Stream）\n对于无缓冲的I/O操作，每次写或者读请求都会直接作用于操作系统，如硬盘访问、网络访问等代价非常昂贵的操作。 缓冲流的引入就是为了提升常规I/O操作的效率。\n\n缓冲输入流是从一块缓冲的内容中读取数据，只有当缓冲区没有数据时才会调用操作系统的API获取一整块的数据，然后放入缓冲区以供程序读取。同样，缓冲输出流每次向缓冲区写入数据，只有当缓冲区被写满后才会调用操作系统的API将数据真正写入目标位置。\n\n* [BufferedInputStream](https://docs.oracle.com/javase/8/docs/api/java/io/BufferedInputStream.html)、[BufferedOutputStream](https://docs.oracle.com/javase/8/docs/api/java/io/BufferedOutputStream.html)：用于创建缓冲的字节流\n** 分别继承于`FilterInputStream`和`FilterOutputStream`，本身字节流成员。\n** 必须使用字节流构造，并可以指定缓存区大小。\n\n* [BufferedReader](https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html)、[BufferedWriter](https://docs.oracle.com/javase/8/docs/api/java/io/BufferedWriter.html)：用于创建缓冲的字符流\n\n\n## Scanning\n[Scanner](https://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html)，一个文本扫描工具，使用正则表达式解析基本数据类型和`String`类型。`Scanner`可以使用分隔符将输入数据分割成诸多片段，默认的分隔符为*whitespace*（参见[Character.isWhitespace](https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isWhitespace-char-))。可以使用不同`next`方法将这些片段转化成不同的数据类型。\n\n### 构成方法：\n* 字符流：`Readable`接口。比如继承于`Reader`的所有类，`FileReader`等。\n* 字节流：`InputStream`，支持自定义charset。其实现是将*字节流转化为字符流*，使用字符流构造。\n    ``` java\n    public Scanner(InputStream source) {\n        this(new InputStreamReader(source), WHITESPACE_PATTERN);\n    }\n    ```\n* 字节可读管道：`ReadableByteChannel`，比如对应文件的管道`FileChannel`。\n* 文件：`File`，支持自定义charset。其实现是构造`FileInputStream`，获取文件管道`FileChannel`，然后使用字节可读管道构造。\n* 文件路径：`Path`，支持自定义charset。其实现是获取文件的字节流，然后构造字符流。\n* 字符串：`String`。其实现是构造`StringReader`，然后构造字符流。\n\n### 主要方法\n* `hasNext、next`：不仅支持基础类型，还支持`BigDecimal`、`BigInteger`以及`nextLine`。这两个方法都会阻塞（block）等待输入。\n* `useDelimiter`：自定义分隔符。\n* `reset`：重置分隔符为*whitespace*。\n\n## [PrintStream](https://docs.oracle.com/javase/8/docs/api/java/io/PrintStream.html)\n* 异常：不会抛`IOException`，但是内部会有相应的标记，可以通过`checkError`来检查。\n* 自动flush：当写入一个字节数组、或者调用`println`方法、或者写入换行符`\\n`时会自动flush。\n\n*注意*： 通过*PrintStream*打印的字符均会根据平台默认的字符编码被转成字节。\n\n### 构造方法：\n支持字节流、文件、文件名进行构造。使用字节流构造时，可自定义是否自动flush，默认为`false`。使用文件名或文件时，不可自定义，默认也为`false`。\n\n相应的，用于处理字符的类为[PrintWriter](https://docs.oracle.com/javase/8/docs/api/java/io/PrintWriter.html)。一般情况下直接使用`PrintWriter`。\n\n### 主要方法\n* `format(String format, Object... args)`\n  类似C语言，格式化输入源数据。具体语法参考[Formatter](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax)。\n\n## [PrintWriter](https://docs.oracle.com/javase/8/docs/api/java/io/PrintWriter.html)\n跟`PrintStream`类似，也是用于格式化输出。并且实现了所有`PrintStream`的方法。但自动flush时有点不同：不再直接检查被写入的是否为换行符`\\n`，而是检查是否为当前平台的换行符。\n\n支持字节流（OutStream）、字符流（Writer）、文件名、文件（File）进行构造。特别的，除了字节流构造意外，其他实现均为会转化成缓存字符流（`BufferedWriter`）。\n\n## 标准流\n标准输入流：`System.in`。\n标准输出流：`System.out`，`System.error`。\n\n因为历史原因，这些标准流均为*字节流*，而非字符流。需要转化时可以通过`InputStreamReader`进行转化，如：\n\n``` java\nInputStreamReader cin = new InputStreamReader(System.in) \n```\n\n## Console\n`Console`是更强大的标准流，同时提供了输入流和输出流，并且是字符流。还有一个安全特性是针对密码输入时设计。\n\n* 无public构造函数：使用时，通过System获取，`System.console()`。\n* readPassword：返回一个字符（char）数组，不再使用时可以将其重写置空，从内存中删除。\n\n## 数据流（DataStream）\n对输入/输出字节流的包装，方便程序中输入/输出基本类型以及String。\n\n因为DataStream操作的是字节流，所以在使用时可以使用缓存流`BufferedInputStream`和`BufferedOutputStream`。\n\n\n与其他流不同的地方是检测输入结束的条件，它是通过catch`EOFException`，而不是检测返回值，参见一下具体实现：\n\n``` java\npublic final byte readByte() throws IOException {\n    int ch = in.read();\n    if (ch < 0)\n        throw new EOFException();\n    return (byte)(ch);\n}\n```\n\n## 对象流（Object Stream）\n对象流包括`ObjectInputSteam`和`ObjectOutputStream`，实现的接口分别为`ObjectInput`和`ObjectOutput`（继承于数据流接口`DataInput`）。这也意味着在数据流中所有基本数据类型相关的方法，在对象流中都有相应的实现。\n\n`ObjectInputSteam`用来反序列化那些用`ObjectOutputStream`序列化的基本数据类型和对象。而`ObjectOutputStream`则是一种将对象持久化的方法。\n\n### 复杂对象的输入流与输出流\n* 当一个对象引用了其他对象时，其所有引用都会被写入流中。\n* 当多个对象引用了同一个对象时，被引用的对象在流中只会存在一份。\n\n\n\n\n","slug":"basic-IO-in-java","published":1,"updated":"2016-03-14T15:40:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciziguc5s001vnps6c69316zk"},{"title":"Java中的多线程（一）：线程的基本概念和使用","date":"2016-03-14T16:03:52.000Z","toc":true,"_content":"日常生活中常常会遇到并发场景，比如你浏览网页的同时，可能同时会受到QQ好友的消息。接下来的一些列文章将介绍如何在Java语言中进行多线程的编程。\n\n本文介绍线程的一些基本概念和操作，如什么是线程，如何创建以及线程的睡眠与中断、join。\n\n<!-- more -->\n\n## 什么是进程，什么是线程\n线程有时候被叫做轻量级的进程，创建一个线程的代销远小于一个进程。线程是进程中最小的运行单元，一个进程中至少包含一个线程。线程间可以共享资源。\n\n而进程通常包含一个独立的运行环境，每个进程有自己的内存空间。\n\n## 线程（Thread）\nJava中每一个线程都是一个[Thread](https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html)的实例。\n\n### 线程的创建\n#### 实现Runable\n``` java\npublic class ThreadTest {\n\n    class HelloRunable implements Runnable {\n\n        @Override\n        public void run() {\n            System.out.println(\"Hello Multithread!\");\n        }\n    }\n    \n    @Test\n    public void testCreateThread() {\n        new Thread(new HelloRunable()).start();\n    }\n\n}\n```\nor 使用Lambda表达式\n``` java\nnew Thread(() -> System.out.println(\"Hello Multithread!\")).start();\n```\n\n#### 继承Thread\n`Thread`实现了`Runable`接口，所以可以覆盖它的run()方法来创建一个线程。run方法的实现为：\n``` java\npublic class Thread implements Runnable {\n    private Runnable target;\n\n    public void run() {\n        if (target != null) {\n            target.run();\n        }\n    }\n}\n```\n``` java\npublic void testCreateThread() {\n    new Thread() {\n\n        @Override\n        public void run() {\n            System.out.println(\"Hello Multithread!\");\n        }\n    }.start();\n}\n```\n\n#### start与run\nstart方法有jvm实现，创建一个线程并调用run方法。而run方法只不过是Thread的一个普通方法，单独调用时也会普通的调用，仍然在主线程线程中。\n\n#### 如何选择创建一个线程\n建议通过实现`Runable`接口：因为Java语言是不支持多继承的，如果是通过继承`Thread`来实现多线程，那么灵活性也将受到限制。\n\n### 线程睡眠\n``` java\npublic void testThreadSleep() throws InterruptedException {\n    Thread.sleep(1000);\n    \n    System.out.println(\"Bingo...\");\n}\n```\n\n### 线程中断\nThread中的很多方法都可能抛出`InterruptedException`异常，当然也可以通过`interrupt`方法来中断某个线程，那么*支持线程中断*就很重要了。\n\n#### 支持线程中断\n两种方式：捕捉异常 或 查询中断状态\n\n#### 线程的中断状态\n线程的中断机制是通过内部的标记来实现，也称中断状态。\n\n中断线程可以通过线程的`interrupt`方法来中断当前线程。\n\n查询线程的中断状态同样可以`Thread.interrupt`静态方法，也可以通过Thread类的`interrupted`方法来查询。不过这里有个需要注意的地方：\n*前者会清空中断状态，而后者不会*。\n\n### joins\nThead的`join`方法会让一个线程等待另一个线程完成。当在一个线程中调用另一个线程的`join`方法后，当前线程会停止执行后面的语句，直到另外一个线程完成。\n\n``` java\npublic void testInterrupt() {\n    Thread interrupt = new Thread(new Runnable() {\n        \n        @Override\n        public void run() {\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                return;\n            }\n            System.out.println(\"sub over\");\n        }\n    });\n\n    interrupt.start();\n    // interrupt.join();\n\n    System.out.println(\"main over\");\n }\n```\n\n运行上面这个demo，你在控制台将看不到打印\"sub over\"：因为主线程没有睡眠，会比子线程先运行结束。除非将注释的代码放开。\n\n","source":"_posts/base-in-java-concurrency.md","raw":"---\ntitle: Java中的多线程（一）：线程的基本概念和使用\ndate: 2016-03-15 00:03:52\ntags:\n- Concurrency\n- Thread\ncategories: Java-Core\ntoc: true\n---\n日常生活中常常会遇到并发场景，比如你浏览网页的同时，可能同时会受到QQ好友的消息。接下来的一些列文章将介绍如何在Java语言中进行多线程的编程。\n\n本文介绍线程的一些基本概念和操作，如什么是线程，如何创建以及线程的睡眠与中断、join。\n\n<!-- more -->\n\n## 什么是进程，什么是线程\n线程有时候被叫做轻量级的进程，创建一个线程的代销远小于一个进程。线程是进程中最小的运行单元，一个进程中至少包含一个线程。线程间可以共享资源。\n\n而进程通常包含一个独立的运行环境，每个进程有自己的内存空间。\n\n## 线程（Thread）\nJava中每一个线程都是一个[Thread](https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html)的实例。\n\n### 线程的创建\n#### 实现Runable\n``` java\npublic class ThreadTest {\n\n    class HelloRunable implements Runnable {\n\n        @Override\n        public void run() {\n            System.out.println(\"Hello Multithread!\");\n        }\n    }\n    \n    @Test\n    public void testCreateThread() {\n        new Thread(new HelloRunable()).start();\n    }\n\n}\n```\nor 使用Lambda表达式\n``` java\nnew Thread(() -> System.out.println(\"Hello Multithread!\")).start();\n```\n\n#### 继承Thread\n`Thread`实现了`Runable`接口，所以可以覆盖它的run()方法来创建一个线程。run方法的实现为：\n``` java\npublic class Thread implements Runnable {\n    private Runnable target;\n\n    public void run() {\n        if (target != null) {\n            target.run();\n        }\n    }\n}\n```\n``` java\npublic void testCreateThread() {\n    new Thread() {\n\n        @Override\n        public void run() {\n            System.out.println(\"Hello Multithread!\");\n        }\n    }.start();\n}\n```\n\n#### start与run\nstart方法有jvm实现，创建一个线程并调用run方法。而run方法只不过是Thread的一个普通方法，单独调用时也会普通的调用，仍然在主线程线程中。\n\n#### 如何选择创建一个线程\n建议通过实现`Runable`接口：因为Java语言是不支持多继承的，如果是通过继承`Thread`来实现多线程，那么灵活性也将受到限制。\n\n### 线程睡眠\n``` java\npublic void testThreadSleep() throws InterruptedException {\n    Thread.sleep(1000);\n    \n    System.out.println(\"Bingo...\");\n}\n```\n\n### 线程中断\nThread中的很多方法都可能抛出`InterruptedException`异常，当然也可以通过`interrupt`方法来中断某个线程，那么*支持线程中断*就很重要了。\n\n#### 支持线程中断\n两种方式：捕捉异常 或 查询中断状态\n\n#### 线程的中断状态\n线程的中断机制是通过内部的标记来实现，也称中断状态。\n\n中断线程可以通过线程的`interrupt`方法来中断当前线程。\n\n查询线程的中断状态同样可以`Thread.interrupt`静态方法，也可以通过Thread类的`interrupted`方法来查询。不过这里有个需要注意的地方：\n*前者会清空中断状态，而后者不会*。\n\n### joins\nThead的`join`方法会让一个线程等待另一个线程完成。当在一个线程中调用另一个线程的`join`方法后，当前线程会停止执行后面的语句，直到另外一个线程完成。\n\n``` java\npublic void testInterrupt() {\n    Thread interrupt = new Thread(new Runnable() {\n        \n        @Override\n        public void run() {\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                return;\n            }\n            System.out.println(\"sub over\");\n        }\n    });\n\n    interrupt.start();\n    // interrupt.join();\n\n    System.out.println(\"main over\");\n }\n```\n\n运行上面这个demo，你在控制台将看不到打印\"sub over\"：因为主线程没有睡眠，会比子线程先运行结束。除非将注释的代码放开。\n\n","slug":"base-in-java-concurrency","published":1,"updated":"2016-04-30T06:44:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciziguc5v001znps6z43b5am6"},{"title":"Java8中的Stream","date":"2016-02-06T06:41:16.000Z","_content":"\nJava8中为集合类`Collection`引入了新的特性：流`Stream`，使得基于集合的操作更加简洁、直观。为了更好的理解`Stream`，需要对Lambda表达式和方法引用有一定的认知，参见前一篇Note：[Java8中的Lambda表达式](http://www.xiaoyuxee.com/2016/02/05/lambda-in-java8/)。\n\n<!-- more -->\n\n## 引子\n\n当我们遍历一个集合并进行打印时：\n\n``` java\nfor (Person p : persons) {\n    System.out.println(p.getName());\n}\n```\n\n使用`Stream`、Lambda表达式后：\n\n``` java\npersons\n    .stream()\n    .forEach(p -> System.out.println(p.getName()));\n```\n\n## 流`Stream`\n\n流`Stream`指的是一系列元素，但不像集合`Collection`，它不是用来存储元素的数据结构，而是通过管道（pipeline）而携带元素。通过集合中的`java.util.Collection.stream()`方法可以获得。\n\n## 管道pipeline\n\n管道（pipeline）指的是一系列的集成操作。如：\n\n``` java\npersons\n    .stream()\n    .filter(p -> p.getAge() >= 18)\n    .forEach(p -> System.out.println(p.getName()));\n```\n\n管道一般由以下几部分组成：\n\n* 来源：可能是集合、数组、生成函数或者I/O管道。\n* 中间操作：比如过滤器`filter`，产生一个新的管道（pipeline）\n* 终止操作：比如`forEach`。\n\n比如，统计*年龄≥18岁的person的平均年龄*：\n\n``` java\npersons\n    .stream()\n    .filter(p -> p.getAge() >= 18)\n    .mapToInt(Person::getAge)\n    .average()\n    .getAsDouble();\n```\n\n上例中，`mapToInt`操作产生了一个类型为`IntStream`的新流，包换所有*年龄≥18岁的person的年龄流*。\n\n`average`操作将计算`IntStream`中所有元素的平均值。JDK中提供了很多类似`average`终止操作，组合流中内容并返回一个值。这类操作叫做[reduction](http://docs.oracle.com/javase/tutorial/collections/streams/reduction.html)。\n\n## `Reduction`\n\n类似于`average`，统计流Stream中内容而返回一个值，还有`sum`、`min`、`max`、`count`。此外，JDK还提供返回集合的终止操作。\n\n当然，JDK还提供了更加通用的`reduce`和`collect`方法。\n\n### `reduce`方法\n\n例如，我们要统计*年龄≥18岁的person的年龄之和*：\n\n``` java\npersons\n    .stream()\n    .filter(p -> p.getAge() >= 18)\n    .mapToInt(Person::getAge)\n    .sum();\n```\n\n这里用到了`sum`终结操作，计算所有`IntStream`中内容之和。如果使用`reduce`则可以这么写：\n\n``` java\npersons\n    .stream()\n    .filter(p -> p.getAge() >= 18)\n    .mapToInt(Person::getAge)\n    .reduce(0, Math::addExact);\n```\n\n查询`sum`源码可以发现，其实也是如此：\n\n``` java\npublic final int sum() {\n    return reduce(0, Integer::sum);\n}\n```\n\n关于`reduce`有三个方法：\n\n#### `Optional<T> reduce(BinaryOperator<T> accumulator)` 用于寻找最大值、最小值等\n\n#### `T reduce(T identity, BinaryOperator<T> accumulator)` 适合于有累加行为\n\n`reduce`操作包含两个参数：\n\n* 标识：reduce操作的初始化值以及默认值（如果流中没有元素）\n* 累加器：累加器包含两个参数：requce操作的*部分结果和下一个流中内容的值*，然后返回一个新的局部结果。\n\n`reduce`操作时，累加器每次都返回一个新的值。假如你的操作是返回一个更加复杂的对象，比如集合，那么就需要为你的程序担忧了。因为其效率是非常低的，正确的做法是*更新已经存在的集合*。这就是`collect`方法。\n\n### `collect`方法\n\n假如你要收集所有*年龄≥18岁的person的人名*：\n\n``` java\npersons\n    .stream()\n    .filter(p -> p.getAge() >= 18)\n    .map(Person::getName)\n    .collect(ArrayList::new, ArrayList::add, ArrayList::addAll);\n```\n\n`collect`有两个方法：\n\n####  `R collect (Supplier<R>, BiConsumer<R, ? super T>, BiConsumer<R, R>)`\n\n* 第一个参数Supplier：用于初始化返回结果\n* 第二个参数BiConsumer： 用于操作*部分结果与下一个流内容*\n* 第二个参数BiConsumer： 用于*合并操作*\n\n#### `<R, A> R collect(Collector<? super T, A, R> collector)`\n\n`Collector`将上述*初始化*、*部分接口与下一个流内容操作*、*合并*封装了起来，并且在`java.util.stream.Collectors`中提供了一些常用的collector，如`toList`、`toSet`等。\n\n上述收集所有*年龄≥18岁的person的人名*的例子可以改写为：\n\n\n``` java\npersons\n    .stream()\n    .filter(p -> p.getAge() >= 18)\n    .map(Person::getName)\n    .collect(Collectors.toList()));\n```\n\n`Collectors.groupingBy(classifier)`用于分组，返回一个key为`classifier`分类的标准，value为ArrayList的Map。\n\n``` java\npersons\n    .stream()\n    .collect(Collectors.groupingBy(Person::getGender)));\n```\n\n如果要将persons按性别分组，返回其name：\n\n``` java\npersons\n    .stream()\n    .collect(Collectors.groupingBy(\n            Person::getGender,\n            Collectors.mapping(Person::getName, Collectors.toList()))));\n```\n\n如果要将persons按性别分组，返回每组的年龄总数/年龄最大值/平均年龄：\n\n``` java\n// 年龄和\npersons\n    .stream()\n    .collect(Collectors.groupingBy(\n            Person::getGender,\n            Collectors.mapping(\n                    Person::getAge, \n                    Collectors.reducing(0, Math::addExact)))));\n// 年龄和\npersons\n    .stream()\n    .collect(Collectors.groupingBy(\n            Person::getGender,\n            Collectors.reducing(0, Person::getAge, Math::addExact))));\n\n// 年龄最大值\npersons\n    .stream()\n    .collect(Collectors.groupingBy(\n            Person::getGender,\n            Collectors.mapping(\n                    Person::getAge, \n                    Collectors.reducing(Math::max)))));\n\n// 年龄平均值\npersons\n    .stream()\n    .collect(Collectors.groupingBy(\n            Person::getGender,\n            Collectors.averagingInt(Person::getAge))));\n\n\n```\n\n## 参考\n[http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html](http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html)\n\n","source":"_posts/aggregate-operation-in-java8.md","raw":"---\ntitle: Java8中的Stream\ndate: 2016-02-06 14:41:16\ntags:\n- Aggregate-Operation\n- Stream\n- Java8\ncategories: Java-Core\n---\n\nJava8中为集合类`Collection`引入了新的特性：流`Stream`，使得基于集合的操作更加简洁、直观。为了更好的理解`Stream`，需要对Lambda表达式和方法引用有一定的认知，参见前一篇Note：[Java8中的Lambda表达式](http://www.xiaoyuxee.com/2016/02/05/lambda-in-java8/)。\n\n<!-- more -->\n\n## 引子\n\n当我们遍历一个集合并进行打印时：\n\n``` java\nfor (Person p : persons) {\n    System.out.println(p.getName());\n}\n```\n\n使用`Stream`、Lambda表达式后：\n\n``` java\npersons\n    .stream()\n    .forEach(p -> System.out.println(p.getName()));\n```\n\n## 流`Stream`\n\n流`Stream`指的是一系列元素，但不像集合`Collection`，它不是用来存储元素的数据结构，而是通过管道（pipeline）而携带元素。通过集合中的`java.util.Collection.stream()`方法可以获得。\n\n## 管道pipeline\n\n管道（pipeline）指的是一系列的集成操作。如：\n\n``` java\npersons\n    .stream()\n    .filter(p -> p.getAge() >= 18)\n    .forEach(p -> System.out.println(p.getName()));\n```\n\n管道一般由以下几部分组成：\n\n* 来源：可能是集合、数组、生成函数或者I/O管道。\n* 中间操作：比如过滤器`filter`，产生一个新的管道（pipeline）\n* 终止操作：比如`forEach`。\n\n比如，统计*年龄≥18岁的person的平均年龄*：\n\n``` java\npersons\n    .stream()\n    .filter(p -> p.getAge() >= 18)\n    .mapToInt(Person::getAge)\n    .average()\n    .getAsDouble();\n```\n\n上例中，`mapToInt`操作产生了一个类型为`IntStream`的新流，包换所有*年龄≥18岁的person的年龄流*。\n\n`average`操作将计算`IntStream`中所有元素的平均值。JDK中提供了很多类似`average`终止操作，组合流中内容并返回一个值。这类操作叫做[reduction](http://docs.oracle.com/javase/tutorial/collections/streams/reduction.html)。\n\n## `Reduction`\n\n类似于`average`，统计流Stream中内容而返回一个值，还有`sum`、`min`、`max`、`count`。此外，JDK还提供返回集合的终止操作。\n\n当然，JDK还提供了更加通用的`reduce`和`collect`方法。\n\n### `reduce`方法\n\n例如，我们要统计*年龄≥18岁的person的年龄之和*：\n\n``` java\npersons\n    .stream()\n    .filter(p -> p.getAge() >= 18)\n    .mapToInt(Person::getAge)\n    .sum();\n```\n\n这里用到了`sum`终结操作，计算所有`IntStream`中内容之和。如果使用`reduce`则可以这么写：\n\n``` java\npersons\n    .stream()\n    .filter(p -> p.getAge() >= 18)\n    .mapToInt(Person::getAge)\n    .reduce(0, Math::addExact);\n```\n\n查询`sum`源码可以发现，其实也是如此：\n\n``` java\npublic final int sum() {\n    return reduce(0, Integer::sum);\n}\n```\n\n关于`reduce`有三个方法：\n\n#### `Optional<T> reduce(BinaryOperator<T> accumulator)` 用于寻找最大值、最小值等\n\n#### `T reduce(T identity, BinaryOperator<T> accumulator)` 适合于有累加行为\n\n`reduce`操作包含两个参数：\n\n* 标识：reduce操作的初始化值以及默认值（如果流中没有元素）\n* 累加器：累加器包含两个参数：requce操作的*部分结果和下一个流中内容的值*，然后返回一个新的局部结果。\n\n`reduce`操作时，累加器每次都返回一个新的值。假如你的操作是返回一个更加复杂的对象，比如集合，那么就需要为你的程序担忧了。因为其效率是非常低的，正确的做法是*更新已经存在的集合*。这就是`collect`方法。\n\n### `collect`方法\n\n假如你要收集所有*年龄≥18岁的person的人名*：\n\n``` java\npersons\n    .stream()\n    .filter(p -> p.getAge() >= 18)\n    .map(Person::getName)\n    .collect(ArrayList::new, ArrayList::add, ArrayList::addAll);\n```\n\n`collect`有两个方法：\n\n####  `R collect (Supplier<R>, BiConsumer<R, ? super T>, BiConsumer<R, R>)`\n\n* 第一个参数Supplier：用于初始化返回结果\n* 第二个参数BiConsumer： 用于操作*部分结果与下一个流内容*\n* 第二个参数BiConsumer： 用于*合并操作*\n\n#### `<R, A> R collect(Collector<? super T, A, R> collector)`\n\n`Collector`将上述*初始化*、*部分接口与下一个流内容操作*、*合并*封装了起来，并且在`java.util.stream.Collectors`中提供了一些常用的collector，如`toList`、`toSet`等。\n\n上述收集所有*年龄≥18岁的person的人名*的例子可以改写为：\n\n\n``` java\npersons\n    .stream()\n    .filter(p -> p.getAge() >= 18)\n    .map(Person::getName)\n    .collect(Collectors.toList()));\n```\n\n`Collectors.groupingBy(classifier)`用于分组，返回一个key为`classifier`分类的标准，value为ArrayList的Map。\n\n``` java\npersons\n    .stream()\n    .collect(Collectors.groupingBy(Person::getGender)));\n```\n\n如果要将persons按性别分组，返回其name：\n\n``` java\npersons\n    .stream()\n    .collect(Collectors.groupingBy(\n            Person::getGender,\n            Collectors.mapping(Person::getName, Collectors.toList()))));\n```\n\n如果要将persons按性别分组，返回每组的年龄总数/年龄最大值/平均年龄：\n\n``` java\n// 年龄和\npersons\n    .stream()\n    .collect(Collectors.groupingBy(\n            Person::getGender,\n            Collectors.mapping(\n                    Person::getAge, \n                    Collectors.reducing(0, Math::addExact)))));\n// 年龄和\npersons\n    .stream()\n    .collect(Collectors.groupingBy(\n            Person::getGender,\n            Collectors.reducing(0, Person::getAge, Math::addExact))));\n\n// 年龄最大值\npersons\n    .stream()\n    .collect(Collectors.groupingBy(\n            Person::getGender,\n            Collectors.mapping(\n                    Person::getAge, \n                    Collectors.reducing(Math::max)))));\n\n// 年龄平均值\npersons\n    .stream()\n    .collect(Collectors.groupingBy(\n            Person::getGender,\n            Collectors.averagingInt(Person::getAge))));\n\n\n```\n\n## 参考\n[http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html](http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html)\n\n","slug":"aggregate-operation-in-java8","published":1,"updated":"2016-02-06T19:45:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciziguc5z0023nps6a972et79"},{"title":"study-spring-mve","date":"2016-01-14T17:21:09.000Z","_content":"\n## 一个请求的生命周期\n\n![请求的生命周期](/images/a_request's_life_in_spring_mvc.png)\n\n`DispatcherServlet`是spring mvc中的前端控制器`front controller`。前端控制器是MVC中常用的模式，其职责是将请求委托给其他应用组件。在这里，`DispatcherServlet`的工作就是将请求转发给`controller`。一个典型的web应用会有很多`controller`，那么`DispatcherServlet`应该如何分发请求呢？通过handler mapping。\n\n`controller`是用来处理用户请求的，但一个设计良好的`controller`应该是不自己处理或者处理得很少，而是将业务逻辑委托给其他业务逻辑服务对象。逻辑处理完后往往需要带回一些信息或数据给用户，然后展示在浏览器端，也就是`model`。当然仅仅返回原始的数据是不够的，需要将其格式化友好的呈现在用户面前，比如典型的HTML格式。所以这些信息需要包含一个`view`，典型的有jsp。注意，这里的 view 仅仅是个名称，`DispatcherServlet`通过视图解析器（view resolver）将之与具体的实现匹配起来。\n\n## control 怎么写\n\n## quest 如何 handle\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_drafts/study-spring-mvc.md","raw":"---\ntitle: study-spring-mve\ndate: 2016-01-15 01:21:09\ntags:\n- spring\n- mvc\ncategories:\n- spring\n---\n\n## 一个请求的生命周期\n\n![请求的生命周期](/images/a_request's_life_in_spring_mvc.png)\n\n`DispatcherServlet`是spring mvc中的前端控制器`front controller`。前端控制器是MVC中常用的模式，其职责是将请求委托给其他应用组件。在这里，`DispatcherServlet`的工作就是将请求转发给`controller`。一个典型的web应用会有很多`controller`，那么`DispatcherServlet`应该如何分发请求呢？通过handler mapping。\n\n`controller`是用来处理用户请求的，但一个设计良好的`controller`应该是不自己处理或者处理得很少，而是将业务逻辑委托给其他业务逻辑服务对象。逻辑处理完后往往需要带回一些信息或数据给用户，然后展示在浏览器端，也就是`model`。当然仅仅返回原始的数据是不够的，需要将其格式化友好的呈现在用户面前，比如典型的HTML格式。所以这些信息需要包含一个`view`，典型的有jsp。注意，这里的 view 仅仅是个名称，`DispatcherServlet`通过视图解析器（view resolver）将之与具体的实现匹配起来。\n\n## control 怎么写\n\n## quest 如何 handle\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"study-spring-mvc","published":0,"updated":"2016-09-28T13:20:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciziguc62002anps6o1rnsdlq"},{"title":"MySQL简易教程","date":"2016-01-13T16:41:38.000Z","toc":true,"_content":"\n许久没用mysql了，`root`密码都忘了... \n\n简单的教程：如何使用mysql客户端创建和使用数据库。（详细版请参考[官网文档](http://dev.mysql.com/doc/refman/5.7/en/tutorial.html))\n\n<!-- more -->\n\n## 连接/断开数据库服务器\n\n``` bash\nmysql -h host -u user -p\n```\n\n* `-h` 用来指定主机（如果是本地`localhost`，可以忽略）\n* `-u` 指定用户名\n* `-p` 表示使用密码登陆\n\n输入密码后就可以看到mysql欢迎页面：\n\n``` bash\nWelcome to the MySQL monitor.  Commands end with ; or \\g.\nYour MySQL connection id is 6\nServer version: 5.7.10 Homebrew\n\nCopyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.\n\nOracle is a registered trademark of Oracle Corporation and/or its\naffiliates. Other names may be trademarks of their respective\nowners.\n\nType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\n\nmysql>\n```\n\n当然，你也有可能得到这样的提示：`ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/tmp/mysql.sock' (2)`，那是因为你忘记启动数据库服务器了，使用以下命令启动：\n\n``` bash\nmysql.server start\n```\n\n断开连接使用`quit`或者`\\q`，mac下也可以使用组合键`control + D`：\n\n``` bash\nmysql> quit\nBye\n```\n\n## 查询\n\n我们来查询下当前mysql版本以及当前时间：\n\n``` bash\nmysql> select version(), current_date;\n+-----------+--------------+\n| version() | current_date |\n+-----------+--------------+\n| 5.7.10    | 2016-01-14   |\n+-----------+--------------+\n1 row in set (0.00 sec)\n\nmysql> \n```\n\n* 一条`query`由一个以分号`;`结尾的SQL表达式组成。（也有很多别的场景可以忽略分号，比如`quit`）\n* 查询的信息以逗号`,`分割，否则会语法抛错\n* 查询结果有2部分\n  * 第一部分已表格形式呈现，第一行为表头，随后查询的数据\n  * 第二部分为一些其他信息，如`返回多少行`，以及`本次查询耗时`\n* 查询语句是大小写不敏感的\n\n多条查询语句可以放在一行，分别已分号结尾。当你忘记输入分号或者想多行输入时，会是这个样子：\n\n``` bash\nmysql> select\n    -> user()\n    -> ,\n    -> current_date;\n+----------------+--------------+\n| user()         | current_date |\n+----------------+--------------+\n| root@localhost | 2016-01-14   |\n+----------------+--------------+\n1 row in set (0.00 sec)\n\nmysql> \n```\n\n如果你不想执行当前的查询，可用通过`\\c`来取消：\n\n``` bash\nmysql> select user()\n    -> \\c\nmysql>\n```\n\n一些提示符及意义：\n\n* `mysql>`：准备接受下次查询\n* `->`：等待一次查询中的下一行\n* `'>`：等待`'`与之匹配表示一个完整的`string`\n* `\">`：等待`\"`与之匹配表示一个完整的`string`\n* ``\\>``：等待`` ` ``与之匹配表示一个完整的标识符\n* `/*>`：等待`*/`与之匹配表示一个完整的注释\n\n## 创建/使用库\n\n\n\n\n\n\n\n\n","source":"_drafts/simple-mysql-tutorial.md","raw":"---\ntitle: MySQL简易教程\ndate: 2016-01-14 00:41:38\ntags: MySQL\ncategories: MySQL\ntoc: true\n---\n\n许久没用mysql了，`root`密码都忘了... \n\n简单的教程：如何使用mysql客户端创建和使用数据库。（详细版请参考[官网文档](http://dev.mysql.com/doc/refman/5.7/en/tutorial.html))\n\n<!-- more -->\n\n## 连接/断开数据库服务器\n\n``` bash\nmysql -h host -u user -p\n```\n\n* `-h` 用来指定主机（如果是本地`localhost`，可以忽略）\n* `-u` 指定用户名\n* `-p` 表示使用密码登陆\n\n输入密码后就可以看到mysql欢迎页面：\n\n``` bash\nWelcome to the MySQL monitor.  Commands end with ; or \\g.\nYour MySQL connection id is 6\nServer version: 5.7.10 Homebrew\n\nCopyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.\n\nOracle is a registered trademark of Oracle Corporation and/or its\naffiliates. Other names may be trademarks of their respective\nowners.\n\nType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\n\nmysql>\n```\n\n当然，你也有可能得到这样的提示：`ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/tmp/mysql.sock' (2)`，那是因为你忘记启动数据库服务器了，使用以下命令启动：\n\n``` bash\nmysql.server start\n```\n\n断开连接使用`quit`或者`\\q`，mac下也可以使用组合键`control + D`：\n\n``` bash\nmysql> quit\nBye\n```\n\n## 查询\n\n我们来查询下当前mysql版本以及当前时间：\n\n``` bash\nmysql> select version(), current_date;\n+-----------+--------------+\n| version() | current_date |\n+-----------+--------------+\n| 5.7.10    | 2016-01-14   |\n+-----------+--------------+\n1 row in set (0.00 sec)\n\nmysql> \n```\n\n* 一条`query`由一个以分号`;`结尾的SQL表达式组成。（也有很多别的场景可以忽略分号，比如`quit`）\n* 查询的信息以逗号`,`分割，否则会语法抛错\n* 查询结果有2部分\n  * 第一部分已表格形式呈现，第一行为表头，随后查询的数据\n  * 第二部分为一些其他信息，如`返回多少行`，以及`本次查询耗时`\n* 查询语句是大小写不敏感的\n\n多条查询语句可以放在一行，分别已分号结尾。当你忘记输入分号或者想多行输入时，会是这个样子：\n\n``` bash\nmysql> select\n    -> user()\n    -> ,\n    -> current_date;\n+----------------+--------------+\n| user()         | current_date |\n+----------------+--------------+\n| root@localhost | 2016-01-14   |\n+----------------+--------------+\n1 row in set (0.00 sec)\n\nmysql> \n```\n\n如果你不想执行当前的查询，可用通过`\\c`来取消：\n\n``` bash\nmysql> select user()\n    -> \\c\nmysql>\n```\n\n一些提示符及意义：\n\n* `mysql>`：准备接受下次查询\n* `->`：等待一次查询中的下一行\n* `'>`：等待`'`与之匹配表示一个完整的`string`\n* `\">`：等待`\"`与之匹配表示一个完整的`string`\n* ``\\>``：等待`` ` ``与之匹配表示一个完整的标识符\n* `/*>`：等待`*/`与之匹配表示一个完整的注释\n\n## 创建/使用库\n\n\n\n\n\n\n\n\n","slug":"simple-mysql-tutorial","published":0,"updated":"2016-01-13T18:01:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciziguc65002hnps6rfhp00ik"},{"title":"Spring","date":"2016-02-03T07:55:03.000Z","toc":true,"_content":"\nSpring中需要加载各种资源，包括XML中bean的配置等，而Java自带的`java.net.URL`并不能满足Application中的资源定位。Spring中将资源统称为`Resource`。\n\n本文就Spring中的资源及资源加载展开探索。\n\n<!-- more -->\n\nApplicationContext与BeanFactory的区别之一就是前者具有资源加载的功能。`ResourcePatternResolver`扩展于`ResourceLoader`，是ApplicationContext继承的接口，用于定位、解析资源。具体实现为`PathMatchingResourcePatternResolver`。\n\n## `ResourceLoader`\n\n### 接口说明\n\n``` java\npublic interface ResourceLoader {\n\n    // 查询指定路径的资源.\n     \n    // Must support fully qualified URLs, e.g. \"file:C:/test.dat\".\n    // Must support classpath pseudo-URLs, e.g. \"classpath:test.dat\".\n    // Should support relative file paths, e.g. \"WEB-INF/test.dat\".\n    // (This will be implementation-specific, typically provided by an\n    // ApplicationContext implementation.)\n    \n    Resource getResource(String location);\n\n    ClassLoader getClassLoader();\n}\n```\n\n### 默认实现\n\n`ResourceLoader`的默认实现为`DefaultResourceLoader`，`AbstractApplicationContext`继承于`DefaultResourceLoader`实现指定路径的资源加载。\n\n#### 默认的`ClassLoader`\n\n资源加载必然离不开`ClassLoader`，`DefaultResourceLoader`的默认class loader是通过`ClassUtils`来初始化的。\n\n``` java\npublic DefaultResourceLoader() {\n    // 默认classLoader\n    this.classLoader = ClassUtils.getDefaultClassLoader();\n}\n\npublic ClassLoader getClassLoader() {\n    return (this.classLoader != null ? this.classLoader : ClassUtils.getDefaultClassLoader());\n}\n```\n\n``` java\npublic static ClassLoader getDefaultClassLoader() {\n    ClassLoader cl = null;\n    try {\n    \t// 当前线程的context ClassLoader\n    \tcl = Thread.currentThread().getContextClassLoader();\n    }\n    catch (Throwable ex) {\n    \t// Cannot access thread context ClassLoader - falling back...\n    }\n    if (cl == null) {\n    \t// No thread context class loader -> use class loader of this class.\n    \tcl = ClassUtils.class.getClassLoader();\n    \tif (cl == null) {\n    \t\t// getClassLoader() returning null indicates the bootstrap ClassLoader\n    \t\ttry {\n    \t\t\tcl = ClassLoader.getSystemClassLoader();\n    \t\t}\n    \t\tcatch (Throwable ex) {\n    \t\t\t// Cannot access system ClassLoader - oh well, maybe the caller can live with null...\n    \t\t}\n    \t}\n    }\n    return cl;\n}\n```\n可以看出会依次获取当前线程的context classLoader、`ClassUtils`的classLoader、jvm系统ClassLoader，直到发现可用的为止。\n\n#### 如何加载指定资源\n\n``` java\npublic Resource getResource(String location) {\n    Assert.notNull(location, \"Location must not be null\");\n    if (location.startsWith(\"/\")) {\n        return getResourceByPath(location);\n    }\n    else if (location.startsWith(CLASSPATH_URL_PREFIX)) {\n        return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());\n    }\n    else {\n    \ttry {\n            // Try to parse the location as a URL...\n            URL url = new URL(location);\n            return new UrlResource(url);\n    \t}\n    \tcatch (MalformedURLException ex) {\n            // No URL -> resolve as resource path.\n            return getResourceByPath(location);\n    \t}\n    }\n}\n\nprotected Resource getResourceByPath(String path) {\n    return new ClassPathContextResource(path, getClassLoader());\n}\n```\n\n`DefaultResourceLoader`加载资源是通过根据不同路径返回不同`Resource`来实现。具体资源内容可通过相应的`Resource`提供的api进行获取。\n\n## `ResourcePatternResolver`\n\n### 接口说明\n\n``` java\npublic interface ResourcePatternResolver extends ResourceLoader {\n    String CLASSPATH_ALL_URL_PREFIX = \"classpath*:\";\n\n    Resource[] getResources(String locationPattern) throws IOException;\n}\n```\n\n### 默认实现\n`PathMatchingResourcePatternResolver`\n\n\n  \n\n\n","source":"_drafts/resources-loading-in-spring.md","raw":"---\ntitle: Spring\ndate: 2016-02-03 15:55:03\ntags:\ncategories:\ntoc: true\n---\n\nSpring中需要加载各种资源，包括XML中bean的配置等，而Java自带的`java.net.URL`并不能满足Application中的资源定位。Spring中将资源统称为`Resource`。\n\n本文就Spring中的资源及资源加载展开探索。\n\n<!-- more -->\n\nApplicationContext与BeanFactory的区别之一就是前者具有资源加载的功能。`ResourcePatternResolver`扩展于`ResourceLoader`，是ApplicationContext继承的接口，用于定位、解析资源。具体实现为`PathMatchingResourcePatternResolver`。\n\n## `ResourceLoader`\n\n### 接口说明\n\n``` java\npublic interface ResourceLoader {\n\n    // 查询指定路径的资源.\n     \n    // Must support fully qualified URLs, e.g. \"file:C:/test.dat\".\n    // Must support classpath pseudo-URLs, e.g. \"classpath:test.dat\".\n    // Should support relative file paths, e.g. \"WEB-INF/test.dat\".\n    // (This will be implementation-specific, typically provided by an\n    // ApplicationContext implementation.)\n    \n    Resource getResource(String location);\n\n    ClassLoader getClassLoader();\n}\n```\n\n### 默认实现\n\n`ResourceLoader`的默认实现为`DefaultResourceLoader`，`AbstractApplicationContext`继承于`DefaultResourceLoader`实现指定路径的资源加载。\n\n#### 默认的`ClassLoader`\n\n资源加载必然离不开`ClassLoader`，`DefaultResourceLoader`的默认class loader是通过`ClassUtils`来初始化的。\n\n``` java\npublic DefaultResourceLoader() {\n    // 默认classLoader\n    this.classLoader = ClassUtils.getDefaultClassLoader();\n}\n\npublic ClassLoader getClassLoader() {\n    return (this.classLoader != null ? this.classLoader : ClassUtils.getDefaultClassLoader());\n}\n```\n\n``` java\npublic static ClassLoader getDefaultClassLoader() {\n    ClassLoader cl = null;\n    try {\n    \t// 当前线程的context ClassLoader\n    \tcl = Thread.currentThread().getContextClassLoader();\n    }\n    catch (Throwable ex) {\n    \t// Cannot access thread context ClassLoader - falling back...\n    }\n    if (cl == null) {\n    \t// No thread context class loader -> use class loader of this class.\n    \tcl = ClassUtils.class.getClassLoader();\n    \tif (cl == null) {\n    \t\t// getClassLoader() returning null indicates the bootstrap ClassLoader\n    \t\ttry {\n    \t\t\tcl = ClassLoader.getSystemClassLoader();\n    \t\t}\n    \t\tcatch (Throwable ex) {\n    \t\t\t// Cannot access system ClassLoader - oh well, maybe the caller can live with null...\n    \t\t}\n    \t}\n    }\n    return cl;\n}\n```\n可以看出会依次获取当前线程的context classLoader、`ClassUtils`的classLoader、jvm系统ClassLoader，直到发现可用的为止。\n\n#### 如何加载指定资源\n\n``` java\npublic Resource getResource(String location) {\n    Assert.notNull(location, \"Location must not be null\");\n    if (location.startsWith(\"/\")) {\n        return getResourceByPath(location);\n    }\n    else if (location.startsWith(CLASSPATH_URL_PREFIX)) {\n        return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());\n    }\n    else {\n    \ttry {\n            // Try to parse the location as a URL...\n            URL url = new URL(location);\n            return new UrlResource(url);\n    \t}\n    \tcatch (MalformedURLException ex) {\n            // No URL -> resolve as resource path.\n            return getResourceByPath(location);\n    \t}\n    }\n}\n\nprotected Resource getResourceByPath(String path) {\n    return new ClassPathContextResource(path, getClassLoader());\n}\n```\n\n`DefaultResourceLoader`加载资源是通过根据不同路径返回不同`Resource`来实现。具体资源内容可通过相应的`Resource`提供的api进行获取。\n\n## `ResourcePatternResolver`\n\n### 接口说明\n\n``` java\npublic interface ResourcePatternResolver extends ResourceLoader {\n    String CLASSPATH_ALL_URL_PREFIX = \"classpath*:\";\n\n    Resource[] getResources(String locationPattern) throws IOException;\n}\n```\n\n### 默认实现\n`PathMatchingResourcePatternResolver`\n\n\n  \n\n\n","slug":"resources-loading-in-spring","published":0,"updated":"2016-02-03T08:34:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciziguc68002mnps6o8pczqfm"},{"title":"nginx之http rewrite","date":"2016-02-18T03:21:05.000Z","_content":"\nnginx中经常会用到rewrite模块进行资源重定向，涉及URI正则匹配、临时重定向、永久重定向等。\n\n<!-- more -->\n\n## 指令执行顺序\n\n* 顺序执行`server`中指令\n* 重复执行\n  * 根据请求的URI寻找相应的`location`\n  * 顺序执行`location`中指令\n  * 如果URI被rewrite，则重新执行，但此时不超过*10*次\n\n##\n\n### `if`\n\n```\nif ($slow) {\n    limit_rate 10k;\n}\n\nif ($variable = \"test\") {\n    set $variable \"test\";\n}\n\nif ($http_cookie ~* \"id=([^;]+)(?:;|$)\") {\n    set $id $1;\n}\n```\n\n*`if`中的配置文件继承于{}外面的配置。*\n\n#### if中条件约定\n\n* 变量：如果变量为`empty`或者`0`，返回`false`\n* 变量比较：使用`=`或者`!=`\n* 变量匹配：使用`~`（大小写敏感）或者`~*`（大小写不敏感）、`!~`、`!~*`。如果正则表达式中包含`}`、`;`字符，则表达式需要使用单引号或者双引号。\n* 检查文件是否存在：`-f`、`!-f`\n* 检查文件夹是否存在：`-d`、`!-d`\n* 检查文件、文件夹、链接是否存在：`-e`、`!-e`\n* 检查可执行文件是否存在：`-x`、`!-x`\n\n## `break`\n\n\n\n\n\n\n","source":"_drafts/nginx-http-rewrite.md","raw":"---\ntitle: nginx之http rewrite\ndate: 2016-02-18 11:21:05\ntags: http_rewrite\ncategories: nginx\n---\n\nnginx中经常会用到rewrite模块进行资源重定向，涉及URI正则匹配、临时重定向、永久重定向等。\n\n<!-- more -->\n\n## 指令执行顺序\n\n* 顺序执行`server`中指令\n* 重复执行\n  * 根据请求的URI寻找相应的`location`\n  * 顺序执行`location`中指令\n  * 如果URI被rewrite，则重新执行，但此时不超过*10*次\n\n##\n\n### `if`\n\n```\nif ($slow) {\n    limit_rate 10k;\n}\n\nif ($variable = \"test\") {\n    set $variable \"test\";\n}\n\nif ($http_cookie ~* \"id=([^;]+)(?:;|$)\") {\n    set $id $1;\n}\n```\n\n*`if`中的配置文件继承于{}外面的配置。*\n\n#### if中条件约定\n\n* 变量：如果变量为`empty`或者`0`，返回`false`\n* 变量比较：使用`=`或者`!=`\n* 变量匹配：使用`~`（大小写敏感）或者`~*`（大小写不敏感）、`!~`、`!~*`。如果正则表达式中包含`}`、`;`字符，则表达式需要使用单引号或者双引号。\n* 检查文件是否存在：`-f`、`!-f`\n* 检查文件夹是否存在：`-d`、`!-d`\n* 检查文件、文件夹、链接是否存在：`-e`、`!-e`\n* 检查可执行文件是否存在：`-x`、`!-x`\n\n## `break`\n\n\n\n\n\n\n","slug":"nginx-http-rewrite","published":0,"updated":"2016-02-26T06:55:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciziguc6a002nnps611qs6zw4"},{"title":"mysql-basic-sql","_content":"\n## 启动/终止mysql\n`mysql.server start`\n`mysql.server status`\n`mysql.server stop`\n`mysql.server restart`\n`mysql.server reload`\n\n## 登录mysql\n`mysql -u root -p -h localhost`\n\n* -u : username\n* -p : password\n* -h : host\n* -P : port\n\n## 退出mysql\n`exit`\n`quit`\n`\\q`\n\n## 修改mysql提示符\n`prompt \\h`\n\n* \\h : host\n* \\u : username\n* \\d : database\n* \\D : date\n\n## 常用命令\n`SELECT VERSION(), NOW(), USER();`\n\n## 数据库基本操作\n`CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] db_name [DEFAULT] CHARACTER SET charset_name`\n\n`SHOW CREATE db_name;`\n\n`ALTER {DATABASE | SCHEMA} [db_name] [DEFAULT] CHARACTER SET [=] charset_name`\n\n`DROP {DATABASE | SCHEMA} [IF EXISTS] db_name;`\n\n## 数据类型\n\n* 整型\n\t* TINYINT 1字节\n\t* SMALLINT 2字节\n\t* MUDIUMINT 3字节\n\t* INT 4字节\n\t* BIGINT 8字节\n* 字符串\n* 时间\n\n## 数据表\n\n`CREATE TABLE table_name (column_name, data_type;`\n\n`","source":"_drafts/mysql-basic-sql.md","raw":"---\ntitle: mysql-basic-sql\ntags:\ncategories:\n---\n\n## 启动/终止mysql\n`mysql.server start`\n`mysql.server status`\n`mysql.server stop`\n`mysql.server restart`\n`mysql.server reload`\n\n## 登录mysql\n`mysql -u root -p -h localhost`\n\n* -u : username\n* -p : password\n* -h : host\n* -P : port\n\n## 退出mysql\n`exit`\n`quit`\n`\\q`\n\n## 修改mysql提示符\n`prompt \\h`\n\n* \\h : host\n* \\u : username\n* \\d : database\n* \\D : date\n\n## 常用命令\n`SELECT VERSION(), NOW(), USER();`\n\n## 数据库基本操作\n`CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] db_name [DEFAULT] CHARACTER SET charset_name`\n\n`SHOW CREATE db_name;`\n\n`ALTER {DATABASE | SCHEMA} [db_name] [DEFAULT] CHARACTER SET [=] charset_name`\n\n`DROP {DATABASE | SCHEMA} [IF EXISTS] db_name;`\n\n## 数据类型\n\n* 整型\n\t* TINYINT 1字节\n\t* SMALLINT 2字节\n\t* MUDIUMINT 3字节\n\t* INT 4字节\n\t* BIGINT 8字节\n* 字符串\n* 时间\n\n## 数据表\n\n`CREATE TABLE table_name (column_name, data_type;`\n\n`","slug":"mysql-basic-sql","published":0,"date":"2016-01-24T09:00:29.000Z","updated":"2016-01-24T09:00:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciziguc6d002snps6pewre2i4"},{"title":"logback-tutorial","date":"2016-01-18T14:21:36.000Z","toc":true,"_content":"\n一个系统，小到web框架，大到操作系统，都离不开日志。因为开发者、使用者都需要在一些重要时刻记录一些重要事件或者里程碑的发生。如[spring-framework](http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#overview-logging)在文档中讲到，它的外部依赖甚少，只有日志框架[commons-logging](https://commons.apache.org/proper/commons-logging/)。那么对日志框架的了解，对web开发、框架开发将起到非常重要的作用。\n\n这边文章主要介绍日志框架中的`Logback`，以及现在流行的其他框架。\n\n<!-- more -->\n\n## SLF4J与JCL\n\n{% blockquote \"-- SLF4J user manual, \" http://www.slf4j.org/manual.html %}\nThe Simple Logging Facade for Java (SLF4J) serves as a simple facade or abstraction for various logging frameworks (e.g. java.util.logging, logback, log4j) allowing the end user to plug in the desired logging framework at deployment time.\n{% endblockquote %}\n\n[SLF4J](http://www.slf4j.org/) 是一个面向Java的简单日志门面，是其他日志框架的抽象（logback、log4j等)，允许使用者在编译部署时插入具体的日志框架。\n\n*JCL*（Jakarta Commons Logging），也叫[Apache Commons Logging](http://commons.apache.org/)，是Apache早起开发的一套日志框架。\n\n## logback是什么\n\n`Logback`是一个日志框架，用来终结现在广为流行的`Log4j`日志框架。它的设计者正是 *log4j* 的作者，*Ceki Gülcü*。\n\n## dependency\n\n``` xml maven\n<dependency>\n    <groupId>ch.qos.logback</groupId>\n    <artifact>logback-classic</artifact>\n    <version>1.1.3</versrion>\n</dependency>\n```\n\nor\n\n``` gradle gradle\ndependencies {\n    compile(\"ch.qos.logback:logback-classic:1.+\")\n}\n```\n\nLogback想要正常使用，classpath中必须可以找到`slf4j-api.jar`、`logback-core.jar`、`logback-classic.jar`3个jar包。\n\n\n\n\n","source":"_drafts/logback-tutorial.md","raw":"---\ntitle: logback-tutorial\ntags: logback\ndate: 2016-01-18 22:21:36\ncategories:\ntoc: true\n---\n\n一个系统，小到web框架，大到操作系统，都离不开日志。因为开发者、使用者都需要在一些重要时刻记录一些重要事件或者里程碑的发生。如[spring-framework](http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#overview-logging)在文档中讲到，它的外部依赖甚少，只有日志框架[commons-logging](https://commons.apache.org/proper/commons-logging/)。那么对日志框架的了解，对web开发、框架开发将起到非常重要的作用。\n\n这边文章主要介绍日志框架中的`Logback`，以及现在流行的其他框架。\n\n<!-- more -->\n\n## SLF4J与JCL\n\n{% blockquote \"-- SLF4J user manual, \" http://www.slf4j.org/manual.html %}\nThe Simple Logging Facade for Java (SLF4J) serves as a simple facade or abstraction for various logging frameworks (e.g. java.util.logging, logback, log4j) allowing the end user to plug in the desired logging framework at deployment time.\n{% endblockquote %}\n\n[SLF4J](http://www.slf4j.org/) 是一个面向Java的简单日志门面，是其他日志框架的抽象（logback、log4j等)，允许使用者在编译部署时插入具体的日志框架。\n\n*JCL*（Jakarta Commons Logging），也叫[Apache Commons Logging](http://commons.apache.org/)，是Apache早起开发的一套日志框架。\n\n## logback是什么\n\n`Logback`是一个日志框架，用来终结现在广为流行的`Log4j`日志框架。它的设计者正是 *log4j* 的作者，*Ceki Gülcü*。\n\n## dependency\n\n``` xml maven\n<dependency>\n    <groupId>ch.qos.logback</groupId>\n    <artifact>logback-classic</artifact>\n    <version>1.1.3</versrion>\n</dependency>\n```\n\nor\n\n``` gradle gradle\ndependencies {\n    compile(\"ch.qos.logback:logback-classic:1.+\")\n}\n```\n\nLogback想要正常使用，classpath中必须可以找到`slf4j-api.jar`、`logback-core.jar`、`logback-classic.jar`3个jar包。\n\n\n\n\n","slug":"logback-tutorial","published":0,"updated":"2016-01-18T15:12:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciziguc6f002tnps6gptdfpv6"},{"title":"java interview","_content":"\n集合： [http://www.importnew.com/15980.html]()","source":"_drafts/java-interview.md","raw":"---\ntitle: java interview\ntags:\ncategories:\n---\n\n集合： [http://www.importnew.com/15980.html]()","slug":"java-interview","published":0,"date":"2016-02-18T04:47:17.000Z","updated":"2016-02-18T04:47:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciziguc6h002wnps6j080u3rz"},{"title":"effective-plugins-of-eclipse","_content":"\n0. code style\n\n1. webx/springExt\n\n2. findbugs\n3. checkStyle\n4. eclEmma \n\n5. [gradle TOOLS](http://dist.springsource.com/release/TOOLS/gradle)\n6. minimalist \n\n7. [eclipse-jetty](http://eclipse-jetty.github.io/update/)\n","source":"_drafts/effective-plugins-of-eclipse.md","raw":"---\ntitle: effective-plugins-of-eclipse\ntags:\ncategories:\n---\n\n0. code style\n\n1. webx/springExt\n\n2. findbugs\n3. checkStyle\n4. eclEmma \n\n5. [gradle TOOLS](http://dist.springsource.com/release/TOOLS/gradle)\n6. minimalist \n\n7. [eclipse-jetty](http://eclipse-jetty.github.io/update/)\n","slug":"effective-plugins-of-eclipse","published":0,"date":"2016-01-18T10:16:35.000Z","updated":"2016-01-18T10:16:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciziguc6j002xnps6lmheg0zt"},{"title":"Config Data Source With Spring","date":"2016-01-24T13:50:46.000Z","_content":"\n## Spring中配置data source\n\n### JNDI data source\n\n### pooled data source\n\n### JDBC driver-based data source\n\n* `DriverManagerDataSource` —— 每次请求返回一个连接，不支持连接池。\n* `SimpleDriverDataSource` —— 功能同`DriverManagerDataSource`，解决class加载问题\n* `SingleConnectionDataSource` —— 每次返回一个相同的连接（连接数为1的连接池）\n\n### embedded data source\n\n## JDBC template\n\n\n","source":"_drafts/config-data-source-with-spring.md","raw":"---\ntitle: Config Data Source With Spring\ndate: 2016-01-24 21:50:46\ntags: JDBC\ncategories: \n---\n\n## Spring中配置data source\n\n### JNDI data source\n\n### pooled data source\n\n### JDBC driver-based data source\n\n* `DriverManagerDataSource` —— 每次请求返回一个连接，不支持连接池。\n* `SimpleDriverDataSource` —— 功能同`DriverManagerDataSource`，解决class加载问题\n* `SingleConnectionDataSource` —— 每次返回一个相同的连接（连接数为1的连接池）\n\n### embedded data source\n\n## JDBC template\n\n\n","slug":"config-data-source-with-spring","published":0,"updated":"2016-01-30T16:18:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciziguc6l002ynps68231iug1"},{"title":"创业阅读清单","_content":"\n* [创始人和VC推荐企业家读的21本书](http://blog.jobbole.com/1537/)\n","source":"_drafts/Startup-Reading-List.md","raw":"---\ntitle: 创业阅读清单\ntags:\ncategories:\n---\n\n* [创始人和VC推荐企业家读的21本书](http://blog.jobbole.com/1537/)\n","slug":"Startup-Reading-List","published":0,"date":"2016-01-10T18:17:25.000Z","updated":"2016-01-10T18:17:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciziguc6p0030nps6poe79757"}],"PostAsset":[],"PostCategory":[{"post_id":"ciziguc4c0003nps6mjn5towy","category_id":"ciziguc4e0004nps6qnpzvocf","_id":"ciziguc4f0007nps6puci3lzn"},{"post_id":"ciziguc4h0008nps6j918gsrs","category_id":"ciziguc4i0009nps6qrprcrt9","_id":"ciziguc4j000cnps6wjs7y91h"},{"post_id":"ciziguc4m000hnps6yfjpl7uc","category_id":"ciziguc4i0009nps6qrprcrt9","_id":"ciziguc4o000inps6m833sxwj"},{"post_id":"ciziguc4q000nnps6iiqgsa41","category_id":"ciziguc4i0009nps6qrprcrt9","_id":"ciziguc4r000onps6xq5liefk"},{"post_id":"ciziguc4t000rnps6yk3uuozi","category_id":"ciziguc4u000snps6n6for3m5","_id":"ciziguc4u000vnps6o2ilvpue"},{"post_id":"ciziguc4w000wnps6doakz953","category_id":"ciziguc4i0009nps6qrprcrt9","_id":"ciziguc4x000xnps67zkp07j3"},{"post_id":"ciziguc500012nps6bfd1swnq","category_id":"ciziguc4i0009nps6qrprcrt9","_id":"ciziguc520013nps6ij8omt6x"},{"post_id":"ciziguc550018nps65ozjuk2j","category_id":"ciziguc4i0009nps6qrprcrt9","_id":"ciziguc570019nps6703c4x8g"},{"post_id":"ciziguc5a001dnps61xaz1dgw","category_id":"ciziguc5b001enps62vctrlg9","_id":"ciziguc5b001fnps6qwxq2g0c"},{"post_id":"ciziguc5c001gnps6gze0i52b","category_id":"ciziguc4i0009nps6qrprcrt9","_id":"ciziguc5d001hnps6k52u9k5x"},{"post_id":"ciziguc5k001onps6tas1ys08","category_id":"ciziguc4e0004nps6qnpzvocf","_id":"ciziguc5m001pnps639rpkxgd"},{"post_id":"ciziguc5s001vnps6c69316zk","category_id":"ciziguc4i0009nps6qrprcrt9","_id":"ciziguc5t001wnps6x4cw4jqd"},{"post_id":"ciziguc5v001znps6z43b5am6","category_id":"ciziguc4i0009nps6qrprcrt9","_id":"ciziguc5y0020nps6401yzgsi"},{"post_id":"ciziguc5z0023nps6a972et79","category_id":"ciziguc4i0009nps6qrprcrt9","_id":"ciziguc600024nps6r6l1y9dj"},{"post_id":"ciziguc62002anps6o1rnsdlq","category_id":"ciziguc63002bnps6oabin6lz","_id":"ciziguc64002enps683zs5dp6"},{"post_id":"ciziguc65002hnps6rfhp00ik","category_id":"ciziguc66002inps6d1zkemen","_id":"ciziguc67002lnps6zcgdgcvn"},{"post_id":"ciziguc6a002nnps611qs6zw4","category_id":"ciziguc6b002onps65rh1amfi","_id":"ciziguc6c002rnps6cgxhjpig"}],"PostTag":[{"post_id":"ciziguc3r0000nps6vr76fs3p","tag_id":"ciziguc3x0001nps6hysi2a6a","_id":"ciziguc460002nps68seyvfb0"},{"post_id":"ciziguc4c0003nps6mjn5towy","tag_id":"ciziguc4e0005nps6ho4gwb06","_id":"ciziguc4f0006nps6pdqiza8g"},{"post_id":"ciziguc4h0008nps6j918gsrs","tag_id":"ciziguc4i000anps6xbzteqt9","_id":"ciziguc4j000enps6c8fl9fkr"},{"post_id":"ciziguc4h0008nps6j918gsrs","tag_id":"ciziguc4j000bnps6x13mu357","_id":"ciziguc4k000fnps63y98zboq"},{"post_id":"ciziguc4h0008nps6j918gsrs","tag_id":"ciziguc4j000dnps6a289k6yg","_id":"ciziguc4k000gnps6my9b5y70"},{"post_id":"ciziguc4m000hnps6yfjpl7uc","tag_id":"ciziguc4i000anps6xbzteqt9","_id":"ciziguc4o000knps6bncn3awj"},{"post_id":"ciziguc4m000hnps6yfjpl7uc","tag_id":"ciziguc4j000bnps6x13mu357","_id":"ciziguc4o000lnps633qdfhvi"},{"post_id":"ciziguc4m000hnps6yfjpl7uc","tag_id":"ciziguc4o000jnps6xguixps8","_id":"ciziguc4o000mnps61midwt96"},{"post_id":"ciziguc4q000nnps6iiqgsa41","tag_id":"ciziguc4r000pnps6tf7cmkhf","_id":"ciziguc4s000qnps6d46f46vc"},{"post_id":"ciziguc4t000rnps6yk3uuozi","tag_id":"ciziguc4u000tnps6qxpxskkf","_id":"ciziguc4u000unps6jcmagbl4"},{"post_id":"ciziguc4w000wnps6doakz953","tag_id":"ciziguc4i000anps6xbzteqt9","_id":"ciziguc4x000znps63yrbv28w"},{"post_id":"ciziguc4w000wnps6doakz953","tag_id":"ciziguc4j000bnps6x13mu357","_id":"ciziguc4y0010nps60goh5rk2"},{"post_id":"ciziguc4w000wnps6doakz953","tag_id":"ciziguc4x000ynps6ls8h9x0y","_id":"ciziguc4y0011nps6cfxcf58k"},{"post_id":"ciziguc500012nps6bfd1swnq","tag_id":"ciziguc520014nps6byhbwcp9","_id":"ciziguc530016nps6r4o5h9f9"},{"post_id":"ciziguc500012nps6bfd1swnq","tag_id":"ciziguc520015nps6bkgw6tlp","_id":"ciziguc530017nps6g93szkhs"},{"post_id":"ciziguc550018nps65ozjuk2j","tag_id":"ciziguc4r000pnps6tf7cmkhf","_id":"ciziguc58001bnps6n9ivo3sf"},{"post_id":"ciziguc550018nps65ozjuk2j","tag_id":"ciziguc58001anps6n530uiyd","_id":"ciziguc58001cnps6tedk45v9"},{"post_id":"ciziguc5c001gnps6gze0i52b","tag_id":"ciziguc4i000anps6xbzteqt9","_id":"ciziguc5e001jnps659d1dokd"},{"post_id":"ciziguc5c001gnps6gze0i52b","tag_id":"ciziguc5d001inps6zw82ixkj","_id":"ciziguc5e001knps6mmssfkof"},{"post_id":"ciziguc5h001lnps69e2r85id","tag_id":"ciziguc5i001mnps6ccgfakl3","_id":"ciziguc5j001nnps6p8o0du41"},{"post_id":"ciziguc5k001onps6tas1ys08","tag_id":"ciziguc5m001qnps6xyjydnho","_id":"ciziguc5n001rnps6pssf78a3"},{"post_id":"ciziguc5p001snps6zxxc61tm","tag_id":"ciziguc5q001tnps6egwuvj7a","_id":"ciziguc5r001unps6v8bsomnx"},{"post_id":"ciziguc5s001vnps6c69316zk","tag_id":"ciziguc5t001xnps6xrwrtccs","_id":"ciziguc5u001ynps64li9o413"},{"post_id":"ciziguc5v001znps6z43b5am6","tag_id":"ciziguc4i000anps6xbzteqt9","_id":"ciziguc5y0021nps6m8qizp6b"},{"post_id":"ciziguc5v001znps6z43b5am6","tag_id":"ciziguc4j000bnps6x13mu357","_id":"ciziguc5y0022nps6empxzimp"},{"post_id":"ciziguc5z0023nps6a972et79","tag_id":"ciziguc610025nps6wyfsue4v","_id":"ciziguc610027nps66em47ljm"},{"post_id":"ciziguc5z0023nps6a972et79","tag_id":"ciziguc610026nps6v907aymb","_id":"ciziguc610028nps6gb3kp8cx"},{"post_id":"ciziguc5z0023nps6a972et79","tag_id":"ciziguc520015nps6bkgw6tlp","_id":"ciziguc610029nps60y4orn5t"},{"post_id":"ciziguc62002anps6o1rnsdlq","tag_id":"ciziguc63002cnps66h3wyvxf","_id":"ciziguc64002fnps6jpwy5jpi"},{"post_id":"ciziguc62002anps6o1rnsdlq","tag_id":"ciziguc64002dnps6e0o684zu","_id":"ciziguc64002gnps69s5wb2kj"},{"post_id":"ciziguc65002hnps6rfhp00ik","tag_id":"ciziguc67002jnps6etjnqnq2","_id":"ciziguc67002knps6rl1qfdjp"},{"post_id":"ciziguc6a002nnps611qs6zw4","tag_id":"ciziguc6b002pnps68imy1226","_id":"ciziguc6c002qnps6dz4nib0m"},{"post_id":"ciziguc6f002tnps6gptdfpv6","tag_id":"ciziguc6g002unps6annndbd4","_id":"ciziguc6g002vnps6w4nacxy7"},{"post_id":"ciziguc6l002ynps68231iug1","tag_id":"ciziguc5i001mnps6ccgfakl3","_id":"ciziguc6n002znps6gqp3upx9"}],"Tag":[{"name":"MySql","_id":"ciziguc3x0001nps6hysi2a6a"},{"name":"Wiring-Beans","_id":"ciziguc4e0005nps6ho4gwb06"},{"name":"Concurrency","_id":"ciziguc4i000anps6xbzteqt9"},{"name":"Thread","_id":"ciziguc4j000bnps6x13mu357"},{"name":"Synchronizer","_id":"ciziguc4j000dnps6a289k6yg"},{"name":"Synchronization","_id":"ciziguc4o000jnps6xguixps8"},{"name":"NIO","_id":"ciziguc4r000pnps6tf7cmkhf"},{"name":"个人计划","_id":"ciziguc4u000tnps6qxpxskkf"},{"name":"Liveness","_id":"ciziguc4x000ynps6ls8h9x0y"},{"name":"Lambda","_id":"ciziguc520014nps6byhbwcp9"},{"name":"Java8","_id":"ciziguc520015nps6bkgw6tlp"},{"name":"Channel","_id":"ciziguc58001anps6n530uiyd"},{"name":"ThreadPool","_id":"ciziguc5d001inps6zw82ixkj"},{"name":"JDBC","_id":"ciziguc5i001mnps6ccgfakl3"},{"name":"Srping-MVC","_id":"ciziguc5m001qnps6xyjydnho"},{"name":"Eclipse","_id":"ciziguc5q001tnps6egwuvj7a"},{"name":"IO","_id":"ciziguc5t001xnps6xrwrtccs"},{"name":"Aggregate-Operation","_id":"ciziguc610025nps6wyfsue4v"},{"name":"Stream","_id":"ciziguc610026nps6v907aymb"},{"name":"spring","_id":"ciziguc63002cnps66h3wyvxf"},{"name":"mvc","_id":"ciziguc64002dnps6e0o684zu"},{"name":"MySQL","_id":"ciziguc67002jnps6etjnqnq2"},{"name":"http_rewrite","_id":"ciziguc6b002pnps68imy1226"},{"name":"logback","_id":"ciziguc6g002unps6annndbd4"}]}}