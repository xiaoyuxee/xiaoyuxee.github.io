<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[子善]]></title>
  <subtitle><![CDATA[假装是个程序员]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.xiaoyuxee.com/"/>
  <updated>2016-02-06T19:45:54.000Z</updated>
  <id>http://www.xiaoyuxee.com/</id>
  
  <author>
    <name><![CDATA[Xiaoyu Xee]]></name>
    <email><![CDATA[smallrain.xuxy@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Java8中的Stream]]></title>
    <link href="http://www.xiaoyuxee.com/2016/02/06/aggregate-operation-in-java8/"/>
    <id>http://www.xiaoyuxee.com/2016/02/06/aggregate-operation-in-java8/</id>
    <published>2016-02-06T06:41:16.000Z</published>
    <updated>2016-02-06T19:45:54.000Z</updated>
    <content type="html"><![CDATA[<p>Java8中为集合类<code>Collection</code>引入了新的特性：流<code>Stream</code>，使得基于集合的操作更加简洁、直观。为了更好的理解<code>Stream</code>，需要对Lambda表达式和方法引用有一定的认知，参见前一篇Note：<a href="http://www.xiaoyuxee.com/2016/02/05/lambda-in-java8/">Java8中的Lambda表达式</a>。</p>
<a id="more"></a>
<h2 id="u5F15_u5B50"><a href="#u5F15_u5B50" class="headerlink" title="引子"></a>引子</h2><p>当我们遍历一个集合并进行打印时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Person p : persons) &#123;</span><br><span class="line">    System.out.println(p.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>Stream</code>、Lambda表达式后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">persons</span><br><span class="line">    .stream()</span><br><span class="line">    .forEach(p -&gt; System.out.println(p.getName()));</span><br></pre></td></tr></table></figure>
<h2 id="u6D41Stream"><a href="#u6D41Stream" class="headerlink" title="流Stream"></a>流<code>Stream</code></h2><p>流<code>Stream</code>指的是一系列元素，但不像集合<code>Collection</code>，它不是用来存储元素的数据结构，而是通过管道（pipeline）而携带元素。通过集合中的<code>java.util.Collection.stream()</code>方法可以获得。</p>
<h2 id="u7BA1_u9053pipeline"><a href="#u7BA1_u9053pipeline" class="headerlink" title="管道pipeline"></a>管道pipeline</h2><p>管道（pipeline）指的是一系列的集成操作。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">persons</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(p -&gt; p.getAge() &gt;= <span class="number">18</span>)</span><br><span class="line">    .forEach(p -&gt; System.out.println(p.getName()));</span><br></pre></td></tr></table></figure>
<p>管道一般由以下几部分组成：</p>
<ul>
<li>来源：可能是集合、数组、生成函数或者I/O管道。</li>
<li>中间操作：比如过滤器<code>filter</code>，产生一个新的管道（pipeline）</li>
<li>终止操作：比如<code>forEach</code>。</li>
</ul>
<p>比如，统计<em>年龄≥18岁的person的平均年龄</em>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">persons</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(p -&gt; p.getAge() &gt;= <span class="number">18</span>)</span><br><span class="line">    .mapToInt(Person::getAge)</span><br><span class="line">    .average()</span><br><span class="line">    .getAsDouble();</span><br></pre></td></tr></table></figure>
<p>上例中，<code>mapToInt</code>操作产生了一个类型为<code>IntStream</code>的新流，包换所有<em>年龄≥18岁的person的年龄流</em>。</p>
<p><code>average</code>操作将计算<code>IntStream</code>中所有元素的平均值。JDK中提供了很多类似<code>average</code>终止操作，组合流中内容并返回一个值。这类操作叫做<a href="http://docs.oracle.com/javase/tutorial/collections/streams/reduction.html" target="_blank" rel="external">reduction</a>。</p>
<h2 id="Reduction"><a href="#Reduction" class="headerlink" title="Reduction"></a><code>Reduction</code></h2><p>类似于<code>average</code>，统计流Stream中内容而返回一个值，还有<code>sum</code>、<code>min</code>、<code>max</code>、<code>count</code>。此外，JDK还提供返回集合的终止操作。</p>
<p>当然，JDK还提供了更加通用的<code>reduce</code>和<code>collect</code>方法。</p>
<h3 id="reduce_u65B9_u6CD5"><a href="#reduce_u65B9_u6CD5" class="headerlink" title="reduce方法"></a><code>reduce</code>方法</h3><p>例如，我们要统计<em>年龄≥18岁的person的年龄之和</em>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">persons</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(p -&gt; p.getAge() &gt;= <span class="number">18</span>)</span><br><span class="line">    .mapToInt(Person::getAge)</span><br><span class="line">    .sum();</span><br></pre></td></tr></table></figure>
<p>这里用到了<code>sum</code>终结操作，计算所有<code>IntStream</code>中内容之和。如果使用<code>reduce</code>则可以这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">persons</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(p -&gt; p.getAge() &gt;= <span class="number">18</span>)</span><br><span class="line">    .mapToInt(Person::getAge)</span><br><span class="line">    .reduce(<span class="number">0</span>, Math::addExact);</span><br></pre></td></tr></table></figure>
<p>查询<code>sum</code>源码可以发现，其实也是如此：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于<code>reduce</code>有三个方法：</p>
<h4 id="Optional_26lt_3BT_26gt_3B_reduce_28BinaryOperator_26lt_3BT_26gt_3B_accumulator_29__u7528_u4E8E_u5BFB_u627E_u6700_u5927_u503C_u3001_u6700_u5C0F_u503C_u7B49"><a href="#Optional_26lt_3BT_26gt_3B_reduce_28BinaryOperator_26lt_3BT_26gt_3B_accumulator_29__u7528_u4E8E_u5BFB_u627E_u6700_u5927_u503C_u3001_u6700_u5C0F_u503C_u7B49" class="headerlink" title="Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator) 用于寻找最大值、最小值等"></a><code>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</code> 用于寻找最大值、最小值等</h4><h4 id="T_reduce_28T_identity_2C_BinaryOperator_26lt_3BT_26gt_3B_accumulator_29__u9002_u5408_u4E8E_u6709_u7D2F_u52A0_u884C_u4E3A"><a href="#T_reduce_28T_identity_2C_BinaryOperator_26lt_3BT_26gt_3B_accumulator_29__u9002_u5408_u4E8E_u6709_u7D2F_u52A0_u884C_u4E3A" class="headerlink" title="T reduce(T identity, BinaryOperator&lt;T&gt; accumulator) 适合于有累加行为"></a><code>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code> 适合于有累加行为</h4><p><code>reduce</code>操作包含两个参数：</p>
<ul>
<li>标识：reduce操作的初始化值以及默认值（如果流中没有元素）</li>
<li>累加器：累加器包含两个参数：requce操作的<em>部分结果和下一个流中内容的值</em>，然后返回一个新的局部结果。</li>
</ul>
<p><code>reduce</code>操作时，累加器每次都返回一个新的值。假如你的操作是返回一个更加复杂的对象，比如集合，那么就需要为你的程序担忧了。因为其效率是非常低的，正确的做法是<em>更新已经存在的集合</em>。这就是<code>collect</code>方法。</p>
<h3 id="collect_u65B9_u6CD5"><a href="#collect_u65B9_u6CD5" class="headerlink" title="collect方法"></a><code>collect</code>方法</h3><p>假如你要收集所有<em>年龄≥18岁的person的人名</em>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">persons</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(p -&gt; p.getAge() &gt;= <span class="number">18</span>)</span><br><span class="line">    .map(Person::getName)</span><br><span class="line">    .collect(ArrayList::<span class="keyword">new</span>, ArrayList::add, ArrayList::addAll);</span><br></pre></td></tr></table></figure>
<p><code>collect</code>有两个方法：</p>
<h4 id="R_collect__28Supplier_26lt_3BR_26gt_3B_2C_BiConsumer_26lt_3BR_2C__3F_super_T_26gt_3B_2C_BiConsumer_26lt_3BR_2C_R_26gt_3B_29"><a href="#R_collect__28Supplier_26lt_3BR_26gt_3B_2C_BiConsumer_26lt_3BR_2C__3F_super_T_26gt_3B_2C_BiConsumer_26lt_3BR_2C_R_26gt_3B_29" class="headerlink" title="R collect (Supplier&lt;R&gt;, BiConsumer&lt;R, ? super T&gt;, BiConsumer&lt;R, R&gt;)"></a><code>R collect (Supplier&lt;R&gt;, BiConsumer&lt;R, ? super T&gt;, BiConsumer&lt;R, R&gt;)</code></h4><ul>
<li>第一个参数Supplier：用于初始化返回结果</li>
<li>第二个参数BiConsumer： 用于操作<em>部分结果与下一个流内容</em></li>
<li>第二个参数BiConsumer： 用于<em>合并操作</em></li>
</ul>
<h4 id="26lt_3BR_2C_A_26gt_3B_R_collect_28Collector_26lt_3B_3F_super_T_2C_A_2C_R_26gt_3B_collector_29"><a href="#26lt_3BR_2C_A_26gt_3B_R_collect_28Collector_26lt_3B_3F_super_T_2C_A_2C_R_26gt_3B_collector_29" class="headerlink" title="&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector)"></a><code>&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector)</code></h4><p><code>Collector</code>将上述<em>初始化</em>、<em>部分接口与下一个流内容操作</em>、<em>合并</em>封装了起来，并且在<code>java.util.stream.Collectors</code>中提供了一些常用的collector，如<code>toList</code>、<code>toSet</code>等。</p>
<p>上述收集所有<em>年龄≥18岁的person的人名</em>的例子可以改写为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">persons</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(p -&gt; p.getAge() &gt;= <span class="number">18</span>)</span><br><span class="line">    .map(Person::getName)</span><br><span class="line">    .collect(Collectors.toList()));</span><br></pre></td></tr></table></figure>
<p><code>Collectors.groupingBy(classifier)</code>用于分组，返回一个key为<code>classifier</code>分类的标准，value为ArrayList的Map。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">persons</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(Collectors.groupingBy(Person::getGender)));</span><br></pre></td></tr></table></figure>
<p>如果要将persons按性别分组，返回其name：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">persons</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(Collectors.groupingBy(</span><br><span class="line">            Person::getGender,</span><br><span class="line">            Collectors.mapping(Person::getName, Collectors.toList()))));</span><br></pre></td></tr></table></figure>
<p>如果要将persons按性别分组，返回每组的年龄总数/年龄最大值/平均年龄：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 年龄和</span></span><br><span class="line">persons</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(Collectors.groupingBy(</span><br><span class="line">            Person::getGender,</span><br><span class="line">            Collectors.mapping(</span><br><span class="line">                    Person::getAge, </span><br><span class="line">                    Collectors.reducing(<span class="number">0</span>, Math::addExact)))));</span><br><span class="line"><span class="comment">// 年龄和</span></span><br><span class="line">persons</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(Collectors.groupingBy(</span><br><span class="line">            Person::getGender,</span><br><span class="line">            Collectors.reducing(<span class="number">0</span>, Person::getAge, Math::addExact))));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 年龄最大值</span></span><br><span class="line">persons</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(Collectors.groupingBy(</span><br><span class="line">            Person::getGender,</span><br><span class="line">            Collectors.mapping(</span><br><span class="line">                    Person::getAge, </span><br><span class="line">                    Collectors.reducing(Math::max)))));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 年龄平均值</span></span><br><span class="line">persons</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(Collectors.groupingBy(</span><br><span class="line">            Person::getGender,</span><br><span class="line">            Collectors.averagingInt(Person::getAge))));</span><br></pre></td></tr></table></figure>
<h2 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h2><p><a href="http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html" target="_blank" rel="external">http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Java8中为集合类<code>Collection</code>引入了新的特性：流<code>Stream</code>，使得基于集合的操作更加简洁、直观。为了更好的理解<code>Stream</code>，需要对Lambda表达式和方法引用有一定的认知，参见前一篇Note：<a href="http://www.xiaoyuxee.com/2016/02/05/lambda-in-java8/">Java8中的Lambda表达式</a>。</p>]]>
    
    </summary>
    
      <category term="Aggregate-Operation" scheme="http://www.xiaoyuxee.com/tags/Aggregate-Operation/"/>
    
      <category term="Java8" scheme="http://www.xiaoyuxee.com/tags/Java8/"/>
    
      <category term="Stream" scheme="http://www.xiaoyuxee.com/tags/Stream/"/>
    
      <category term="Java-Core" scheme="http://www.xiaoyuxee.com/categories/Java-Core/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java8中的Lambda表达式]]></title>
    <link href="http://www.xiaoyuxee.com/2016/02/05/lambda-in-java8/"/>
    <id>http://www.xiaoyuxee.com/2016/02/05/lambda-in-java8/</id>
    <published>2016-02-04T16:43:08.000Z</published>
    <updated>2016-02-08T02:30:34.000Z</updated>
    <content type="html"><![CDATA[<p>Lambda表达式是Java8引进的新特性，用一句话概括为：<em>更紧凑的表达仅有一个方法的接口实例</em>。</p>
<a id="more"></a>
<h2 id="Lambda_u8868_u8FBE_u5F0F_u5982_u4F55_u800C_u6765"><a href="#Lambda_u8868_u8FBE_u5F0F_u5982_u4F55_u800C_u6765" class="headerlink" title="Lambda表达式如何而来"></a>Lambda表达式如何而来</h2><p>我们在日常编程中经常会遇到只有一个方法的接口，如<code>Runnable</code>，只有一个<code>void run()</code>方法。在Java8之前是不支持接口中的方法带有默认实现的，所以在Java8中，Lambda表达式更准确得讲为：<em>更紧凑的表达仅有一个抽象方法的接口实例</em>，因为Jaba8中可以有<a href="http://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html" target="_blank" rel="external">默认实现的方法</a>和<a href="http://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html#static" target="_blank" rel="external">静态方法</a>。</p>
<p>特别地，在使用策略模式时，经常会使用匿名类来实现某个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, Operation operator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> operator.calculate(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"1 + 2 = "</span> + calculate(<span class="number">1</span>, <span class="number">2</span>, <span class="keyword">new</span> Operation()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在引入Lambda表达式之后，上面的例子就可改写为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"1 + 2 = "</span> + calculate(<span class="number">1</span>, <span class="number">2</span>, (a, b) -&gt; a + b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>较之前的匿名类而言，更加简洁、直观、紧凑。</p>
<h2 id="Lambda_u8868_u8FBE_u5F0F_u7684_u8BED_u6CD5"><a href="#Lambda_u8868_u8FBE_u5F0F_u7684_u8BED_u6CD5" class="headerlink" title="Lambda表达式的语法"></a>Lambda表达式的语法</h2><p>一个Lambda表达式由以下几部分组成：</p>
<ul>
<li><p>一个在闭合圆括号中用逗号分隔的参数列表。<br>如：<code>calculate(1, 3, (int a, int b) -&gt; a + b)</code>。<br><em>Note</em>：在Lambda表达式中，<em>可以省略数据类型</em>。此外，<em>如果仅有一个参数时，也可以将圆括号省略</em>：<code>a -&gt; a.foo()</code>。</p>
</li>
<li><p><code>-&gt;</code></p>
</li>
<li><p>表达体：一个单独的表达式 或者 区块。<br>如：<code>a &gt; 0 &amp;&amp; b &gt;0</code> 或者 <code>{ return a &gt; 0 &amp;&amp; b &gt; 0; }</code>。当然，如果返回值为<code>void</code>时，完全没必要写成后者形式。</p>
</li>
</ul>
<h2 id="JDK_u5BF9Lambda_u8868_u8FBE_u5F0F_u7684_u652F_u6301"><a href="#JDK_u5BF9Lambda_u8868_u8FBE_u5F0F_u7684_u652F_u6301" class="headerlink" title="JDK对Lambda表达式的支持"></a>JDK对Lambda表达式的支持</h2><p>Java8中引入注释<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html" target="_blank" rel="external">FunctionalInterface</a>，用于标识功能性接口<a href="http://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html#package.description" target="_blank" rel="external"></a>。</p>
<p>在<code>java.util.function</code>包中提供了大量的通用功能性接口：<code>Function</code>、<code>Consumer</code>、<code>Predicate</code>：</p>
<ul>
<li><code>Function</code>：<code>R apply(T t)</code></li>
<li><code>Consumer</code>：<code>void accept(T t)</code></li>
<li><code>Predicate</code>：<code>boolean test(T t)</code></li>
<li><code>Supplier</code>：<code>T get()</code></li>
</ul>
<p>还包括一些指定数据类型的<code>ToIntFunction</code>、<code>LongConsumer</code>等。</p>
<p>使用JDK中提供的标准接口可以将上例改写为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, ToIntBiFunction&lt;Integer, Integer&gt; operator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> operator.applyAsInt(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"1 + 2 = "</span> + calculate(<span class="number">1</span>, <span class="number">2</span>, (a, b) -&gt; a + b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Lambda_u8868_u8FBE_u5F0F_u7684_u76EE_u6807_u7C7B_u578B"><a href="#Lambda_u8868_u8FBE_u5F0F_u7684_u76EE_u6807_u7C7B_u578B" class="headerlink" title="Lambda表达式的目标类型"></a>Lambda表达式的目标类型</h2><p>Java编译器会通过调用时的上下文或者Lambda表达式的位置来决定其表达式的类型。</p>
<p>例如，当你自己定义一个相同功能的功能性接口进行使用时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, Operation operator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> operator.calculate(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>(a, b) -&gt; a + b)</code>的类型为<code>Operation</code>，当你使用JDK提供的标准接口时类型为：<code>ToIntBiFunction</code>。</p>
<h3 id="u76EE_u6807_u7C7B_u578B_u548C_u65B9_u6CD5_u53C2_u6570"><a href="#u76EE_u6807_u7C7B_u578B_u548C_u65B9_u6CD5_u53C2_u6570" class="headerlink" title="目标类型和方法参数"></a>目标类型和方法参数</h3><p>比如下面两个可调用的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    r.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">invoke</span><span class="params">(Callable&lt;T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c.call();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当执行 <code>String s = invoke(() -&gt; &quot;done&quot;);</code> 时，调用的方法为 <code>invoke(Callable&lt;T&gt; c)</code>，因为这个方法返回了值。所有Lambda表达式的类型为<code>Callable&lt;T&gt;</code>。</p>
<h2 id="u672C_u5730_u53D8_u91CF_u7684_u8BBF_u95EE"><a href="#u672C_u5730_u53D8_u91CF_u7684_u8BBF_u95EE" class="headerlink" title="本地变量的访问"></a>本地变量的访问</h2><p>Lambda表达式中并不会产生一个新的局部变量，所以你不能再表达式的参数列表中包含上一次的局部变量，但是你可以在表达体中直接使用这些的变量。</p>
<p>当然，同内部类、匿名类一样，这些被Lambda表达式使用的变量必须是<code>final</code>类型，否则编译器会提示你：</p>
<blockquote>
<p>local variables referenced from a lambda expression must be final or effectively final。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Lambda expression's parameter a cannot redeclare another local variable  </span></span><br><span class="line">    <span class="comment">// defined in an enclosing scope.</span></span><br><span class="line">    <span class="comment">// int a = 0;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">    System.out.println(<span class="string">"1 + 2 = "</span> + calculate(<span class="number">1</span>, <span class="number">2</span>, (a, b) -&gt; a + b + c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u65B9_u6CD5_u5F15_u7528"><a href="#u65B9_u6CD5_u5F15_u7528" class="headerlink" title="方法引用"></a>方法引用</h2><p>还是上面的例子：计算两个数字之和。<code>java.lang.Math</code>中提供了相关api：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">addExact</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = x + y;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (((x ^ r) &amp; (y ^ r)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException(<span class="string">"integer overflow"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以上述例子可以改写为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"1 + 2 = "</span> + calculate(<span class="number">1</span>, <span class="number">3</span>, </span><br><span class="line">        <span class="keyword">new</span> ToIntBiFunction&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">applyAsInt</span><span class="params">(Integer t, Integer u)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Math.addExact(t, u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br></pre></td></tr></table></figure>
<p>此处的功能接口中实际上调用的是<code>addExact</code>方法，Java8中支持方法的引用，可以写得更简洁 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"1 + 2 = "</span> + calculate(<span class="number">1</span>, <span class="number">3</span>, Math::addExact));</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>Lambda表达式是Java8引进的新特性，用一句话概括为：<em>更紧凑的表达仅有一个方法的接口实例</em>。</p>]]>
    
    </summary>
    
      <category term="Java8" scheme="http://www.xiaoyuxee.com/tags/Java8/"/>
    
      <category term="Lambda" scheme="http://www.xiaoyuxee.com/tags/Lambda/"/>
    
      <category term="Java-Core" scheme="http://www.xiaoyuxee.com/categories/Java-Core/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Wiring Beans In Spring]]></title>
    <link href="http://www.xiaoyuxee.com/2016/01/30/wiring-beans-in-spring/"/>
    <id>http://www.xiaoyuxee.com/2016/01/30/wiring-beans-in-spring/</id>
    <published>2016-01-29T16:43:26.000Z</published>
    <updated>2016-02-08T02:28:37.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://martinfowler.com/articles/injection.html" target="_blank" rel="external">控制反转和依赖注入</a>是Spring的核心功能，也是其他模块的基石。Spring容器控制着bean的生命周期，并维护其之间的依赖关系。如何在容器中装配（配置）这些bean是学习Spring的基础。</p>
<p>本文将介绍如何在Spring4.0中进行bean的装配，及每种方式的特点。</p>
<a id="more"></a>
<h2 id="u81EA_u52A8_u88C5_u914D_uFF08Automatically_uFF09"><a href="#u81EA_u52A8_u88C5_u914D_uFF08Automatically_uFF09" class="headerlink" title="自动装配（Automatically）"></a>自动装配（Automatically）</h2><p><code>@ComponentScan</code>：用于指定扫描路径，将所有带有注解<code>@Component</code>的类注册到ioc容器中进行管理。也可以通过XML类配置<code>&lt;context:component-scan&gt;</code>。</p>
<ul>
<li><code>basePackages</code>：当没有指定扫描的包名时，默认扫描当前配置所在的包</li>
<li><code>basePackageClasses</code>：使用<code>basePackages</code>可能会遇到一个问题：重构包名时，扫描将会失效。那么我们可以指定扫描类所在的包。有个技巧为：<em>在预想扫描的包里创建一个标记类，用于标记扫描的包</em>。</li>
</ul>
<p><code>@Component</code>：用于说明该类将会注册到ioc容器中。</p>
<ul>
<li>id：当没有指定id时，id为首字母小写的类名，如：beanFactory，当类为BeanFactory时。</li>
<li><code>@Named</code>：与<code>@Component</code>有同样的功效，它是<a href="https://jcp.org/en/jsr/detail?id=330" target="_blank" rel="external">Dependency Injection for Java</a>中的规范。<em>不建议使用</em>，因为其语义很差劲。</li>
</ul>
<p><code>@AutoWired</code>：告诉ioc容器，帮其自动解决（某方法）的依赖关系。</p>
<ul>
<li>使用范围：适用于构造函数、以及其他任何函数。</li>
<li><code>Inject</code>：同<code>@AutoWired</code>。</li>
</ul>
<h2 id="Java_u4EE3_u7801_u88C5_u914D_uFF08Java-based_uFF09"><a href="#Java_u4EE3_u7801_u88C5_u914D_uFF08Java-based_uFF09" class="headerlink" title="Java代码装配（Java-based）"></a>Java代码装配（Java-based）</h2><p>虽然自动装配非常的诱人，简介而高效，但有些场景却无法适用。比如，当依赖一些第三方的jar包时，我们没有源码，没有办法为他们添加类似于<code>@Component</code>的注解，那我们必须在配置中明确指定依赖关系。</p>
<p><code>Configuration</code>：表示此类为配置文件，其中包含将要注册到容器中的Bean。</p>
<p><code>Bean</code>：表示此方法将会返回一个对象，并需要将其注册到容器中进行管理。</p>
<ul>
<li>id：默认id为<em>方法名</em>，当然也可以显式的指定：<code>name=&quot;foo&quot;</code>。</li>
<li>依赖关系：可以通过调用通一个配置里的方法，或者构造函数解决（不在同一个配置项中时）。</li>
</ul>
<h2 id="XML_u6587_u4EF6_u88C5_u914D_uFF08XML_uFF09"><a href="#XML_u6587_u4EF6_u88C5_u914D_uFF08XML_uFF09" class="headerlink" title="XML文件装配（XML）"></a>XML文件装配（XML）</h2><p>XML文件配置Spring历史悠久，Spring刚面世时就是基于XML来配置bean，甚至在大多数人眼中有这样的观念：spring就是XML配置。</p>
<h2 id="Java-based_with_xml"><a href="#Java-based_with_xml" class="headerlink" title="Java-based with xml"></a>Java-based with xml</h2><p>使用java-based配置时，可以引入别的java-based配置以及xml配置：</p>
<ul>
<li><code>@Import</code>：引入其他java-based配置</li>
<li><code>@ImportResource</code>：引入xml配置</li>
</ul>
<p><code>注意</code>：这里的xml必须要携带完整的路径（包括包路径），<br>如：<code>@ImportResource(&quot;classpath:/com/osceola/soundsystem/cd-config.xml&quot;)</code></p>
<h2 id="Xml_with_java-based"><a href="#Xml_with_java-based" class="headerlink" title="Xml with java-based"></a>Xml with java-based</h2><p>在使用xml配置时，同样可以引入别的xml配置和java-based配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">import</span> <span class="attribute">resource</span>=<span class="value">"config.xml"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"Config"</span> /&gt;</span> <span class="comment">&lt;!-- 想配置bean一样将java-based类配置进来 --&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="u63A8_u8350"><a href="#u63A8_u8350" class="headerlink" title="推荐"></a>推荐</h2><p><code>Automatically</code> &gt; <code>Java-based</code> &gt; <code>XML</code></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://martinfowler.com/articles/injection.html">控制反转和依赖注入</a>是Spring的核心功能，也是其他模块的基石。Spring容器控制着bean的生命周期，并维护其之间的依赖关系。如何在容器中装配（配置）这些bean是学习Spring的基础。</p>
<p>本文将介绍如何在Spring4.0中进行bean的装配，及每种方式的特点。</p>]]>
    
    </summary>
    
      <category term="Wiring-Beans" scheme="http://www.xiaoyuxee.com/tags/Wiring-Beans/"/>
    
      <category term="Spring" scheme="http://www.xiaoyuxee.com/categories/Spring/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java应用中的数据库访问]]></title>
    <link href="http://www.xiaoyuxee.com/2016/01/24/database-access-in-java/"/>
    <id>http://www.xiaoyuxee.com/2016/01/24/database-access-in-java/</id>
    <published>2016-01-24T05:56:04.000Z</published>
    <updated>2016-02-08T01:56:38.000Z</updated>
    <content type="html"><![CDATA[<p>早起对数据库的访问，都是直接调用数据库厂商提供的专有API。<a href="https://zh.wikipedia.org/zh-cn/ODBC" target="_blank" rel="external">ODBC(Open Database Connectivity)</a>是微软开放服务结构（WOSA，Windows Open Service Architecture）中有关数据库的一部分，提供了Windows下统一的数据库访问方式。使用者只需要调用ODBC API，由ODBC驱动程序将调用请求转化为对特定数据库的调用请求。</p>
<p>Java语言问世后，Sun公司与1996年推出了<a href="https://zh.wikipedia.org/zh-cn/Java%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5" target="_blank" rel="external">JDBC(Java Database Connectivity)</a>，提供了对数据库访问的统一方式。JDBC是一套标准的访问关系数据库的Java类库，同时为数据库厂商提供了一个标准的API，让厂商为自己的数据库产品提供相应的JDBC驱动程序。应用程序调用JDBC API，由JDBC驱动程序（具体数据库厂商的实现层）处理与数据库的通信，从而使应用程序与具体数据库产品解耦。</p>
<a id="more"></a>
<h2 id="u52A0_u8F7D_u6CE8_u518C_u6570_u636E_u5E93_u9A71_u52A8"><a href="#u52A0_u8F7D_u6CE8_u518C_u6570_u636E_u5E93_u9A71_u52A8" class="headerlink" title="加载注册数据库驱动"></a>加载注册数据库驱动</h2><h3 id="Drive_u63A5_u53E3"><a href="#Drive_u63A5_u53E3" class="headerlink" title="Drive接口"></a>Drive接口</h3><p><code>javax.sql.Driver</code>是所有JDBC驱动程序需要实现的接口。</p>
<p>其中，<code>connect(url, info)</code>方法用于建立到数据到的连接。而在实际的应用程序中，不需要直接调用此方法，而是通过JDBC驱动程序管理器<code>DriverManager</code>注册相应的驱动程序，使用驱动管理器来建立数据库连接。</p>
<h3 id="u52A0_u8F7D_u6CE8_u518CJDBC_u9A71_u52A8"><a href="#u52A0_u8F7D_u6CE8_u518CJDBC_u9A71_u52A8" class="headerlink" title="加载注册JDBC驱动"></a>加载注册JDBC驱动</h3><p>加载JDBC驱动通过<code>Class.forName(String className)</code>在CLASSPATH中定位、加载驱动类。</p>
<p>注册JDBC驱动实例则是通过<code>Driver.registerDriver(Driver driver)</code>来完成。通常，不需要我们亲自去注册，因为实现了<code>Driver</code>的驱动类都包含一个静态区，调用驱动管理器的静态方法来注册自己的一个实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Driver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// Required for Class.forName().newInstance()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u5EFA_u7ACB_u5230_u6570_u636E_u5E93_u7684_u8FDE_u63A5"><a href="#u5EFA_u7ACB_u5230_u6570_u636E_u5E93_u7684_u8FDE_u63A5" class="headerlink" title="建立到数据库的连接"></a>建立到数据库的连接</h2><p>通过<code>DriverManager.getConnection(String url, String user, String password)</code>建立到数据库的连接（代理给相应的驱动程序）</p>
<h3 id="JDBC_URL"><a href="#JDBC_URL" class="headerlink" title="JDBC URL"></a>JDBC URL</h3><p><code>jdbc:subprotocol:subname</code>：</p>
<ul>
<li>协议：jdbc，唯一允许的协议</li>
<li>子协议：标识一个数据库驱动程序，如mysql、sqlserver</li>
<li>子名称：与具体数据库驱动有关，如mysql中：jdbc:mysql://localhost:3306/database</li>
</ul>
<h2 id="u6570_u636E_u5E93_u8BBF_u95EE"><a href="#u6570_u636E_u5E93_u8BBF_u95EE" class="headerlink" title="数据库访问"></a>数据库访问</h2><p>数据库访问通过建立的连接的来访问，有3种方式<code>Statement</code>、<code>PreparedStatement</code>、<code>CallableStatement</code>。</p>
<h3 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h3><p>用于执行静态的SQL语句，通过<code>Connection.createStatement()</code>来创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Statement</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 执行查询语句 */</span></span><br><span class="line">    <span class="function">ResultSet <span class="title">executeQuery</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 用于执行INSERT、UPDATE、DELETE等语句 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 通过`addBatch()`批量添加sql命令，然后一起执行 */</span></span><br><span class="line">    <span class="keyword">int</span>[] executeBatch() <span class="keyword">throws</span> SQLException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h3><p><code>ResultSet</code>以<em>逻辑表格</em>封装了数据库执行结果，由数据库厂商来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResultSet</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 将游标移动到下一行，如果该行有数据返回`true`，否则返回`false` */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 通过索引（1开始）查看某列数据 **/</span></span><br><span class="line">    <span class="function">String <span class="title">getString</span><span class="params">(<span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 通过列名称查看某列数据 **/</span></span><br><span class="line">    <span class="function">String <span class="title">getString</span><span class="params">(String columnLabel)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h3><p>sql语句在执行以前需要预编译，包括语句分析、代码优化等。如果仅仅是参数不同的sql语句，可以使用<code>PreparedStatement</code>。</p>
<h3 id="ResultSetMetaData"><a href="#ResultSetMetaData" class="headerlink" title="ResultSetMetaData"></a>ResultSetMetaData</h3><p>用于描述数据库表结构的元数据， <code>ResultSet.getMetaData()</code></p>
<h2 id="u4E8B_u52A1_u5904_u7406"><a href="#u4E8B_u52A1_u5904_u7406" class="headerlink" title="事务处理"></a>事务处理</h2><ul>
<li>脏读（dirty read）<br>一个事务对数据进行了修改，但没有提交，与此同时另外一个事务读取了被修改的数据。如若前一个事务发生回滚，那么后一个事务读取的数据也就是无效数据。</li>
<li>不可重复读（non-repeatable read）<br>一个事务读取了一行数据，在事务结束以前另外一个事务对这行数据进行了修改，那么当前一个事务再次读取那部分数据时，得到了不同的数据。</li>
<li>幻读（phantom read）<br>一个事务查询某条件下的数据，事务结束之前另外一个事务又插入一些满足条件的数据，那么当第一个事务再次查询时发现数据多出几行。</li>
</ul>
<h3 id="Connection_u4E2D_u5173_u4E8E_u4E8B_u52A1_u9694_u79BB_u7EA7_u522B_u7684_u5E38_u91CF"><a href="#Connection_u4E2D_u5173_u4E8E_u4E8B_u52A1_u9694_u79BB_u7EA7_u522B_u7684_u5E38_u91CF" class="headerlink" title="Connection中关于事务隔离级别的常量"></a><code>Connection</code>中关于事务隔离级别的常量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Connection</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 不支持事务 */</span></span><br><span class="line">    <span class="keyword">int</span> TRANSACTION_NONE             = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 允许脏读 */</span></span><br><span class="line">    <span class="keyword">int</span> TRANSACTION_READ_UNCOMMITTED = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 不允许脏读，但允许不可重复我和幻读 */</span></span><br><span class="line">    <span class="keyword">int</span> TRANSACTION_READ_COMMITTED   = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 不允许脏读、不可重复读，但允许幻读 */</span></span><br><span class="line">    <span class="keyword">int</span> TRANSACTION_REPEATABLE_READ  = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 脏读、不可重复读、幻读均不允许 */</span></span><br><span class="line">    <span class="keyword">int</span> TRANSACTION_SERIALIZABLE     = <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mysql默认级别为：<code>TRANSACTION_READ_COMMITTED</code>, 禁止脏读、不可重复读。</p>
<p>而事务默认为<em>自动提交</em>，可通过<code>Connection.setAutoCommit(false)</code>来重置，自行提交（commit）或回滚（rollback）。</p>
<h2 id="JDBC_u6570_u636E_u6E90_u548C_u8FDE_u63A5_u6C60"><a href="#JDBC_u6570_u636E_u6E90_u548C_u8FDE_u63A5_u6C60" class="headerlink" title="JDBC数据源和连接池"></a>JDBC数据源和连接池</h2><p>对数据库的访问除了加载、实例化驱动程序并通过驱动程序管理器获得连接外，还可通过<code>DataSource</code>来实现（由数据库厂商实现）。</p>
<h3 id="u4EC0_u4E48_u662F_u8FDE_u63A5_u6C60"><a href="#u4EC0_u4E48_u662F_u8FDE_u63A5_u6C60" class="headerlink" title="什么是连接池"></a>什么是连接池</h3><p>建立数据库连接的成本是很大的，并且一个数据库服务器能够同时建立的连接数是有限的。在web应用中可能同时会有成千上万个访问数据库的请求，如果为每个请求创建一个数据库连接，性能将急剧下降。为了能够<em>重复利用数据库连接</em>，提高对请求的响应时间和服务器性能，于是诞生了数据库连接池。</p>
<p>数据库连接池预先建立了一些数据库连接，然后保存到连接池中，当有访问数据库的请求时，从池中取出一个闲置的连接对象完成对数据的访问，请求结束后将连接对象放回池中。</p>
<p>调用物理连接的<code>close</code>方法将关闭连接，而连接池的连接的<code>close</code>方法为释放连接对象放回连接池中。</p>
<p>大部分servlet容器都支持基于JNDI的数据库连接池的配置，如<a href="http://tomcat.apache.org/tomcat-9.0-doc/jndi-datasource-examples-howto.html" target="_blank" rel="external">Tomcat</a>，<a href="http://www.eclipse.org/jetty/documentation/current/jndi-datasource-examples.html" target="_blank" rel="external">Jetty</a>。</p>
<h3 id="u8FDE_u63A5_u6C60_u5B9E_u73B0"><a href="#u8FDE_u63A5_u6C60_u5B9E_u73B0" class="headerlink" title="连接池实现"></a>连接池实现</h3><ul>
<li><a href="http://commons.apache.org/proper/commons-dbcp/" target="_blank" rel="external">Apache Commons DBCP</a></li>
<li><a href="http://sourceforge.net/projects/c3p0/" target="_blank" rel="external">c3p0</a></li>
<li><a href="https://github.com/wwadge/bonecp" target="_blank" rel="external">bonecp</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>早起对数据库的访问，都是直接调用数据库厂商提供的专有API。<a href="https://zh.wikipedia.org/zh-cn/ODBC">ODBC(Open Database Connectivity)</a>是微软开放服务结构（WOSA，Windows Open Service Architecture）中有关数据库的一部分，提供了Windows下统一的数据库访问方式。使用者只需要调用ODBC API，由ODBC驱动程序将调用请求转化为对特定数据库的调用请求。</p>
<p>Java语言问世后，Sun公司与1996年推出了<a href="https://zh.wikipedia.org/zh-cn/Java%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5">JDBC(Java Database Connectivity)</a>，提供了对数据库访问的统一方式。JDBC是一套标准的访问关系数据库的Java类库，同时为数据库厂商提供了一个标准的API，让厂商为自己的数据库产品提供相应的JDBC驱动程序。应用程序调用JDBC API，由JDBC驱动程序（具体数据库厂商的实现层）处理与数据库的通信，从而使应用程序与具体数据库产品解耦。</p>]]>
    
    </summary>
    
      <category term="JDBC" scheme="http://www.xiaoyuxee.com/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac下高效地使用Eclipse]]></title>
    <link href="http://www.xiaoyuxee.com/2016/01/17/coding-effectively-with-eclipse-on-mac/"/>
    <id>http://www.xiaoyuxee.com/2016/01/17/coding-effectively-with-eclipse-on-mac/</id>
    <published>2016-01-17T11:04:43.000Z</published>
    <updated>2016-01-24T13:14:35.000Z</updated>
    <content type="html"><![CDATA[<blockquote><p>工欲善其事，必先利其器。</p>
<footer><strong>孔子，论语·卫灵公</strong></footer></blockquote>
<p><a href="http://www.eclipse.org/" target="_blank" rel="external">Eclipse</a>想必是很多同学每天接触的IDE，那么熟练使用eclipse中的快捷键，对每天coding效率的提升将会带来显著的提示。</p>
<a id="more"></a>
<h2 id="u6587_u4EF6_u4E0E_u5DE5_u7A0B_u7BA1_u7406"><a href="#u6587_u4EF6_u4E0E_u5DE5_u7A0B_u7BA1_u7406" class="headerlink" title="文件与工程管理"></a>文件与工程管理</h2><p><code>command</code>+<code>N</code>：新建文件/工程<br><code>command</code>+<code>shift</code>+<code>R</code>：快速打开文件，支持<code>?</code>、<code>*</code>匹配<br><code>command</code>+<code>I</code>：打开文件属性<br><code>option</code>+<code>I</code>：打开文件属性<br><code>command</code>+<code>S</code>：保存当前文件<br><code>command</code>+<code>shift</code>+<code>S</code>：保存所有文件<br><code>command</code>+<code>W</code>：关闭当前文件<br><code>command</code>+<code>shift</code>+<code>W</code>：关闭所有文件<br><code>F5</code>：从本地文件系统刷新资源</p>
<h2 id="u7F16_u8F91_u7A97_u53E3"><a href="#u7F16_u8F91_u7A97_u53E3" class="headerlink" title="编辑窗口"></a>编辑窗口</h2><p><code>command</code>+<code>shift</code>+<code>[</code>：返回上一个编辑的文件<br><code>command</code>+<code>shift</code>+<code>]</code>：返回下一个编辑的文件<br><code>control</code>+<code>M</code>：最大化/最小化当前窗口<br><code>command</code>+<code>E</code>：在打开的文件列表中切换<br><code>command</code>+<code>L</code>：跳至指定行</p>
<h2 id="u7F16_u8F91_u6587_u4EF6"><a href="#u7F16_u8F91_u6587_u4EF6" class="headerlink" title="编辑文件"></a>编辑文件</h2><p><code>command</code>+<code>C</code>：复制<br><code>command</code>+<code>X</code>：剪切<br><code>command</code>+<code>V</code>：黏贴<br><code>command</code>+<code>Z</code>：取消上步操作<br><code>command</code>+<code>shift</code>+<code>Z</code>：重新执行上步被取消的操作<br><code>command</code>+<code>D</code>：删除当前这一行<br><code>option</code>+<code>Arrow Up</code>/<code>Arrow Down</code>：向上/向下<em>移动</em>当前行或者当前选择的区块<br><code>command</code>+<code>option</code>+<code>Arrow Up</code>/<code>Arrow Down</code>：向上/向下<em>复制</em>当前行或者当前选择的区块<br><code>command</code>+<code>delete</code>：删除上一个单词<br><code>shift</code>+<code>enter</code>：在下一行插入编辑<br><code>command</code>+<code>shift</code>+<code>enter</code>：在上一行插入编辑<br><code>command</code>+<code>shift</code>+<code>X</code>：将选择区块全部变为大写<br><code>command</code>+<code>shift</code>+<code>Y</code>：将选择区块全部变为小写</p>
<h2 id="u641C_u7D22_u548C_u66FF_u6362"><a href="#u641C_u7D22_u548C_u66FF_u6362" class="headerlink" title="搜索和替换"></a>搜索和替换</h2><p><code>command</code>+<code>F</code>：打开<em>查找和替换</em>对话框<br><code>control</code>+<code>H</code>：在工作区间中搜索（java、task、file等）<br><code>control</code>+<code>J</code>：输入内容后，<em>正向</em>查找字符串<br><code>command</code>+<code>shift</code>+<code>J</code>：输入内容后，<em>反向</em>查找字符串</p>
<h2 id="u4EE3_u7801_u7F16_u8F91"><a href="#u4EE3_u7801_u7F16_u8F91" class="headerlink" title="代码编辑"></a>代码编辑</h2><p><code>command</code>+<code>I</code>：修正当前选择区块的缩进<br><code>command</code>+<code>shift</code>+<code>F</code>：格式化代码<br><code>command</code>+<code>/</code>：注释/取消注释当前行<br><code>command</code>+<code>control</code>+<code>/</code>：添加块注释<code>/* ... */</code><br><code>command</code>+<code>control</code>+<code>\</code>：取消块注释<br><code>command</code>+<code>option</code>+<code>J</code>：增加元素注释<code>/** ... *</code><br><code>command</code>+<code>1</code>：快速修复<br><code>command</code>+<code>shift</code>+<code>M</code>：增加<code>import</code><br><code>command</code>+<code>shift</code>+<code>O</code>：组织包<code>import</code><br><code>option</code>+<code>/</code>：代码提示</p>
<h2 id="u4EE3_u7801_u4FE1_u606F"><a href="#u4EE3_u7801_u4FE1_u606F" class="headerlink" title="代码信息"></a>代码信息</h2><p><code>command</code>+<code>O</code>：快速查看代码结构<br><code>command</code>+<code>T</code>：快速查看类型继承<br><code>command</code>+<code>shift</code>+<code>T</code>：搜索查看类<br><code>F2</code>：查看类、方法、变量注释说明<br><code>F3</code>：跳至类、方法、变量声明处<br><code>F4</code>：在类型继承窗口（视图）中打开<br><code>control</code>+<code>option</code>+<code>H</code>：查看类、方法调用层次<br><code>command</code>+<code>shift</code>+<code>U</code>：在当前类中查找表达式出现的地方<br><code>command</code>+move over method：打开方法声明或则实现</p>
<h2 id="u91CD_u6784"><a href="#u91CD_u6784" class="headerlink" title="重构"></a>重构</h2><p><code>control</code>+<code>option</code>+<code>R</code>：类、方法、变量等重命名<br><code>control</code>+<code>option</code>+<code>V</code>：方法移动<br><code>control</code>+<code>option</code>+<code>M</code>：抽取方法<br><code>control</code>+<code>option</code>+<code>L</code>：抽取本地变量<br><code>control</code>+<code>option</code>+<code>I</code>：内联收拢变量</p>
<h2 id="u8C03_u8BD5_u4E0E_u8FD0_u884C"><a href="#u8C03_u8BD5_u4E0E_u8FD0_u884C" class="headerlink" title="调试与运行"></a>调试与运行</h2><p><code>command</code>+<code>F11</code>：Run<br><code>shift</code>+<code>command</code>+<code>B</code>：设置断点<br><code>F5</code>：单步进入<br><code>F6</code>：下一行<br><code>F7</code>：跳出，进行下一步<br><code>F8</code>：调至下一个断点</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.shortcutworld.com/en/win/Eclipse.html" target="_blank" rel="external">Eclipse Shortcuts </a><br><a href="http://blog.csdn.net/jmyue/article/details/16960199" target="_blank" rel="external">玩转Eclipse — 快捷键设置及汇总</a><br><a href="http://www.codeaffine.com/2012/11/26/working-efficiently-with-junit-in-eclipse-2/" target="_blank" rel="external">Working Efficiently with JUnit in Eclipse</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote><p>工欲善其事，必先利其器。</p>
<footer><strong>孔子，论语·卫灵公</strong></footer></blockquote>
<p><a href="http://www.eclipse.org/">Eclipse</a>想必是很多同学每天接触的IDE，那么熟练使用eclipse中的快捷键，对每天coding效率的提升将会带来显著的提示。</p>]]>
    
    </summary>
    
      <category term="Eclipse" scheme="http://www.xiaoyuxee.com/tags/Eclipse/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Servlet3.0中配置DispatcherServlet]]></title>
    <link href="http://www.xiaoyuxee.com/2016/01/16/config-diapatcher-servlet-with-servlet3.0/"/>
    <id>http://www.xiaoyuxee.com/2016/01/16/config-diapatcher-servlet-with-servlet3.0/</id>
    <published>2016-01-15T16:08:30.000Z</published>
    <updated>2016-02-08T02:33:48.000Z</updated>
    <content type="html"><![CDATA[<p>大家都知道<code>DispatcherServelt</code>是 <em>spring-mvc</em> 中的前端控制器。按照传统的方式，可以在<code>web.xml</code>中配置这个 <em>servlet</em> 。</p>
<p>而在 <em>Servlet 3.0</em> 以后，支持通过注解配置 <em>servlet</em>、<em>listener</em>、<em>filter</em>等，同时也支持以注解方式配置<em>servlet container</em>，达到与配置<code>web.xml</code>一样的效果。</p>
<p>这篇文章主要介绍下<em>如何在Servlet 3.0下以 Java-Code 配置Servlet Container以及Dispatcher Servlet</em>。</p>
<a id="more"></a>
<h2 id="u4F20_u7EDFweb-xml_u4E2D_u5B9A_u4E49Servlet"><a href="#u4F20_u7EDFweb-xml_u4E2D_u5B9A_u4E49Servlet" class="headerlink" title="传统web.xml中定义Servlet"></a>传统web.xml中定义Servlet</h2><p>通过<code>web.xml</code>来配置一个web应用时，一般是这样子的：</p>
<figure class="highlight xml"><figcaption><span>code.1-web.xml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">web-app</span> <span class="attribute">xmlns</span>=<span class="value">"http://java.sun.com/xml/ns/javaee"</span> <span class="attribute">version</span>=<span class="value">"2.5"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>/WEB-INF/spring/dispatcher-config.xml<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="title">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="ServletContainerInitializer"><a href="#ServletContainerInitializer" class="headerlink" title="ServletContainerInitializer"></a>ServletContainerInitializer</h2><p>Servlet 3.0中，定义了一个接口：<code>javax.servlet.ServletContainerInitializer</code>，在Servlet 3.0下，将会在 <em>classpath</em> 下寻找该接口的实现，然后以此来配置Servlet Container。</p>
<blockquote>
<p>Implementations of this interface may be annotated with <code>HandlesTypes</code>, in order to receive (at their <code>onStartup</code> method) the Set of application classes that implement, extend, or have been annotated with the class types specified by the annotation. </p>
<p>Implementations of this interface must be declared by a JAR file resource located inside the <code>META-INF/services</code> directory and named for the fully qualified class name of this interface, and will be discovered using the runtime’s service provider lookup mechanism or a container specific mechanism that is semantically equivalent to it.</p>
</blockquote>
<p>通过其注释不难得知：</p>
<ol>
<li>被<code>@HandlesTypes</code>注解的接口的 <em>实现</em> 将被以参数的方式传给其方法 <code>onStartup</code></li>
<li>具体实现必须在JAR包的Spring中的 <em>META-INF/services</em> 下声明其实现。它的运行时发现机制其实是通过<code>ServiceLoader</code>实现的，具体参考官方文档<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html#Service_Provider" target="_blank" rel="external">Service Provider</a></li>
</ol>
<h2 id="SpringServletContainerInitializer"><a href="#SpringServletContainerInitializer" class="headerlink" title="SpringServletContainerInitializer"></a>SpringServletContainerInitializer</h2><h3 id="provider_u58F0_u660E"><a href="#provider_u58F0_u660E" class="headerlink" title="provider声明"></a>provider声明</h3><p>在 <em>spring-web</em> 包下的 <em>META-INF/services</em> 中定义有：</p>
<figure class="highlight"><figcaption><span>code.2-javax.servlet.ServletContainerInitializer</span></figcaption><table><tr><td class="code"><pre><span class="line">org.springframework.web.SpringServletContainerInitializer</span><br></pre></td></tr></table></figure>
<h3 id="u63A5_u53E3_u5B9A_u4E49"><a href="#u63A5_u53E3_u5B9A_u4E49" class="headerlink" title="接口定义"></a>接口定义</h3><figure class="highlight java"><figcaption><span>SpringServletContainerInitializer.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="annotation">@HandlesTypes</span>(WebApplicationInitializer.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringServletContainerInitializer</span> <span class="keyword">implements</span> <span class="title">ServletContainerInitializer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="onStartup__u5177_u4F53_u5B9E_u73B0"><a href="#onStartup__u5177_u4F53_u5B9E_u73B0" class="headerlink" title="onStartup 具体实现"></a>onStartup 具体实现</h3><figure class="highlight java"><figcaption><span>code.3-SpringServletContainerInitializer.onStartup</span></figcaption><table><tr><td class="code"><pre><span class="line">List&lt;WebApplicationInitializer&gt; initializers = <span class="keyword">new</span> LinkedList&lt;WebApplicationInitializer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (webAppInitializerClasses != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; waiClass : webAppInitializerClasses) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// servlet container传入的参数均为具体实现，而非接口或抽象类</span></span><br><span class="line">        <span class="keyword">if</span> (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers())</span><br><span class="line">            &amp;&amp; WebApplicationInitializer.class.isAssignableFrom(waiClass)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                initializers.add((WebApplicationInitializer) waiClass.newInstance());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"Failed to instantiate WebApplicationInitializer class"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 Servlet Context</span></span><br><span class="line"><span class="keyword">for</span> (WebApplicationInitializer initializer : initializers) &#123;</span><br><span class="line">    initializer.onStartup(servletContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u901A_u8FC7java_code_u521D_u59CB_u5316Servlet_Context"><a href="#u901A_u8FC7java_code_u521D_u59CB_u5316Servlet_Context" class="headerlink" title="通过java code初始化Servlet Context"></a>通过java code初始化Servlet Context</h2><p>初始化 <em>Servlet Context</em> 的工作其实是委托给了<code>WebApplicationInitializer</code>的实现类，那么我们就可以自定义其实现过程，如：</p>
<figure class="highlight java"><figcaption><span>code.4-MyWebAppInitializer.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebAppInitializer</span> <span class="keyword">implements</span> <span class="title">WebApplicationInitializer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(ServletContext container)</span> </span>&#123;</span><br><span class="line">        XmlWebApplicationContext appContext = <span class="keyword">new</span> XmlWebApplicationContext();</span><br><span class="line">        appContext.setConfigLocation(<span class="string">"/WEB-INF/spring/dispatcher-config.xml"</span>);</span><br><span class="line"></span><br><span class="line">        ServletRegistration.Dynamic dispatcher = </span><br><span class="line">        container.addServlet(<span class="string">"dispatcher"</span>, <span class="keyword">new</span> DispatcherServlet(appContext));</span><br><span class="line"></span><br><span class="line">        dispatcher.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        dispatcher.addMapping(<span class="string">"/"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们就完全取代了<code>web.xml</code>。但是，还是<code>/WEB-INF/spring/dispatcher-config.xml</code>还是XML配置，能否也用 <em>Java-Code</em> 替代呢？</p>
<p>答案是肯定的，因为Spring 3.0就支持通过注解<code>@Configuration</code>来实现以往通过XML形式配置的工作了：</p>
<figure class="highlight java"><figcaption><span>code.5-MyWebAppInitializer.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebAppInitializer</span> <span class="keyword">implements</span> <span class="title">WebApplicationInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(ServletContext container)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Create the 'root' Spring application context</span></span><br><span class="line">        AnnotationConfigWebApplicationContext rootContext =</span><br><span class="line">        <span class="keyword">new</span> AnnotationConfigWebApplicationContext();</span><br><span class="line">        rootContext.register(AppConfig.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Manage the lifecycle of the root application context</span></span><br><span class="line">        container.addListener(<span class="keyword">new</span> ContextLoaderListener(rootContext));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the dispatcher servlet's Spring application context</span></span><br><span class="line">        AnnotationConfigWebApplicationContext dispatcherContext =</span><br><span class="line">        <span class="keyword">new</span> AnnotationConfigWebApplicationContext();</span><br><span class="line">        dispatcherContext.register(DispatcherConfig.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Register and map the dispatcher servlet</span></span><br><span class="line">        ServletRegistration.Dynamic dispatcher =</span><br><span class="line">        container.addServlet(<span class="string">"dispatcher"</span>, <span class="keyword">new</span> DispatcherServlet(dispatcherContext));</span><br><span class="line">        dispatcher.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        dispatcher.addMapping(<span class="string">"/"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>以上的demo仅为简单实现，那么Spring中又是如何设计的呢？</p>
<h2 id="Spring_u4E2D_u5982_u4F55_u8BBE_u8BA1"><a href="#Spring_u4E2D_u5982_u4F55_u8BBE_u8BA1" class="headerlink" title="Spring中如何设计"></a>Spring中如何设计</h2><p>分析<code>code.5</code>，其实变化的、需要用户具体指定的内容有3块：</p>
<ol>
<li>rootConfig：根容器配置</li>
<li>dispatcherConfig：dispatcher配置</li>
<li>mapping：dispatcherServlet匹配规则</li>
</ol>
<ul>
<li>AbstractContextLoaderInitializer</li>
</ul>
<figure class="highlight java"><figcaption><span>code.6-AbstractContextLoaderInitializer.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractContextLoaderInitializer</span> <span class="keyword">implements</span> <span class="title">WebApplicationInitializer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(ServletContext servletContext)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        registerContextLoaderListener(servletContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerContextLoaderListener</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">        WebApplicationContext rootAppContext = createRootApplicationContext();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注册root ApplicationContext</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> WebApplicationContext <span class="title">createRootApplicationContext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> ApplicationContextInitializer&lt;?&gt;[] getRootApplicationContextInitializers() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>AbstractDispatcherServletInitializer</li>
</ul>
<figure class="highlight java"><figcaption><span>code.7-AbstractDispatcherServletInitializer.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDispatcherServletInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractContextLoaderInitializer</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(ServletContext servletContext)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStartup(servletContext);</span><br><span class="line"></span><br><span class="line">        registerDispatcherServlet(servletContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerDispatcherServlet</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">        WebApplicationContext servletAppContext = createServletApplicationContext();</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> WebApplicationContext <span class="title">createServletApplicationContext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> ApplicationContextInitializer&lt;?&gt;[] getServletApplicationContextInitializers() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizeRegistration</span><span class="params">(ServletRegistration.Dynamic registration)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户自定义Url匹配规则</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> String[] getServletMappings();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>AbstractAnnotationConfigDispatcherServletInitializer</li>
</ul>
<figure class="highlight java"><figcaption><span>code.8-AbstractAnnotationConfigDispatcherServletInitializer.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span></span><br><span class="line">        <span class="keyword">extends</span> <span class="title">AbstractDispatcherServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createRootApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// create root ApplicationContext</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createServletApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// create servlet ApplicationContext</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定root ApplicationContext配置文件</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Class&lt;?&gt;[] getRootConfigClasses();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定servlet ApplicationContext配置文件</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Class&lt;?&gt;[] getServletConfigClasses();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u6700_u7EC8_u914D_u7F6E"><a href="#u6700_u7EC8_u914D_u7F6E" class="headerlink" title="最终配置"></a>最终配置</h2><figure class="highlight java"><figcaption><span>code.9-WebAppInitializer.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebAppInitializer</span> </span><br><span class="line">    <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[] &#123; RootConfig.class &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[] &#123; WebConfig.class &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123; <span class="string">"/"</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>大家都知道<code>DispatcherServelt</code>是 <em>spring-mvc</em> 中的前端控制器。按照传统的方式，可以在<code>web.xml</code>中配置这个 <em>servlet</em> 。</p>
<p>而在 <em>Servlet 3.0</em> 以后，支持通过注解配置 <em>servlet</em>、<em>listener</em>、<em>filter</em>等，同时也支持以注解方式配置<em>servlet container</em>，达到与配置<code>web.xml</code>一样的效果。</p>
<p>这篇文章主要介绍下<em>如何在Servlet 3.0下以 Java-Code 配置Servlet Container以及Dispatcher Servlet</em>。</p>]]>
    
    </summary>
    
      <category term="Srping-MVC" scheme="http://www.xiaoyuxee.com/tags/Srping-MVC/"/>
    
      <category term="Spring" scheme="http://www.xiaoyuxee.com/categories/Spring/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我的二〇一五]]></title>
    <link href="http://www.xiaoyuxee.com/2016/01/11/My-2015/"/>
    <id>http://www.xiaoyuxee.com/2016/01/11/My-2015/</id>
    <published>2016-01-11T15:47:00.000Z</published>
    <updated>2016-01-12T16:15:49.000Z</updated>
    <content type="html"><![CDATA[<p>2015就这样过去了，而且是已经过去了11天。一直想着要认真制定下新年计划，然后记录下来，因为方向是什么比当下在做什么更重要。前几天却因为博客迟迟没有迁移过来而纠结年度计划记录在哪里… 现在博客基本达到了自己想要的样子，也该把年度计划给落地了。</p>
<p>有人说，没有回顾的计划都是自欺欺人。貌似很有稻梨，于是就静静地坐下来回顾这匆匆过去的又一年。</p>
<a id="more"></a>
<h2 id="u5F15_u5B50"><a href="#u5F15_u5B50" class="headerlink" title="引子"></a>引子</h2><p>其实我2015年是没有做年度计划的。</p>
<p>只记得那个2014年的最后一个晚上，心潮澎湃地说要跨年，新年第一天一定不能贪睡。于是第二天就起了个早直奔<a href="https://zh.wikipedia.org/zh-cn/%E5%AE%9D%E7%9F%B3%E5%B1%B1" target="_blank" rel="external">宝石山</a>看日出，无奈在高架上错过西湖大道的出口不得不到下个出口掉头重新上高架… 更无奈的是再次错过保俶路的停车场… 于是整个行程就耽误了半个多小时，上山的时候看见别人已经开始下山了。但却丝毫没有影响我的心情，因为我还是来了。站在<a href="https://zh.wikipedia.org/zh-cn/%E4%BF%9D%E4%BF%B6%E5%A1%94" target="_blank" rel="external">保俶塔</a>旁边的小山上，望着苏堤倾斜的穿过整个西湖，心中在想：我的2015应该如何度过。</p>
<p>然后最后还是没有产出一些像样的新年计划，只是在脑海中时不时浮现出那些清晰又模糊的计划或者目标。</p>
<h2 id="u56DE_u987E"><a href="#u56DE_u987E" class="headerlink" title="回顾"></a>回顾</h2><p>现在还能回忆起或者顺利地回忆起过去的一年，功劳归功于<a href="http://www.feidee.com/money/" target="_blank" rel="external">随手记</a>。因为某些原因，去年的记账还是坚持了下来（除去1、2月份，春节过后开始的）。以每个月的开销为主线，不免想起很多无从想起的事情。</p>
<ul>
<li><p><em>个人感情</em><br>将近一年的感情告一段落。离开是为了成全让对方遇到更好的彼此。坚信每一个人都有自己的优点和缺点，也肯定会有另外一个人来欣赏你、包容你然后陪你走到最后。所以没有走到最后只是因为彼此还不是那个对的人。不后悔遇见，只愿你找到那个合适的他。</p>
</li>
<li><p><em>身体健康</em><br>拖了很久，终于还是把种牙提上了日程并且经过3个月的折腾可以正常吃饭了（虽然早已不习惯，早年不用右边吃饭了…），这算今年蛮大的收获之一吧，因为有这个想法已经将近一年了。<br>健身卡一张，健身次数 <em>&lt;8</em> 次，游泳次数 <em>&lt;10</em> 次：后面因为某些原因（狗狗、感情等因素），被搁浅了…</p>
</li>
<li><p><em>财务收支</em><br>春节过后坚持记账，对自己的支出有了明确的认识。而收入明年需要跟上。<br>不完全统计全年支出<a href="/">25W+</a>，其中生活开销<a href="/">11W+</a>（以上数据均不包含1、2月份…）<br>在收支平衡上比上一年有进步。<em>这点应该是2015的最大收获吧。</em></p>
</li>
<li><p><em>远足旅行</em><br>4月份港澳游，10月份台湾行：也算把我天朝的三个未接壤的地方给去了。收获良多，感受他乡风情的同时，更加内心的目标更加清晰，坚定。<br>大于12次杭州周边游：最喜欢的是<a href="https://zh.wikipedia.org/zh-cn/%E8%8E%AB%E5%B9%B2%E5%B1%B1" target="_blank" rel="external">德清·莫干山</a>，最失望的是<a href="/">半山·仙人谷</a></p>
</li>
<li><p><em>阅读清单</em><br>买了很多书、读了很多书但全部读完且印象深刻的有<a href="http://www.books.com.tw/products/0010675560" target="_blank" rel="external">《慢慢來 人生就會不一樣》</a>、<a href="http://www.books.com.tw/products/0010687284" target="_blank" rel="external">《跳槽法則》</a>（两本书都是从台湾带回来的）。<br>两个书架已经快装不下，上周末去宜家买了个书架，书架促销性价比极高（开森ing…）。</p>
</li>
<li><p><em>休闲娱乐</em><br>电影院：12+<br>聚餐/下馆子：48+</p>
</li>
<li><p><em>个人成长</em><br>相对前两年成长较明显的一年，但还不够，因为原本也没有年度计划，此处不展开详说。<br>这应该算是2015第二大欣慰的地方吧：渐渐明白自己努力的方向，深感时间不够用，越深入越发现自己需要掌握的东西越多。</p>
</li>
<li><p><em>数码装备</em><br><a href="http://www.apple.com/cn/macbook-air/" target="_blank" rel="external">Air</a>升级到<a href="http://www.apple.com/cn/macbook-pro/" target="_blank" rel="external">Pro</a>。陪伴了自己4年多的小A退出了舞台，希望小P在其之上更助自己一臂之力。<br>入手<a href="https://en.wikipedia.org/wiki/High_fidelity" target="_blank" rel="external">HiFi</a>，使用次数 <em>&lt;10+</em> 次。<br>入手<a href="https://www.asus.com/us/Networking/RTAC68U/" target="_blank" rel="external">RT-AC68U</a>，实现家中路由<a href="https://zh.wikipedia.org/zh-cn/%E7%AA%81%E7%A0%B4%E7%BD%91%E7%BB%9C%E5%AE%A1%E6%9F%A5" target="_blank" rel="external">科学上网</a>，全家终端自由访问<a href="https://www.facebook.com/" target="_blank" rel="external">Facebook</a>。</p>
</li>
<li><p><em>陪伴家人</em><br>春节在家中待了 <em>3</em> 天，每月平均通话：<em>30</em> 分钟<br>平均带闹闹外出远足次数：<em>1</em> 次/月<br><em>这是2015做得最差的地方</em></p>
</li>
<li><p><em>英语学习</em><br>学习次数 <em>&lt;10</em>，呵呵了…</p>
</li>
</ul>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>如果2015年可以重来，你选择怎么度过（扯蛋，所以叫如果）。</p>
<p>捡重点，具体落实到2016年计划中：</p>
<ol>
<li>个人成长：制定详细的学习计划（月计划），加强深度，分模块各个击破。</li>
<li>阅读清单：同上</li>
<li>身体健康：身体是自己的，看着办</li>
<li>英语学习：这个没得商量</li>
<li>财务收支：节流，暂不开源</li>
<li>陪伴家人：重点</li>
<li>其他：视情况待定</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>2015就这样过去了，而且是已经过去了11天。一直想着要认真制定下新年计划，然后记录下来，因为方向是什么比当下在做什么更重要。前几天却因为博客迟迟没有迁移过来而纠结年度计划记录在哪里… 现在博客基本达到了自己想要的样子，也该把年度计划给落地了。</p>
<p>有人说，没有回顾的计划都是自欺欺人。貌似很有稻梨，于是就静静地坐下来回顾这匆匆过去的又一年。</p>]]>
    
    </summary>
    
      <category term="个人计划" scheme="http://www.xiaoyuxee.com/tags/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92/"/>
    
      <category term="目标管理" scheme="http://www.xiaoyuxee.com/categories/%E7%9B%AE%E6%A0%87%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://www.xiaoyuxee.com/2016/01/10/Hello-World/"/>
    <id>http://www.xiaoyuxee.com/2016/01/10/Hello-World/</id>
    <published>2016-01-10T03:44:08.000Z</published>
    <updated>2016-01-10T16:25:29.000Z</updated>
    <content type="html"><![CDATA[<p>国际惯例：<code>Hello World</code></p>
<p>折腾了许久，从 <a href="https://wordpress.com/" target="_blank" rel="external">wordpress</a> 到 <a href="http://jekyllrb.com/" target="_blank" rel="external">jekyll</a> ，以及国人开发的 <a href="https://www.farbox.com/" target="_blank" rel="external">farbox</a>… 待最近静下来梳理思路时问自己：<em>为何折腾，有没有必要，初衷又是什么。</em></p>
<p>屡清楚之后选择了 <a href="https://hexo.io" target="_blank" rel="external">hexo</a>。</p>
<a id="more"></a>
<h2 id="u521D_u8877"><a href="#u521D_u8877" class="headerlink" title="初衷"></a>初衷</h2><ul>
<li><p>记录生活、工作中的点点滴滴<br>其实起因是工作中的一个小需求：有个页面需要反向代理到别的团队，鉴于业务统计原因，页面中的链接必须是我们的域名，同时别人的页面还可正常访问。<br>于是就将这个<code>nginx</code>文本替换的工单提给了PE（由PE统一处理，我们没有权限… ），结果PE吭哧吭哧半天没搞定，对<code>substitutions_filter_module</code>不熟悉，最后被告知“<em>自己申请权限去改，改好了由他审批发布</em>”。</p>
<p>本来就对<code>niginx</code>感兴趣，一直没有时间折腾，索性就折腾一把。自己看文档，拉代码，编译，安装，测试。整个过程还是还是蛮有意思的，也遇到了各种问题。之后就在想，能否将这些分析问题、解决问题的思路和方法记录一下，备案的同时也给别人某种程度上的参考。</p>
</li>
<li><p>适合程序员方式的记录<br>之前在本地都在使用<a href="http://www.ulyssesapp.com" target="_blank" rel="external">Ulysess</a>，一款专注于写作的软件，支持<code>Markdown</code>、<code>Dropbox</code>同步、多种文档格式的输出等。</p>
</li>
<li><p>可托管于Github<br>无须担心备份等问题。</p>
</li>
<li><p>极简<br>记录，分享。包括呈现方式，抛弃华丽的外表，不忘初心，分享内容而非炫酷的各种Blog效果。</p>
</li>
</ul>
<h2 id="u6846_u67B6_u9009_u62E9"><a href="#u6846_u67B6_u9009_u62E9" class="headerlink" title="框架选择"></a>框架选择</h2><p>最后选择<a href="https://hexo.io" target="_blank" rel="external">hexo</a>的原因也很简单，其官方定义</p>
<blockquote>
<p>  A fast, simple &amp; powerful blog framework</p>
</blockquote>
<ul>
<li><p>速度<br>基于Node.js，支持多进程，几百篇文章几秒搞定</p>
</li>
<li><p>简单</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一条日志</span></span><br><span class="line">hexo n <span class="string">"Hell World"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发布</span></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>几条简单的命令就可完成全部过程。</p>
</li>
<li><p>易扩展<br>已经有很多成熟的插件，比如同时部署到Github和Gitcafe等</p>
</li>
</ul>
<h2 id="u6A21_u677F_u9009_u62E9"><a href="#u6A21_u677F_u9009_u62E9" class="headerlink" title="模板选择"></a>模板选择</h2><p><a href="https://github.com/pagecho/maupassant" target="_blank" rel="external">maupassant</a>，简约但不简单。 官方定义：</p>
<blockquote>
<p>A simple template with great performance on different devices.</p>
</blockquote>
<p>已支持的平台：<a href="https://github.com/pagecho/maupassant/" target="_blank" rel="external">Typecho</a>, <a href="https://github.com/pagecho/mewpassant/" target="_blank" rel="external">Octopress</a>, <a href="https://github.com/pagecho/Maupassant-farbox" target="_blank" rel="external">Farbox</a>, <a href="https://github.com/iMuFeng/maupassant" target="_blank" rel="external">Wordpress</a>, <a href="https://github.com/LjxPrime/maupassant" target="_blank" rel="external">Ghost</a>, <a href="https://github.com/tufu9441/maupassant-hexo" target="_blank" rel="external">Hexo</a>。</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="external">hexo你的博客</a></li>
<li><a href="https://www.haomwei.com/technology/maupassant-hexo.html" target="_blank" rel="external">大道至简——Hexo简洁主题推荐</a></li>
<li><a href="http://theme-next.iissnan.com/" target="_blank" rel="external">NexT - an elegant theme for hexo</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>国际惯例：<code>Hello World</code></p>
<p>折腾了许久，从 <a href="https://wordpress.com/">wordpress</a> 到 <a href="http://jekyllrb.com/">jekyll</a> ，以及国人开发的 <a href="https://www.farbox.com/">farbox</a>… 待最近静下来梳理思路时问自己：<em>为何折腾，有没有必要，初衷又是什么。</em></p>
<p>屡清楚之后选择了 <a href="https://hexo.io">hexo</a>。</p>]]>
    
    </summary>
    
      <category term="生活随笔" scheme="http://www.xiaoyuxee.com/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
