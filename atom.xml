<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[子善]]></title>
  <subtitle><![CDATA[假装是个程序员]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.xiaoyuxee.com/"/>
  <updated>2016-04-16T13:00:24.000Z</updated>
  <id>http://www.xiaoyuxee.com/</id>
  
  <author>
    <name><![CDATA[Xiaoyu Xee]]></name>
    <email><![CDATA[smallrain.xuxy@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Java中的多线程（五）：ThreadPoolExecutor框架源码解析]]></title>
    <link href="http://www.xiaoyuxee.com/2016/04/07/executor-in-java-concurrency/"/>
    <id>http://www.xiaoyuxee.com/2016/04/07/executor-in-java-concurrency/</id>
    <published>2016-04-07T09:07:43.000Z</published>
    <updated>2016-04-16T13:00:24.000Z</updated>
    <content type="html"><![CDATA[<p>启动线程任务最简单的方式是：为每个任务都创建一个线程（per-task）。在没有超出服务器处理能力时，这种方法既可以提升响应速度、又可以提升吞吐量。</p>
<p>而在实际应用中，这种<em>thread-per-task</em>存在缺陷，特别是需要创建大量的线程时：</p>
<ul>
<li>线程创建的开销：线程的创建与关闭不是“免费”的</li>
<li>资源消耗量：活动的线程会消耗系统资源</li>
</ul>
<p>所以，在一定范围内，增加线程可以提高系统的吞吐量。但一旦超过这个范围，再创建更多的线程只会增加系统开销，并有可能导致应用程序崩溃。所以应该限制你的应用程序可以创建的线程数量，确保线程数达到这个极限时，程序也不至于耗尽所有资源。于是线程池应运而生。</p>
<a id="more"></a>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>Java中内置的线程池，主要通过<code>Executors</code>的静态工厂方法创建不同类型的线程池，如：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Executors</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u76F8_u5173_u7C7B_u8BBE_u8BA1"><a href="#u76F8_u5173_u7C7B_u8BBE_u8BA1" class="headerlink" title="相关类设计"></a>相关类设计</h2><h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>用于提交任务的接口：将任务的提交与任务执行细节隔离。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h3><p>线程状态/生命周期的管理接口：提交任务、关闭线程池、查询线程池状态等。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u57FA_u672C_u7ED3_u6784"><a href="#u57FA_u672C_u7ED3_u6784" class="headerlink" title="基本结构"></a>基本结构</h2><ul>
<li>corePoolSize：最小的活跃线程数</li>
<li>maximumPoolSize：最大的处理作业线程数，受限于<code>CAPACITY</code></li>
<li>workers：线程池中所有的工作线程</li>
<li>workQueue：阻塞（缓存）队列，向工作的线程传递任务</li>
<li>ctl：线程池状态(AtomicInteger)，按二进制的位数切分后包含两部分：<code>runState|workerCount</code><ul>
<li>workerCount：活跃的线程数，范围(2^29)-1，占据ctl的前28位</li>
<li>runState：线程池状态包括运行、正在关闭等，由剩下的4位组成<ul>
<li>RUNNING：接受新的任务，并且处理队列中的任务</li>
<li>SHUTDOWN：不再接受新的任务，但是会处理完队列中任务</li>
<li>STOP：不再接受新的任务，也不会处理队列中的任务，同时会中断正在执行的任务</li>
<li>TIDYING：所有任务被终止，workerCount=0。会调用<code>terminated()</code>方法</li>
<li>TERMINATED：<code>terminated()</code>方法执行完毕<br>以上这些状态是可比较的，依次递增</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="u7EBF_u7A0B_u6C60_u4E2D_u4E3B_u8981_u539F_u7406/_u673A_u5236"><a href="#u7EBF_u7A0B_u6C60_u4E2D_u4E3B_u8981_u539F_u7406/_u673A_u5236" class="headerlink" title="线程池中主要原理/机制"></a>线程池中主要原理/机制</h2><h3 id="u4EFB_u52A1_u7684_u6267_u884C_u673A_u5236"><a href="#u4EFB_u52A1_u7684_u6267_u884C_u673A_u5236" class="headerlink" title="任务的执行机制"></a>任务的执行机制</h3><p>线程的执行机制主要在<code>execute</code>方法中，任务的提交其实是封装线程后，再执行：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 构造Future</span></span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当一个线程被提交后，线程池的工作机制为：</p>
<ol>
<li>如果当前工作的线程数小于设置的核心线程数，则新建一个线程执行此任务</li>
<li>如果工作的线程数已满足核心线程数，则将任务放入用于存放待执行任务的队列中（后续会被处理）</li>
<li>如果缓存队列已满，则新建一个线程执行此任务（此时工作线程数<em>大于</em>核心线程数）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123; <span class="comment">// 如果工作线程小于核心线程池数量</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>)) <span class="comment">// 创建一个新的核心线程来处理当前任务</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; <span class="comment">// 如果线程池还在运行中，将任务添加到缓存队列</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get(); <span class="comment">// 添加到缓存队列后，仍然需要二次检查</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command)) <span class="comment">// 如果线程池关闭，删除刚刚添加的任务</span></span><br><span class="line">            reject(command); <span class="comment">// 如果成功删除，则执行任务拒绝流程</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>) <span class="comment">// 如果没有在工作的线程，需要启动一个线程来队列中任务</span></span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>); <span class="comment">// 创建一个线程来处理刚刚被加入到队列的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>)) <span class="comment">// 如果缓存队列已满，创建一个新的线程来处理当前任务</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u72B6_u6001_u4E8C_u6B21_u6821_u9A8C"><a href="#u72B6_u6001_u4E8C_u6B21_u6821_u9A8C" class="headerlink" title="状态二次校验"></a>状态二次校验</h4><p>将任务放入缓存队列后有一个二次校验：如果线程池已经关闭，那么将其从队列中剔除，并且直接执行拒绝流程。当然没有这块判断，这个任务最终也不会被执行，只是反馈被延迟了。</p>
<h3 id="u7EBF_u7A0B_u7684_u65B0_u589E_u673A_u5236"><a href="#u7EBF_u7A0B_u7684_u65B0_u589E_u673A_u5236" class="headerlink" title="线程的新增机制"></a>线程的新增机制</h3><p><code>addWorker</code>方法至关重要，因为增加工作线程总是伴随着任务的提交，新建的线程需要立刻用于执行被提交的任务：</p>
<ol>
<li>首先检查线程池状态：排除明显不需要再创建线程的场景，如线程池已经关闭则不再接受新的任务，或者正在关闭时，队列中的任务已经为空</li>
<li>然后检查线程上限，然后增加线程池中工作线程的数量</li>
<li>最后获取线程池锁，新增工作线程，<em>并将其启动</em></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数core在判断工作线程上限时使用:</span></span><br><span class="line"><span class="comment">// true:表示上限为核心线程数, false:表示上限为最大线程数.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">// 线程池非运行状态下：</span></span><br><span class="line">        <span class="comment">// 1. 非正在关闭状态：不再增加工作线程，因为已经在强制关闭或已经关闭</span></span><br><span class="line">        <span class="comment">// 2. task!=null：不再接受新的任务，但可能会创建新的线程来处理队列中任务</span></span><br><span class="line">        <span class="comment">// 3. 缓存队列为空：不需要线程线程，因为没有需要处理的任务了</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新工作线程数量：</span></span><br><span class="line">        <span class="comment">// 1. 更新机制：CAS(CompareAndSet)，确保是当前线程执行了更新</span></span><br><span class="line">        <span class="comment">// 2. 如果线程池运行状态发生变更，需要重新获取线程池状态：ctl</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 工作线程数量的上限判断</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果工作线程数量“更加”成功（n=&gt;n+1），则跳出retry，去创建线程</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line"></span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry; 线程池运行状态发生变更，需要重新获取线程池状态：ctl</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 需要创建新线程的场景：</span></span><br><span class="line">                <span class="comment">// 1. 运行状态</span></span><br><span class="line">                <span class="comment">// 2. 正在关闭并且该线程是用来处理缓存队列中任务(task=null) </span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u72B6_u6001_u53D8_u91CF_u7684_u53D8_u5316_u6CA1_u6709_u4E0A_u9501"><a href="#u72B6_u6001_u53D8_u91CF_u7684_u53D8_u5316_u6CA1_u6709_u4E0A_u9501" class="headerlink" title="状态变量的变化没有上锁"></a>状态变量的变化没有上锁</h4><ol>
<li>因为线程池的状态变量已为线程安全的，也就没有通过外部锁去控制它变化的原子性，这样将有很大的灵活性，多个线程在检查线程池状态时不存在竞争关系。但这也要求：在修改状态变量ctl时必须保证同时只有一个线程去修改它，因为它的检查与修改不具有原子性。这里用的是jvm底层<code>CAS-check and set</code>机制</li>
<li>工作线程也没有上锁，所以工作线程变更时需要获取外部锁</li>
</ol>
<h3 id="u5DE5_u4F5C_u7EBF_u7A0Bworker_u7684_u8FD0_u884C_u673A_u5236"><a href="#u5DE5_u4F5C_u7EBF_u7A0Bworker_u7684_u8FD0_u884C_u673A_u5236" class="headerlink" title="工作线程worker的运行机制"></a>工作线程worker的运行机制</h3><p>内部类<code>Worker</code>实现了<code>Runnable</code>，也是一个任务，run方法委托给了外部的<code>runWorker</code>。</p>
<ul>
<li>工作线程被启动后总是先运行第一个任务（也就是初始化工作线程时的任务）</li>
<li>如果第一个任务任务为<code>null</code>，则<em>循环</em>从缓存缓存队列中获取任务，直到队列为空</li>
<li>每次获取任务后，要检查线程池状态，必要时（线程池已关闭）及时中断该工作线程</li>
<li>缓存队列为空后，执行线程组退出流程：统计已完成的任务数量等</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="comment">// 防止工作线程处理队列中任务时发生异常，预设标记值</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 循环获取任务</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="comment">// 每次执行任务时，都需要检查线程池状态，及时中断当前线程</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>; <span class="comment">// 改工作线程工作正常，没有发生异常</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 缓存队列中已经没有任务，则可以退出了：修改线程池相关状态</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u83B7_u53D6_u7F13_u5B58_u961F_u5217_u4E2D_u4EFB_u52A1"><a href="#u83B7_u53D6_u7F13_u5B58_u961F_u5217_u4E2D_u4EFB_u52A1" class="headerlink" title="获取缓存队列中任务"></a>获取缓存队列中任务</h3><ol>
<li>检查线程池状态：如果线程池正在关闭却队列已经为空，或者线程池已关闭，修改工作线程数量，因为当前线程会自然运行结束</li>
<li>维护核心线程数量：超过核心线程后需要停掉该线程（此时已经完成工作线程的第一个任务）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">// 如果线程池正在关闭却队列已经为空，或者线程池已关闭，修改工作线程数量</span></span><br><span class="line">        <span class="comment">// 当前线程会自然运行结束</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount(); <span class="comment">// CAS机制</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处用于维护核心线程数量</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u4EFB_u52A1_u7684_u83B7_u53D6_u4E0E_u5DE5_u4F5C_u7EBF_u7A0B_u95F4_u7684_u201C_u534F_u8BAE_u201D"><a href="#u4EFB_u52A1_u7684_u83B7_u53D6_u4E0E_u5DE5_u4F5C_u7EBF_u7A0B_u95F4_u7684_u201C_u534F_u8BAE_u201D" class="headerlink" title="任务的获取与工作线程间的“协议”"></a>任务的获取与工作线程间的“协议”</h4><ul>
<li>当线程池关闭时，获取任务方法将返回<code>null</code>，并关闭工作线程。</li>
<li>当工作线程执行完首个任务后，再次获取任务时将 <em>维护核心工作线程数量</em></li>
</ul>
<h4 id="u5DE5_u4F5C_u7EBF_u7A0B_u9000_u51FA_u6D41_u7A0B"><a href="#u5DE5_u4F5C_u7EBF_u7A0B_u9000_u51FA_u6D41_u7A0B" class="headerlink" title="工作线程退出流程"></a>工作线程退出流程</h4><ol>
<li>统计线程池已完成任务数量（需要获取mainLock）</li>
<li>在工作线程组中剔除当前线程</li>
<li>尝试终止线程池</li>
<li></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前工作线程异常，需要修正工作线程数量</span></span><br><span class="line">    <span class="comment">// 因为正常情形下（队列为空后），getTask方法发现队列为空时，已经修改了工作线程数量</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn't adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试终止线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果线程池没有被关闭，则需要维持最小的工作线程数:</span></span><br><span class="line">    <span class="comment">// 允许核心工作线超时，最小数量为0，否则最小数量为预测值corePoolSize</span></span><br><span class="line">    <span class="comment">// 特例：如果最小数量为0，但队列又不为空，那修正为1（因为总要有工作的线程吧）</span></span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123; <span class="comment">// 当前工作线程正常退出时，需要判断是否有足够多的核心工作线程</span></span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程池没有关闭 且 工作线程数量小于核心工作线程数，则需要再重新启动一个线程，保持核心工作线程数</span></span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>); <span class="comment">// 线程补足</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果线程池没有被关闭，则需要维持最小的工作线程数：允许核心工作线超时，最小数量为0，否则最小数量为预测值corePoolSize。<br><em>特例</em>：如果此时最小数量为0，但队列不为空（有可能执行完队列中任务的同时，有并发线程提交了任务），那么修正为1（因为总要有工作的线程吧）</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ul>
<li>时刻检查线程池状态：</li>
<li>状态的深刻要理解，因为线程池状态的检查无处不在，也需要时刻检查：<ul>
<li>SHUTDOWN：不再接受新的任务（不再创建工作线程），但需要依次执行队列中任务<em>（特别是工作线程发生异常时，需要保证至少有1个工作线程去完成队列中任务，必须时还需重新创建工作线程）</em></li>
<li>STOP：不再处理任务，立刻中断所有工作线程</li>
</ul>
</li>
<li>CAS（campare and set）机制与原子性：<br>为了提高系统活跃度，整个框架总是先获取线程池状态：<code>c=ctl.get()</code>，然后循环<code>for(;;)</code>进行<em>compareAndSet</em>操作，确保<em>当前一系列操作的原子性</em>没有被破坏</li>
<li>mainLock：工作线程workers、已完成任务数量completedTaskCount均是非线程安全的，通过<code>ReentrantLock</code>保证其线程安全</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>启动线程任务最简单的方式是：为每个任务都创建一个线程（per-task）。在没有超出服务器处理能力时，这种方法既可以提升响应速度、又可以提升吞吐量。</p>
<p>而在实际应用中，这种<em>thread-per-task</em>存在缺陷，特别是需要创建大量的线程时：</p>
<ul>
<li>线程创建的开销：线程的创建与关闭不是“免费”的</li>
<li>资源消耗量：活动的线程会消耗系统资源</li>
</ul>
<p>所以，在一定范围内，增加线程可以提高系统的吞吐量。但一旦超过这个范围，再创建更多的线程只会增加系统开销，并有可能导致应用程序崩溃。所以应该限制你的应用程序可以创建的线程数量，确保线程数达到这个极限时，程序也不至于耗尽所有资源。于是线程池应运而生。</p>]]>
    
    </summary>
    
      <category term="Concurrence" scheme="http://www.xiaoyuxee.com/tags/Concurrence/"/>
    
      <category term="ThreadPool" scheme="http://www.xiaoyuxee.com/tags/ThreadPool/"/>
    
      <category term="Java-Core" scheme="http://www.xiaoyuxee.com/categories/Java-Core/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java中的多线程（四）：同步器]]></title>
    <link href="http://www.xiaoyuxee.com/2016/03/31/synchronizer-in-java-concurrency/"/>
    <id>http://www.xiaoyuxee.com/2016/03/31/synchronizer-in-java-concurrency/</id>
    <published>2016-03-30T16:15:18.000Z</published>
    <updated>2016-04-11T01:43:51.000Z</updated>
    <content type="html"><![CDATA[<p>多线程编程中经常会遇到线程协调问题。比如经典的生产者-消费者模式，生产者和消费者的工作需要通过一个作业队列来协调：当队列中有作业时消费者才会从队列中取出一个作业进行消费，否则将一直处于等待状态。</p>
<p>最基础的线程协调可以通过同步机制与<code>wait()</code>结合来实现：在某个对象中设置一个标记，当修改标记后通过<code>notifyAll()</code>来通知其他等待的线程。</p>
<p>幸运的是Java提供一些同步器来协调线程间的控制流。同步器内部封装了一些状态，这些状态将决定执行同步器的线程是继续执行还是等待。常用的同步器有阻塞队列（BlockingQueue）、闭锁（Latch）、信号量（Semaphore）和栅栏（Barrier）。</p>
<a id="more"></a>
<h2 id="u95ED_u9501_uFF08CountDownLatch_uFF09"><a href="#u95ED_u9501_uFF08CountDownLatch_uFF09" class="headerlink" title="闭锁（CountDownLatch）"></a>闭锁（CountDownLatch）</h2><p><a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html" target="_blank" rel="external">CountDownLatch</a>用于实现：一个或多个线程等待，直到其他线程完成某些操作。</p>
<p>CountDownLatch通过一个<code>count</code>来初始化，而<code>await()</code>方法将一直等待直到<code>count</code>的值变为0。CountDownLatch的状态无法重置。当需要重置功能时可以考虑使用栅栏<a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CyclicBarrier.html" target="_blank" rel="external">CyclicBarrier</a>。</p>
<p>CountDownLatch常常用作开关或者一扇门，使<em>所有线程在门前等待，直到门被开启</em>。可以通过闭锁来启动一组操作，或者等待一组操作的结束。郑州</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LatchTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Soldier</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch gate;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Soldier</span><span class="params">(CountDownLatch gate)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.gate = gate;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"Waiting for gate open..."</span>);</span><br><span class="line">                gate.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fight();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Fight... "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        CountDownLatch gate = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> soldierCount = <span class="number">5</span>;</span><br><span class="line">        </span><br><span class="line">        Executor executor = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;soldierCount; i++) &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Soldier(gate));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"gate opened!"</span>);</span><br><span class="line">        gate.countDown();</span><br><span class="line">        </span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u6805_u680F_uFF08Barrier_uFF09"><a href="#u6805_u680F_uFF08Barrier_uFF09" class="headerlink" title="栅栏（Barrier）"></a>栅栏（Barrier）</h2><p><a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CyclicBarrier.html" target="_blank" rel="external">Barrier</a>跟CountDownLatch类似，都能阻塞一组线程直到某个事件发生。关键区别在于：<em>CountDownLatch等待的是事件，count通过<code>countDown()</code>变为0的事件。而Barrier等待的是其他线程。</em></p>
<p>Barrier常常用在并行迭代算法中：将一个问题拆分成一系列相互独立的子问题。如果<code>await()</code>调用超时或者被阻塞的线程被中断，那么栅栏被认为是打破了，所有其他阻塞的线程终止并抛出<code>BrokenBarrierException</code>。</p>
<p>CyclicBarrier的构造函数支持传递一个Runable，当成功通过栅栏时会在一个子任务线程中执行它。</p>
<h2 id="u4FE1_u53F7_u91CF_uFF08Semaphore_uFF09"><a href="#u4FE1_u53F7_u91CF_uFF08Semaphore_uFF09" class="headerlink" title="信号量（Semaphore）"></a>信号量（Semaphore）</h2><p>计数信号量用来控制<em>同时</em>访问的某个资源的操作数量或实现某种<em>资源池</em>，如数据库连接池。</p>
<p>初始值为1的信号量可以用作互斥锁，它与内置锁类似，但不可重入。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>多线程编程中经常会遇到线程协调问题。比如经典的生产者-消费者模式，生产者和消费者的工作需要通过一个作业队列来协调：当队列中有作业时消费者才会从队列中取出一个作业进行消费，否则将一直处于等待状态。</p>
<p>最基础的线程协调可以通过同步机制与<code>wait()</code>结合来实现：在某个对象中设置一个标记，当修改标记后通过<code>notifyAll()</code>来通知其他等待的线程。</p>
<p>幸运的是Java提供一些同步器来协调线程间的控制流。同步器内部封装了一些状态，这些状态将决定执行同步器的线程是继续执行还是等待。常用的同步器有阻塞队列（BlockingQueue）、闭锁（Latch）、信号量（Semaphore）和栅栏（Barrier）。</p>]]>
    
    </summary>
    
      <category term="Concurrence" scheme="http://www.xiaoyuxee.com/tags/Concurrence/"/>
    
      <category term="Synchronizer" scheme="http://www.xiaoyuxee.com/tags/Synchronizer/"/>
    
      <category term="Thread" scheme="http://www.xiaoyuxee.com/tags/Thread/"/>
    
      <category term="Java-Core" scheme="http://www.xiaoyuxee.com/categories/Java-Core/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java中的多线程（三）：活跃度]]></title>
    <link href="http://www.xiaoyuxee.com/2016/03/16/liveness-in-java-concurrency/"/>
    <id>http://www.xiaoyuxee.com/2016/03/16/liveness-in-java-concurrency/</id>
    <published>2016-03-15T17:58:19.000Z</published>
    <updated>2016-03-30T16:34:16.000Z</updated>
    <content type="html"><![CDATA[<p>一个并发程序的及时执行能力叫做活跃度（liveness）。活跃度问题一般包括死锁（deadlock）、饥饿（starvation）和活锁（liveness）。</p>
<a id="more"></a>
<h2 id="u6B7B_u9501_uFF08deadlock_29"><a href="#u6B7B_u9501_uFF08deadlock_29" class="headerlink" title="死锁（deadlock)"></a>死锁（deadlock)</h2><p>死锁，指两个或更多的线程被永久阻塞，等待彼此进行解锁。</p>
<h2 id="u9965_u997F_uFF08starvation_uFF09"><a href="#u9965_u997F_uFF08starvation_uFF09" class="headerlink" title="饥饿（starvation）"></a>饥饿（starvation）</h2><p>饥饿，指某个线程长时间内无法获得资源而处于阻塞状态，这种现象常常是由于其他“贪婪”线程长时间占用资源导致。</p>
<h2 id="u6D3B_u9501_uFF08livelock_uFF09"><a href="#u6D3B_u9501_uFF08livelock_uFF09" class="headerlink" title="活锁（livelock）"></a>活锁（livelock）</h2><p>活锁，指一个线程的操作或响应其他线程，而其他线程又会响应另外线程，这时候可能导致活锁。活锁同样会导致程序无法进行，但跟死锁不同的是，它并没有阻塞</p>
<h2 id="u5B88_u62A4_u533A_u5757_uFF08guarded_uFF09"><a href="#u5B88_u62A4_u533A_u5757_uFF08guarded_uFF09" class="headerlink" title="守护区块（guarded）"></a>守护区块（guarded）</h2><p>线程间经常需要协调他们的活动。最常用的协调习惯就是守护区块：该区块轮询一个条件，直到满足后才会执行。</p>
<p>最常见的错误用法为：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Guarded</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 等待</span></span><br><span class="line">        <span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">"waiting..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"Run done!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">activate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGuarded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Guarded guarded = <span class="keyword">new</span> Guarded();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; guarded.run()).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; guarded.activate()).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的程序也会正常运行，但是开销是巨大的，应该那个轮询会一直进行打印“waiting…”。正确的做法是通过“等待-通知”模式：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Guarded</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">"waiting..."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待</span></span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"Run done!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">activate</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知</span></span><br><span class="line">        notify();</span><br><span class="line">        System.out.println(<span class="string">"notify..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>wait()</code>常常与<em>synchronized方法</em>一起使用，用来获取内部锁。当<em>wait</em>方法被调用时，这个线程会挂起并<em>释放内部锁</em>。当然其他线程同样可以调用此同步方法，获得内部锁并再次执行<em>wait</em>然后将自己挂起。当将来有个线程执行<code>nitifyAll()</code>时将会通知之前<em>所有</em>被挂起的线程。</p>
<p><em>注意</em>：nitifyAll并不会<em>同时</em>唤醒所有等待中的线程，因为毕竟内部锁（监视锁）只有一把，有且只有一个线程获得，然后执行剩下的操作，待退出同步方法时释放内部锁。所以应该说是其他线程依次被唤醒，但没有固定的顺序，依赖CPU的算法。（当然，也可以通过公平锁来根据线程的等待时间来依次给予内部锁，后面会讲到）</p>
<h2 id="u751F_u4EA7_u8005_u4E0E_u6D88_u8D39_u8005_u95EE_u9898"><a href="#u751F_u4EA7_u8005_u4E0E_u6D88_u8D39_u8005_u95EE_u9898" class="headerlink" title="生产者与消费者问题"></a>生产者与消费者问题</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Drop</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DONE = <span class="string">"Done"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="comment">// 注意这里的初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> empty = <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (empty) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        empty = <span class="keyword">true</span>;</span><br><span class="line">        notifyAll();</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!empty) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        empty = <span class="keyword">false</span>;</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    String dataForProduct = <span class="string">"simply retrieves the messages and prints them out"</span>;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    </span><br><span class="line">    Drop drop;</span><br><span class="line">    Producer(Drop drop) &#123;</span><br><span class="line">        <span class="keyword">this</span>.drop = drop;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String message : dataForProduct.split(<span class="string">" "</span>)) &#123;</span><br><span class="line">            drop.put(message);</span><br><span class="line">            System.out.println(<span class="string">"Product data: "</span> + message);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(random.nextInt(<span class="number">500</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        drop.put(Drop.DONE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    Drop drop;</span><br><span class="line">    Consumer(Drop drop) &#123;</span><br><span class="line">        <span class="keyword">this</span>.drop = drop;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String message = drop.take(); !message.equals(Drop.DONE); message = drop.take()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Received data : "</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Drop drop = <span class="keyword">new</span> Drop();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(drop)).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(drop)).start();</span><br><span class="line">    </span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>一个并发程序的及时执行能力叫做活跃度（liveness）。活跃度问题一般包括死锁（deadlock）、饥饿（starvation）和活锁（liveness）。</p>]]>
    
    </summary>
    
      <category term="Concurrence" scheme="http://www.xiaoyuxee.com/tags/Concurrence/"/>
    
      <category term="Liveness" scheme="http://www.xiaoyuxee.com/tags/Liveness/"/>
    
      <category term="Thread" scheme="http://www.xiaoyuxee.com/tags/Thread/"/>
    
      <category term="Java-Core" scheme="http://www.xiaoyuxee.com/categories/Java-Core/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java中的多线程（二）：同步机制]]></title>
    <link href="http://www.xiaoyuxee.com/2016/03/15/synchronization-in-java-concurrency/"/>
    <id>http://www.xiaoyuxee.com/2016/03/15/synchronization-in-java-concurrency/</id>
    <published>2016-03-15T03:32:44.000Z</published>
    <updated>2016-03-16T16:53:16.000Z</updated>
    <content type="html"><![CDATA[<p>进程中的多个线程间往往需要通信，共同完成或维护进程的目的。线程间的通信主要通过共享数据（基础类型数据，对象引用等)，这种共享数据的方式会导致两种潜在发生的错误：线程干扰（thread interference）和内存一致性错误（memory consistency errors）。而同步（synchronization）机制应运而生，用于解决上面可能出现的错误。</p>
<p>同步机制虽然可以解决线程干扰和内存一致性问题，但也可能带来其他问题：线程竞争（thread contention）。当多个线程尝试访问同一块资源时产出了竞争关系，有可能会导致线程被挂起或者死锁。</p>
<a id="more"></a>
<h2 id="u7EBF_u7A0B_u5E72_u6270"><a href="#u7EBF_u7A0B_u5E72_u6270" class="headerlink" title="线程干扰"></a>线程干扰</h2><p>线程干扰是指，别的线程会影响当前线程执行结果的正确性。<br>举个常见的栗子：<code>i++</code>。这个自增操作对应的jvm指令大概是这样：</p>
<ol>
<li>内存中获取 i 的值</li>
<li>对 i 执行 i+1 操作</li>
<li>将 i+1 写入内存</li>
</ol>
<p>如果两个线程同时对某一成员执行自增操作，考虑以下场景：两个线程同时从内存中取得相同的值，执行递增操作后，写入内存的时间发生了差异。那么后执行的线程必然覆盖提前结束线程的操作结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100000</span>; i++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">reduce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100000</span>; i++) &#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInterference</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Counter counter = <span class="keyword">new</span> Counter();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; counter.increase());</span><br><span class="line">    </span><br><span class="line">    counter.reduce();</span><br><span class="line">    </span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 断言将会失败</span></span><br><span class="line">    assertEquals(<span class="number">0</span>, counter.getCount());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u5185_u5B58_u4E00_u81F4_u6027_u95EE_u9898"><a href="#u5185_u5B58_u4E00_u81F4_u6027_u95EE_u9898" class="headerlink" title="内存一致性问题"></a>内存一致性问题</h2><p>每个线程有自己的栈，为了提供访问效率，一般会将进程中堆上的数据做一份缓存放在自己的栈上面。那么有可能在短暂时间内会导致一个线程的修改结果对另一个线程不可见。Java提供了<a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.5" target="_blank" rel="external">happens-before</a>机制来避免内存一致性问题。</p>
<h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>只有当一个写操作与读操作存在happens-before关系时，才能保证此写操作的结果对那个读操作可见。同步（synchronized）、volatile关键字、Thread.start()，Thread.join()都会建立happens-before关系。</p>
<ul>
<li>一个线程中，每个操作与当前线程中后面的操作存在happens-before关系。</li>
<li>未上锁的同步区块或方法与后面的锁定区块或方法存在happens-before关系（注意：这种关系是可以传递的）</li>
<li>一个<em>volatile</em>域的写操作与随后的读操作存在happens-before关系。</li>
<li>一个主线程与它启动的其他线程存在happens-before关系。</li>
<li>一个线程与成功join的其他线程存在happens-before关系。</li>
</ul>
<h2 id="u5185_u90E8_u9501_u4E0E_u76D1_u89C6_u5668"><a href="#u5185_u90E8_u9501_u4E0E_u76D1_u89C6_u5668" class="headerlink" title="内部锁与监视器"></a>内部锁与监视器</h2><p>同步机制的实现是通过监视器来实现：<em>Java中的每个对象都有一个可以被锁定或者解锁的监视器</em>。任何时间段里有且只可能有一个线程拥有这个监视器的锁。任何尝试对已经锁定的监视器进行再次锁定的线程都会被阻塞（当然不包括已经含有此锁的线程），直到他们获得监视器的锁。</p>
<p><em>同步语句</em>会计算对象的引用，并尝试对对象的监视器进行锁定操作，直到锁定操作成功后才会执行后面的操作。当同步内容执行完毕后，又会自动对监视器进行解锁操作。</p>
<p>当一个<em>同步方法</em>被调用时，会自动进行锁定监视器的操作，同样只有锁定操作成功后才会执行方法体内的操作。对于<em>实例方法</em>，锁定的是被调用实例的监视器。而对于<em>静态方法</em>，锁定的是被调用的<code>Class</code>对象。</p>
<p>Java中并不会避免或者检测<em>死锁条件</em>，所以应用程序必要时需要自己避免死锁。</p>
<h2 id="u540C_u6B65_u65B9_u6CD5"><a href="#u540C_u6B65_u65B9_u6CD5" class="headerlink" title="同步方法"></a>同步方法</h2><p>方法同步的影响：</p>
<ul>
<li>不允许对一个对象的两个方法交替调用。也就是说当一个线程正在执行某对象的同步方法时，其他调用改方法的线程将被阻塞或挂起，直到那个正在执行的线程执行完毕。</li>
<li>当退出同步方法时，将与随后对此方法的调用自动建立happens-before关系。保证对象状态的改变对随后的线程可见。</li>
</ul>
<p>构造方法不能用于同步，因为没有意义，为什么呢？（因为只有当前线程才能创建它）。</p>
<h2 id="u540C_u6B65_u8BED_u53E5"><a href="#u540C_u6B65_u8BED_u53E5" class="headerlink" title="同步语句"></a>同步语句</h2><p>同步方法是对整个被调用的（this）<em>实例</em>或者<em>Class</em>的监视器进行锁定，而同步语句不一定要对当前被调用的实例锁定，它可以锁定指定的对象，这将非常有帮助。比如一个类中有两个成员，foo和bar，但它们并不会同时使用。所有对它们的更新都需要同步，但并不意味着两个线程不可以交叉分别更新它们。我们可以单独对它们的监视器进行锁定，针对基本类型可以分别创建一个对象锁。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> foo;</span><br><span class="line">    <span class="keyword">private</span> Object lockForFoo = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Long bar = <span class="number">0L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increaseFoo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockForFoo) &#123;</span><br><span class="line">            foo++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increaseBar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (bar) &#123;</span><br><span class="line">            bar++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.format(<span class="string">"foo=%d, bar=%d%n"</span>, foo, bar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    MyLock lock = <span class="keyword">new</span> MyLock();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; lock.increaseFoo()).start();;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; lock.increaseBar()).start();;</span><br><span class="line">    </span><br><span class="line">    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">    lock.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u591A_u6B21_u540C_u6B65"><a href="#u591A_u6B21_u540C_u6B65" class="headerlink" title="多次同步"></a>多次同步</h2><p>大家已经知道一个线程只能等待另一个线程解锁监视器后才能调用其同步方法，那如果一个同步方法中会调用另外一个同步方法会怎样？答案是可以的，该线程已经获得了这个实例的内部锁，可以再次进入别的同步方法。</p>
<h2 id="u539F_u5B50_u8BBF_u95EE"><a href="#u539F_u5B50_u8BBF_u95EE" class="headerlink" title="原子访问"></a>原子访问</h2><p>如上所示，<code>c++</code>在多线程环境容易导致并发问题，其中一个原因为这并不是一个原子性的操作，它被分解成3个指令来执行。对于这种基本类型的增减操作，Java提供了相关的<code>Atomic</code>原子类。</p>
<p>原子操作，意味着要么被全部执行，要么什么都不执行。虽然原子操作可以避免线程干扰的问题，但是不是在多线程环境下就一定不会有线程安全问题呢？答案是否定的，因为可能导致内存不一致问题。这时<code>volatile</code>就派上用场了。所以在使用Atomic类是需要注意内存一致性问题。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>进程中的多个线程间往往需要通信，共同完成或维护进程的目的。线程间的通信主要通过共享数据（基础类型数据，对象引用等)，这种共享数据的方式会导致两种潜在发生的错误：线程干扰（thread interference）和内存一致性错误（memory consistency errors）。而同步（synchronization）机制应运而生，用于解决上面可能出现的错误。</p>
<p>同步机制虽然可以解决线程干扰和内存一致性问题，但也可能带来其他问题：线程竞争（thread contention）。当多个线程尝试访问同一块资源时产出了竞争关系，有可能会导致线程被挂起或者死锁。</p>]]>
    
    </summary>
    
      <category term="Concurrence" scheme="http://www.xiaoyuxee.com/tags/Concurrence/"/>
    
      <category term="Synchronization" scheme="http://www.xiaoyuxee.com/tags/Synchronization/"/>
    
      <category term="Thread" scheme="http://www.xiaoyuxee.com/tags/Thread/"/>
    
      <category term="Java-Core" scheme="http://www.xiaoyuxee.com/categories/Java-Core/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java中的多线程（一）：线程的基本概念和使用]]></title>
    <link href="http://www.xiaoyuxee.com/2016/03/15/base-in-java-concurrency/"/>
    <id>http://www.xiaoyuxee.com/2016/03/15/base-in-java-concurrency/</id>
    <published>2016-03-14T16:03:52.000Z</published>
    <updated>2016-03-15T17:20:24.000Z</updated>
    <content type="html"><![CDATA[<p>日常生活中常常会遇到并发场景，比如你浏览网页的同时，可能同时会受到QQ好友的消息。接下来的一些列文章将介绍如何在Java语言中进行多线程的编程。</p>
<p>本文介绍线程的一些基本概念和操作，如什么是线程，如何创建以及线程的睡眠与中断、join。</p>
<a id="more"></a>
<h2 id="u4EC0_u4E48_u662F_u8FDB_u7A0B_uFF0C_u4EC0_u4E48_u662F_u7EBF_u7A0B"><a href="#u4EC0_u4E48_u662F_u8FDB_u7A0B_uFF0C_u4EC0_u4E48_u662F_u7EBF_u7A0B" class="headerlink" title="什么是进程，什么是线程"></a>什么是进程，什么是线程</h2><p>线程有时候被叫做轻量级的进程，创建一个线程的代销远小于一个进程。线程是进程中最小的运行单元，一个进程中至少包含一个线程。线程间可以共享资源。</p>
<p>而进程通常包含一个独立的运行环境，每个进程有自己的内存空间。</p>
<h2 id="u7EBF_u7A0B_uFF08Thread_uFF09"><a href="#u7EBF_u7A0B_uFF08Thread_uFF09" class="headerlink" title="线程（Thread）"></a>线程（Thread）</h2><p>Java中每一个线程都是一个<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html" target="_blank" rel="external">Thread</a>的实例。</p>
<h3 id="u7EBF_u7A0B_u7684_u521B_u5EFA"><a href="#u7EBF_u7A0B_u7684_u521B_u5EFA" class="headerlink" title="线程的创建"></a>线程的创建</h3><h4 id="u5B9E_u73B0Runable"><a href="#u5B9E_u73B0Runable" class="headerlink" title="实现Runable"></a>实现Runable</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">HelloRunable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Hello Multithread!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreateThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> HelloRunable()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>or 使用Lambda表达式<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"Hello Multithread!"</span>)).start();</span><br></pre></td></tr></table></figure></p>
<h4 id="u7EE7_u627FThread"><a href="#u7EE7_u627FThread" class="headerlink" title="继承Thread"></a>继承Thread</h4><p><code>Thread</code>实现了<code>Runable</code>接口，所以可以覆盖它的run()方法来创建一个线程。run方法的实现为：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Runnable target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreateThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Hello Multithread!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="start_u4E0Erun"><a href="#start_u4E0Erun" class="headerlink" title="start与run"></a>start与run</h4><p>start方法有jvm实现，创建一个线程并调用run方法。而run方法只不过是Thread的一个普通方法，单独调用时也会普通的调用，仍然在主线程线程中。</p>
<h4 id="u5982_u4F55_u9009_u62E9_u521B_u5EFA_u4E00_u4E2A_u7EBF_u7A0B"><a href="#u5982_u4F55_u9009_u62E9_u521B_u5EFA_u4E00_u4E2A_u7EBF_u7A0B" class="headerlink" title="如何选择创建一个线程"></a>如何选择创建一个线程</h4><p>建议通过实现<code>Runable</code>接口：因为Java语言是不支持多继承的，如果是通过继承<code>Thread</code>来实现多线程，那么灵活性也将受到限制。</p>
<h3 id="u7EBF_u7A0B_u7761_u7720"><a href="#u7EBF_u7A0B_u7761_u7720" class="headerlink" title="线程睡眠"></a>线程睡眠</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testThreadSleep</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"Bingo..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u7EBF_u7A0B_u4E2D_u65AD"><a href="#u7EBF_u7A0B_u4E2D_u65AD" class="headerlink" title="线程中断"></a>线程中断</h3><p>Thread中的很多方法都可能抛出<code>InterruptedException</code>异常，当然也可以通过<code>interrupt</code>方法来中断某个线程，那么<em>支持线程中断</em>就很重要了。</p>
<h4 id="u652F_u6301_u7EBF_u7A0B_u4E2D_u65AD"><a href="#u652F_u6301_u7EBF_u7A0B_u4E2D_u65AD" class="headerlink" title="支持线程中断"></a>支持线程中断</h4><p>两种方式：捕捉异常 或 查询中断状态</p>
<h4 id="u7EBF_u7A0B_u7684_u4E2D_u65AD_u72B6_u6001"><a href="#u7EBF_u7A0B_u7684_u4E2D_u65AD_u72B6_u6001" class="headerlink" title="线程的中断状态"></a>线程的中断状态</h4><p>线程的中断机制是通过内部的标记来实现，也称中断状态。</p>
<p>中断线程可以通过线程的<code>interrupt</code>方法来中断当前线程。</p>
<p>查询线程的中断状态同样可以<code>Thread.interrupt</code>静态方法，也可以通过Thread类的<code>interrupted</code>方法来查询。不过这里有个需要注意的地方：<br><em>前者会清空中断状态，而后者不会</em>。</p>
<h3 id="joins"><a href="#joins" class="headerlink" title="joins"></a>joins</h3><p>Thead的<code>join</code>方法会让一个线程等待另一个线程完成。当在一个线程中调用另一个线程的<code>join</code>方法后，当前线程会停止执行后面的语句，直到另外一个线程完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread interrupt = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"sub over"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    interrupt.start();</span><br><span class="line">    <span class="comment">// interrupt.join();</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"main over"</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>运行上面这个demo，你在控制台将看不到打印”sub over”：因为主线程没有睡眠，会比子线程先运行结束。除非将注释的代码放开。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>日常生活中常常会遇到并发场景，比如你浏览网页的同时，可能同时会受到QQ好友的消息。接下来的一些列文章将介绍如何在Java语言中进行多线程的编程。</p>
<p>本文介绍线程的一些基本概念和操作，如什么是线程，如何创建以及线程的睡眠与中断、join。</p>]]>
    
    </summary>
    
      <category term="Concurrence" scheme="http://www.xiaoyuxee.com/tags/Concurrence/"/>
    
      <category term="Thread" scheme="http://www.xiaoyuxee.com/tags/Thread/"/>
    
      <category term="Java-Core" scheme="http://www.xiaoyuxee.com/categories/Java-Core/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解NIO中的Channel]]></title>
    <link href="http://www.xiaoyuxee.com/2016/03/13/in-depth-understanding-of-channel-in-nio/"/>
    <id>http://www.xiaoyuxee.com/2016/03/13/in-depth-understanding-of-channel-in-nio/</id>
    <published>2016-03-13T02:16:44.000Z</published>
    <updated>2016-04-16T07:25:53.000Z</updated>
    <content type="html"><![CDATA[<blockquote><p>A nexus for I/O operations.</p>
</blockquote>
<p>管道（<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/channels/Channel.html" target="_blank" rel="external">Channel</a>）是NIO中非常重要的概念，它直接面向缓存块，并且支持多并发环境，极大提升了I/O效率。本文将深入探讨Channel的使用及实现。</p>
<a id="more"></a>
<h2 id="Channel_u662F_u5982_u4F55_u51FA_u73B0_u7684"><a href="#Channel_u662F_u5982_u4F55_u51FA_u73B0_u7684" class="headerlink" title="Channel是如何出现的"></a>Channel是如何出现的</h2><p>Mark Reinhold在<a href="https://www.jcp.org/en/jsr/detail?id=51#2" target="_blank" rel="external">JSR-51</a>中提出：是时候在Java平台中提供一些<em>新的</em>、<em>性能提升</em>的I/O API了：</p>
<ul>
<li>The scalable I/O API will make it easier to write production-quality web and application servers that scale well to thousands of open connections and can easily take advantage of multiple processors;</li>
<li>The fast buffered binary I/O API will make it easier to write high-performance, I/O-intensive programs that manipulate streams or files of binary data;</li>
<li>The fast buffered character I/O API will simplify the efficient handling of character streams and files; it will also bring regular expressions and a compact notation for formatted output to the Java platform, putting it on a par with other popular platforms such as Perl;</li>
<li>The character-set converter API will give developers direct access the platform’s built-in character-set converters and will also provide for the easy “plugging in” of new converters;</li>
</ul>
<p>JSR-51是在JDK1.4中实现的，Channel就是其中一个非常重要的概念。</p>
<h2 id="u4EC0_u4E48_u662FChannel"><a href="#u4EC0_u4E48_u662FChannel" class="headerlink" title="什么是Channel"></a>什么是Channel</h2><p>Channel是用来连接硬件设备、文件、network socket或者具有读写操作的是实体。<br>Channel的状态有两种，要么打开状态，要么已被关闭。当Channel被创建时被打开，一旦被关闭代表<em>永久</em>处于关闭状态。Channel状态可以通过<code>isOpen</code>方法来检测。</p>
<h2 id="Channel_u7684_u7C7B_u56FE_u7ED3_u6784"><a href="#Channel_u7684_u7C7B_u56FE_u7ED3_u6784" class="headerlink" title="Channel的类图结构"></a>Channel的类图结构</h2><ul>
<li>ReadableByteChannel：可读Channel<br>ScatteringByteChannel：支持偏移读取（感觉设计过渡）</li>
<li>WritableByteChannel：可写Channel<br>GatheringByteChannel：支持偏移写入（感觉设计过渡）</li>
<li>InterruptibleChannel：可异步终端Channel</li>
<li>ByteChannel：可读写的字节Channel</li>
<li>SeekableByteChannel：继承于字节Channel，可获取/设置Channel当前的位置、当前连体实体的大小</li>
</ul>
<p><img src="/../images/Channel-class.png" alt="Channel Class Diagram"></p>
<h2 id="nio_u4E2D_u7684_u7F13_u5B58_uFF08Buffer_uFF09"><a href="#nio_u4E2D_u7684_u7F13_u5B58_uFF08Buffer_uFF09" class="headerlink" title="nio中的缓存（Buffer）"></a>nio中的缓存（Buffer）</h2><p>熟悉Channel的同学会发现它的读写操作都依赖<code>ByteBuffer</code>，可见Buffered在NIO中的重要性不言而喻。</p>
<h3 id="u57FA_u672C_u5C5E_u6027"><a href="#u57FA_u672C_u5C5E_u6027" class="headerlink" title="基本属性"></a>基本属性</h3><p>专为基本数据类型设计的缓存，主要有以下3个基本属性：</p>
<ul>
<li>容量（capacity）：缓存中元素的多少，非负且不可变。</li>
<li>哨兵（limit）：首个不可读或者不可写的元素索引值，非负且不会大于缓存容量。</li>
<li>指针（position）：下一个应该被读取或写入的索引值，非负且不会大于哨兵值。</li>
<li>重置标记位（mark）：reset辅助属性，不一定被定义，被定义时非负却不会大于指针（大于指针时将被视为无效）。</li>
</ul>
<h3 id="u57FA_u672C_u64CD_u4F5C"><a href="#u57FA_u672C_u64CD_u4F5C" class="headerlink" title="基本操作"></a>基本操作</h3><ul>
<li><code>clear</code>：哨兵（limit）设置为容器大小，并将指针（position）设置为0。</li>
<li><code>flip</code>：哨兵（limit）设置为当前位置position，并将指针（position）设置为0。</li>
<li><code>rewind</code>：哨兵(limit)不变，将指针（position）设置为0。</li>
</ul>
<p>后面两个方法比较绕，可以从以下角度理解：</p>
<h4 id="u6DF1_u5165_u7406_u89E3flip_u3001rewind"><a href="#u6DF1_u5165_u7406_u89E3flip_u3001rewind" class="headerlink" title="深入理解flip、rewind"></a>深入理解flip、rewind</h4><ul>
<li>哨兵（limit）：用于控制读取/写入缓存数据而设计的终止符，</li>
<li>指针（position）：用于控制读取/写入缓存而设计的起始符。</li>
<li>写入缓存时：<code>position = position + n</code>：n代表缓存大小。</li>
<li>读取缓存时：<code>position = limit</code>，读取的缓存块为：<code>[old_position, limit)</code></li>
<li>两者都可以通过方法自行设定，方便随机读取</li>
<li><code>flip</code>：只不过是官方提供的快捷api，方便读取从缓存块起始位置到刚刚写入位置的所有内容，也就是写入后读取前。</li>
<li><code>rewind</code>：方便读取缓存中所有数据（可能会有脏数据）</li>
<li><code>clear</code>：写入数据是充分利用缓存块大小，limit不设置也可以，但效率可能会下降<br>比如上一次读取到容量一半时调用<code>flip</code>方法，此时limit=capacity，以后写入数据时只会写入一半容量的数据。</li>
</ul>
<h4 id="byte_u4E0EBuffer_u4E4B_u95F4_u7684_u8F6C_u5316"><a href="#byte_u4E0EBuffer_u4E4B_u95F4_u7684_u8F6C_u5316" class="headerlink" title="byte与Buffer之间的转化"></a>byte与Buffer之间的转化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.wrap(<span class="string">"Hello World"</span>.getBytes());</span><br></pre></td></tr></table></figure>
<h3 id="u7EBF_u7A0B_u5B89_u5168_u95EE_u9898"><a href="#u7EBF_u7A0B_u5B89_u5168_u95EE_u9898" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><p>Buffer具有线程安全问题，在多线程下需要使用同步机制。</p>
<h2 id="Channel_u7684_u521B_u5EFA_u4E0E_u4F7F_u7528"><a href="#Channel_u7684_u521B_u5EFA_u4E0E_u4F7F_u7528" class="headerlink" title="Channel的创建与使用"></a>Channel的创建与使用</h2><p>通常通过Files的<code>newByteChanne</code>方法来实例化，不过返回类型为<code>SeekableByteChannel</code>。而在默认的文件系统中，它的实现为<code>FileSystemProvider.newByteChannel</code>，所以你可以将其转化为<code>FileChannel</code>来使用。</p>
<p>另外还可以使用<code>FileChannel.open</code>来创建。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote><p>A nexus for I/O operations.</p>
</blockquote>
<p>管道（<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/channels/Channel.html">Channel</a>）是NIO中非常重要的概念，它直接面向缓存块，并且支持多并发环境，极大提升了I/O效率。本文将深入探讨Channel的使用及实现。</p>]]>
    
    </summary>
    
      <category term="Channel" scheme="http://www.xiaoyuxee.com/tags/Channel/"/>
    
      <category term="NIO" scheme="http://www.xiaoyuxee.com/tags/NIO/"/>
    
      <category term="Java-Core" scheme="http://www.xiaoyuxee.com/categories/Java-Core/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java中的NIO]]></title>
    <link href="http://www.xiaoyuxee.com/2016/03/11/nio-in-java/"/>
    <id>http://www.xiaoyuxee.com/2016/03/11/nio-in-java/</id>
    <published>2016-03-11T08:36:02.000Z</published>
    <updated>2016-03-14T15:21:01.000Z</updated>
    <content type="html"><![CDATA[<p>java.io是面向序列化得字节流，阻塞模式工作，在java.nio中引入很多新的类，它们是面向缓存、非阻塞模式工作，并且类似线程池引入了选择器来管理管道,极大的提升的I/O性能。nio是new i/o，对传统i/o的扩展，但不是替代。</p>
<a id="more"></a>
<h2 id="u8DEF_u5F84_uFF08Path_uFF09"><a href="#u8DEF_u5F84_uFF08Path_uFF09" class="headerlink" title="路径（Path）"></a>路径（Path）</h2><p><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html" target="_blank" rel="external">Path</a>是<code>java.nio.file</code>中一个重要的概念。</p>
<h3 id="u4EC0_u4E48_u662F_u8DEF_u5F84"><a href="#u4EC0_u4E48_u662F_u8DEF_u5F84" class="headerlink" title="什么是路径"></a>什么是路径</h3><p>路径在文件系统中用于定位文件。比如：在Mac OS中<code>/Users/Xee/logs/sys.log</code>就表示定位sys.log的路径。在文件操作系统中，文件都是以树或者继承的形态分布。不同的是，在Unix系统下只有一个根root目录，而在Windows下可能会存在多个卷volume。路径的组成包含根目录、根目录到文件路径上的所有中间目录和文件名本身，它们用文件系统中的分隔符连接delimiter。不同的操作系统中分隔符也不一样，Unix中为slash<code>/</code>，如<code>/Users/Xee/logs/sys.log</code>，而在Windows中为black slash<code>\</code>，如<code>C:\home\sally\statusReport</code>。</p>
<h3 id="u8DEF_u5F84_u7C7B_u578B"><a href="#u8DEF_u5F84_u7C7B_u578B" class="headerlink" title="路径类型"></a>路径类型</h3><p>路径分为绝对路径和相对路径。绝对路径包含了根目录以及定位到具体文件所需的所有文件目录。相对目录是相对于某一个文件的路径，需要结合相对的文件才能定位到想定位的问题。</p>
<h3 id="Path_u7684_u4E3B_u8981_u65B9_u6CD5"><a href="#Path_u7684_u4E3B_u8981_u65B9_u6CD5" class="headerlink" title="Path的主要方法"></a><code>Path</code>的主要方法</h3><p>Path包含很多获取有关路径信息的很多方法，包括访问路径中的元素、转化路径格式、匹配路径等。这些方法大部分为静态（static）方法，因为这些操作只是针对路径本身而不需要访问文件系统。</p>
<h4 id="u521B_u5EFA_u8DEF_u5F84"><a href="#u521B_u5EFA_u8DEF_u5F84" class="headerlink" title="创建路径"></a>创建路径</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path1 = Paths.get(<span class="string">"/tmp/foo"</span>); <span class="comment">// /tmp/foo</span></span><br><span class="line">Path path2 = Paths.get(System.getProperty(<span class="string">"user.home"</span>), <span class="string">"bar"</span>); <span class="comment">// /Users/Xee/bar</span></span><br><span class="line">Path path3 = Paths.get(URI.create(<span class="string">"file:///Users/Xee/logs/"</span>));  <span class="comment">// /Users/Xee/logs/</span></span><br></pre></td></tr></table></figure>
<p>创建路径可以通过<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Paths.html" target="_blank" rel="external">Paths</a>的静态方法，支持通过<code>String</code>和<code>URI</code>来创建。其实它的实现是调用<code>FileSystems</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Path <span class="title">get</span><span class="params">(String first, String... more)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> FileSystems.getDefault().getPath(first, more);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="u83B7_u53D6_u8DEF_u5F84_u4FE1_u606F"><a href="#u83B7_u53D6_u8DEF_u5F84_u4FE1_u606F" class="headerlink" title="获取路径信息"></a>获取路径信息</h4><p>你可以将Path的存储结构想象成一个存储着路径中所有元素的列表：索引0存储的是根元素，索引n-1存储的是需要定位的文件名，n是路径中所有元素的个数。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(URI.create(<span class="string">"file:///Users/Xee/logs/"</span>));</span><br><span class="line"></span><br><span class="line">System.out.format(<span class="string">"toString: %s%n"</span>, path.toString());</span><br><span class="line">System.out.format(<span class="string">"getFileName: %s%n"</span>, path.getFileName());</span><br><span class="line">System.out.format(<span class="string">"getName(0): %s%n"</span>, path.getName(<span class="number">0</span>));</span><br><span class="line">System.out.format(<span class="string">"getNameCount: %d%n"</span>, path.getNameCount());</span><br><span class="line">System.out.format(<span class="string">"subpath(0,2): %s%n"</span>, path.subpath(<span class="number">0</span>,<span class="number">2</span>));</span><br><span class="line">System.out.format(<span class="string">"getParent: %s%n"</span>, path.getParent());</span><br><span class="line">System.out.format(<span class="string">"getRoot: %s%n"</span>, path.getRoot());</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output：</span><br><span class="line">toString: /Users/Xee/logs</span><br><span class="line">getFileName: logs</span><br><span class="line">getName(0): Users</span><br><span class="line">getNameCount: 3</span><br><span class="line">subpath(0,2): Users/Xee</span><br><span class="line">getParent: /Users/Xee</span><br><span class="line">getRoot: /</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure></p>
<h4 id="u89C4_u683C_u5316_u8DEF_u5F84"><a href="#u89C4_u683C_u5316_u8DEF_u5F84" class="headerlink" title="规格化路径"></a>规格化路径</h4><p><code>normalize()</code>：很多文件系统中用<code>.</code>表示当前文件夹，<code>..</code>表示父级文件夹。</p>
<h4 id="u8DEF_u5F84_u8F6C_u6362"><a href="#u8DEF_u5F84_u8F6C_u6362" class="headerlink" title="路径转换"></a>路径转换</h4><ul>
<li>toUri：转化可以在浏览器中访问的路径</li>
<li>toRealPath：<br><strong> 如果是相对路径，返回绝对路径
</strong> 如果包含<code>.</code>、<code>..</code>等路径，返回规格化的路径</li>
<li>toAbsolutePath：返回绝度路径</li>
<li>normalize：去除被简化的路径信息，返回规格化的路径（<em>但不改变路径类型，原先是相对路径，则还是相对路径</em>）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java文件所在路径：/Users/Xee/osceola/</span></span><br><span class="line"><span class="comment">// 创建相对路径</span></span><br><span class="line">Path path = Paths.get(<span class="string">".."</span>);</span><br><span class="line"></span><br><span class="line">System.out.format(<span class="string">"toString: %s%n"</span>, path.toString());</span><br><span class="line"></span><br><span class="line">System.out.format(<span class="string">"toUri: %s%n"</span>, path.toUri());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回真实路径，去除被简化的信息“..”</span></span><br><span class="line">System.out.format(<span class="string">"toRealPath: %s%n"</span>, path.toRealPath(LinkOption.NOFOLLOW_LINKS).toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回绝对路径，但包含简化的“..”</span></span><br><span class="line">System.out.format(<span class="string">"toAbsolutePath: %s%n"</span>, path.toAbsolutePath().toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output:</span><br><span class="line">toString: ..</span><br><span class="line">toUri: file:///Users/Xee/osceola/../</span><br><span class="line">toRealPath: /Users/Xee/</span><br><span class="line">toAbsolutePath: /Users/Xee/osceola/..</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="u89E3_u6790_u76F8_u5BF9_u8DEF_u5F84"><a href="#u89E3_u6790_u76F8_u5BF9_u8DEF_u5F84" class="headerlink" title="解析相对路径"></a>解析相对路径</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(URI.create(<span class="string">"file:///Users/Xee/logs/"</span>));</span><br><span class="line">System.out.format(<span class="string">"toString: %s%n"</span>, path.resolve(<span class="string">".."</span>).toRealPath(NOFOLLOW_LINKS));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output:</span><br><span class="line">toString: /Users/Xee</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="u521B_u5EFA_u76F8_u5BF9_u8DEF_u5F84"><a href="#u521B_u5EFA_u76F8_u5BF9_u8DEF_u5F84" class="headerlink" title="创建相对路径"></a>创建相对路径</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path home = Paths.get(<span class="string">"/Users/Xee"</span>);</span><br><span class="line">Path sysLog = Paths.get(<span class="string">"/Users/Xee/log/sys.log"</span>);</span><br><span class="line"></span><br><span class="line">System.out.format(<span class="string">"home_to_sysLog: %s%n"</span>, home.relativize(sysLog));</span><br><span class="line">System.out.format(<span class="string">"sysLog_to_home: %s%n"</span>, sysLog.relativize(home));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output:</span><br><span class="line">home_to_sysLog: log/sys.log</span><br><span class="line">sysLog_to_home: ../..</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="u8DEF_u5F84_u6BD4_u8F83"><a href="#u8DEF_u5F84_u6BD4_u8F83" class="headerlink" title="路径比较"></a>路径比较</h4><p><code>equals</code>，<code>startsWith</code>，<code>endsWith</code>：值得注意的是，这里比较的是<em>存储列表中的元素</em>，而不是真实路径<em>realPath</em>。</p>
<h4 id="u904D_u5386_u8DEF_u5F84_u4E2D_u7684_u5143_u7D20"><a href="#u904D_u5386_u8DEF_u5F84_u4E2D_u7684_u5143_u7D20" class="headerlink" title="遍历路径中的元素"></a>遍历路径中的元素</h4><p>因为Path实现了<code>Iterable</code>接口，所以可以通过迭代器遍历存储结构中的元素。</p>
<h2 id="Files_u57FA_u672C_u64CD_u4F5C"><a href="#Files_u57FA_u672C_u64CD_u4F5C" class="headerlink" title="Files基本操作"></a>Files基本操作</h2><p><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html" target="_blank" rel="external">Files</a>包含了大量的静态方法，这些方法依赖Path实例。</p>
<p>而实现一般是通过<code>path.getFileSystem().provider()</code>获取<code>FileSystemProvider</code>来执行具体操作。</p>
<h3 id="u68C0_u67E5_u64CD_u4F5C"><a href="#u68C0_u67E5_u64CD_u4F5C" class="headerlink" title="检查操作"></a>检查操作</h3><h4 id="u6587_u4EF6_u5B58_u5728_u6027_u5224_u65AD"><a href="#u6587_u4EF6_u5B58_u5728_u6027_u5224_u65AD" class="headerlink" title="文件存在性判断"></a>文件存在性判断</h4><p><em>注意：</em> </p>
<ul>
<li>文件存在与否可能有三种结果：存在，不存在 或者 未知（没有权限）。</li>
<li>查询结果具有时效性，返回结果表示存在，但当你访问是可能不存在（已被删除）</li>
</ul>
<h4 id="u6587_u4EF6_u8BBF_u95EE_u6743_u9650_u5224_u65AD"><a href="#u6587_u4EF6_u8BBF_u95EE_u6743_u9650_u5224_u65AD" class="headerlink" title="文件访问权限判断"></a>文件访问权限判断</h4><p>可读性、可写性和可执行性。</p>
<h4 id="u8DEF_u5F84_u5B9A_u4F4D_u662F_u5426_u540C_u4E00_u6587_u4EF6"><a href="#u8DEF_u5F84_u5B9A_u4F4D_u662F_u5426_u540C_u4E00_u6587_u4EF6" class="headerlink" title="路径定位是否同一文件"></a>路径定位是否同一文件</h4><p>特别是用于判断软连接定位的文件<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Files.isSameFile(p1, p2)) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u5220_u9664_u3001_u79FB_u52A8_u3001_u590D_u5236"><a href="#u5220_u9664_u3001_u79FB_u52A8_u3001_u590D_u5236" class="headerlink" title="删除、移动、复制"></a>删除、移动、复制</h3><h4 id="u5220_u9664"><a href="#u5220_u9664" class="headerlink" title="删除"></a>删除</h4><p>可以删除文件、目录和链接。</p>
<ul>
<li>如果删除的是链接，链接指向的真正文件是不会被删除的。</li>
<li>如果删除的是目录不为空，则删除失败。</li>
</ul>
<h4 id="u590D_u5236"><a href="#u590D_u5236" class="headerlink" title="复制"></a>复制</h4><p>复制文件时值得注意的是<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#copy-java.nio.file.Path-java.nio.file.Path-java.nio.file.CopyOption...-" target="_blank" rel="external">Path copy(Path source, Path target, CopyOption… options)</a>中<em>StandardCopyOption</em>选项：<br>如果目标文件存在，那么复制操作失败，除非指定<code>REPLACE_EXISTING</code>选项进行覆盖。</p>
<p>同时还支持字节流与Path之间的复制。</p>
<p><em>注意</em>：复制目录时，只会复制目录本身而不会递归复制。StandardCopyOption中也没有这个枚举类型。</p>
<h4 id="u79FB_u52A8/_u91CD_u547D_u540D"><a href="#u79FB_u52A8/_u91CD_u547D_u540D" class="headerlink" title="移动/重命名"></a>移动/重命名</h4><p><em>注意</em>：</p>
<ul>
<li>如果是在同个目录下移动，等价于<em>重命名</em></li>
<li>移动目录时，目录里的子文件、子目录也会随着移动（跟复制有差别，复制时不会递归复制）。当然前提是源目录和目标目录在同一个<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileStore.html" target="_blank" rel="external">FileStore</a>中：同一个卷、移动设备等。</li>
</ul>
<h2 id="u6587_u4EF6_u5143_u6570_u636E_uFF08_u6587_u4EF6_u5C5E_u6027_uFF09"><a href="#u6587_u4EF6_u5143_u6570_u636E_uFF08_u6587_u4EF6_u5C5E_u6027_uFF09" class="headerlink" title="文件元数据（文件属性）"></a>文件元数据（文件属性）</h2><p>文件的元数据包含在文件或者目录中，如是不是一个常规文件，还是一个目录或者一个链接。它的大小是多少，创建时间，最后修改时间，文件所属者，所属用户组和访问权限。</p>
<p>一个文件系统的元数据通常指文件的属性。<code>Files</code>中包含了获取以及设置这些属性的方法：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">+----------------------------------------------+--------------------------------------------------+</span><br><span class="line">| Method                                       | Comment                                          |</span><br><span class="line">+----------------------------------------------+--------------------------------------------------+</span><br><span class="line">| size(Path)                                   | Returns the size of the specified file in bytes. |</span><br><span class="line">+----------------------------------------------+--------------------------------------------------+</span><br><span class="line">| isDirectory(Path, LinkOption)                | Returns true if the file is a directory.         |</span><br><span class="line">+----------------------------------------------+--------------------------------------------------+</span><br><span class="line">| isRegularFile(Path, LinkOption...)           | Returns true if the file is a regular file.      |</span><br><span class="line">+----------------------------------------------+--------------------------------------------------+</span><br><span class="line">| isSymbolicLink(Path)                         | Returns true if the file is a symbolic link.     |</span><br><span class="line">+----------------------------------------------+--------------------------------------------------+</span><br><span class="line">| isHidden(Path)                               | Returns true if the file is considered hidden.   |</span><br><span class="line">+----------------------------------------------+--------------------------------------------------+</span><br><span class="line">| getLastModifiedTime(Path, LinkOption...)     | Returns the specified file's last modified time. |</span><br><span class="line">+----------------------------------------------+--------------------------------------------------+</span><br><span class="line">| getOwner(Path, LinkOption...)                | Returns the owner of the file.                   |</span><br><span class="line">+----------------------------------------------+--------------------------------------------------+</span><br><span class="line">| getPosixFilePermissions(Path, LinkOption...) | Returns a file's POSIX file permissions.         |</span><br><span class="line">+----------------------------------------------+--------------------------------------------------+</span><br><span class="line">| getAttribute(Path, String, LinkOption...)    | Returns the value of a file attribute.           |</span><br><span class="line">+----------------------------------------------+--------------------------------------------------+</span><br></pre></td></tr></table></figure></p>
<p>如果想要一次获取多个属性，Files也是支持的，并且效率大大优于分别取获取单个属性：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">+----------------------------------------------+------------------------------------------------------------+</span><br><span class="line">| Method                                       | Comment                                                    |</span><br><span class="line">+----------------------------------------------+------------------------------------------------------------+</span><br><span class="line">| readAttributes(Path, String, LinkOption...)  | The String parameter identifies the attributes to be read. |</span><br><span class="line">+----------------------------------------------+------------------------------------------------------------+</span><br><span class="line">|readAttributes(Path, Class<span class="tag">&lt;<span class="title">A</span>&gt;</span>, LinkOption...) | The Class<span class="tag">&lt;<span class="title">A</span>&gt;</span> parameter is the type of attributes requested.|</span><br><span class="line">+----------------------------------------------+------------------------------------------------------------+</span><br></pre></td></tr></table></figure></p>
<h3 id="u57FA_u672C_u6587_u4EF6_u5C5E_u6027"><a href="#u57FA_u672C_u6587_u4EF6_u5C5E_u6027" class="headerlink" title="基本文件属性"></a>基本文件属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path file = Paths.get(System.getProperty(<span class="string">"user.home"</span>));</span><br><span class="line">        </span><br><span class="line">Map&lt;String, Object&gt; attributesMap = Files.readAttributes(file, <span class="string">"*"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Entry&lt;String, Object&gt; entry : attributesMap.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">" = "</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Output:</span><br><span class="line">lastAccessTime = 2016-03-12T09:48:48Z</span><br><span class="line">lastModifiedTime = 2016-03-12T09:48:49Z</span><br><span class="line">size = 2686</span><br><span class="line">creationTime = 2015-11-27T02:23:57Z</span><br><span class="line">isSymbolicLink = false</span><br><span class="line">isRegularFile = false</span><br><span class="line">fileKey = (dev=1000004,ino=611925)</span><br><span class="line">isOther = false</span><br><span class="line">isDirectory = true</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="u8BBE_u7F6E_u6587_u4EF6_u65F6_u95F4_u6233"><a href="#u8BBE_u7F6E_u6587_u4EF6_u65F6_u95F4_u6233" class="headerlink" title="设置文件时间戳"></a>设置文件时间戳</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path file = Paths.get(System.getProperty(<span class="string">"user.home"</span>));</span><br><span class="line"></span><br><span class="line">FileTime currentTime = FileTime.fromMillis(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改“最后修改时间”</span></span><br><span class="line">Files.setLastModifiedTime(file, currentTime);</span><br><span class="line"></span><br><span class="line">FileTime lastModifiedTime = (FileTime) Files.getAttribute(file, <span class="string">"lastModifiedTime"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后修改时间只能精确到秒</span></span><br><span class="line">assertNotEquals(currentTime.toMillis(), lastModifiedTime.toMillis());</span><br><span class="line">assertEquals(currentTime.to(TimeUnit.SECONDS), lastModifiedTime.to(TimeUnit.SECONDS));</span><br></pre></td></tr></table></figure>
<h3 id="u5176_u4ED6_u5C5E_u6027_u83B7_u53D6"><a href="#u5176_u4ED6_u5C5E_u6027_u83B7_u53D6" class="headerlink" title="其他属性获取"></a>其他属性获取</h3><ul>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/BasicFileAttributes.html" target="_blank" rel="external">BasicFileAttributes</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/DosFileAttributes.html" target="_blank" rel="external">DosFileAttributes</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/PosixFileAttributes.html" target="_blank" rel="external">PosixFileAttributes</a></li>
</ul>
<h3 id="u5176_u4ED6_u5C5E_u6027_u8BBE_u7F6E"><a href="#u5176_u4ED6_u5C5E_u6027_u8BBE_u7F6E" class="headerlink" title="其他属性设置"></a>其他属性设置</h3><ul>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/BasicFileAttributeView.html" target="_blank" rel="external">BasicFileAttributeView</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/DosFileAttributeView.html" target="_blank" rel="external">DosFileAttributeView</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/PosixFileAttributeView.html" target="_blank" rel="external">PosixFileAttributeView</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/AclFileAttributeView.html" target="_blank" rel="external">AclFileAttributeView</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/attribute/UserDefinedFileAttributeView.html" target="_blank" rel="external">UserDefinedFileAttributeView</a></li>
</ul>
<h2 id="u6587_u4EF6_u7684_u8BFB_u53D6_u3001_u4FEE_u6539_u4E0E_u521B_u5EFA"><a href="#u6587_u4EF6_u7684_u8BFB_u53D6_u3001_u4FEE_u6539_u4E0E_u521B_u5EFA" class="headerlink" title="文件的读取、修改与创建"></a>文件的读取、修改与创建</h2><h3 id="OpenOption_u53C2_u6570"><a href="#OpenOption_u53C2_u6570" class="headerlink" title="OpenOption参数"></a>OpenOption参数</h3><p>OpenOption参数是进行文件内容操作的可选参数，其中<code>StandardOpenOption</code>支持：</p>
<ul>
<li>READ</li>
<li>WRITE</li>
<li>APPEND</li>
<li>TRUNCATE_EXISTING：只有在支持WRITE时生效</li>
<li>CREATE</li>
<li>CREATE_NEW：只有文件不存在时才创建</li>
<li>DELETE_ON_CLOSE：</li>
<li>SPARSE</li>
<li>SYNC：内容及元数据同步</li>
<li>DSYNC：仅仅内容同步</li>
</ul>
<h3 id="u5E38_u7528_u64CD_u4F5C"><a href="#u5E38_u7528_u64CD_u4F5C" class="headerlink" title="常用操作"></a>常用操作</h3><p>主要有<code>readAllBytes</code>、<code>readAllLines</code>、<code>write(Path, byte[])</code>、<code>write(Path, Iterable&lt;? extends CharSequence&gt;</code>，详见下面的demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(System.getProperty(<span class="string">"user.home"</span>), <span class="string">"text"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取所有字节数组</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = Files.readAllBytes(path);</span><br><span class="line">ByteArrayInputStream inputStream = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line"></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream)));</span><br><span class="line"><span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">    System.out.println(scanner.nextLine());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取所有行</span></span><br><span class="line">List&lt;String&gt; lines = Files.readAllLines(path);</span><br><span class="line">lines.forEach(System.out::println);</span><br><span class="line">scanner.close();</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 默认的OpenOption：CREATE，TRUNCATE_EXISTING，WRITE</span></span><br><span class="line">Files.write(path, <span class="string">"Hello World"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">Files.write(path, Arrays.asList(<span class="keyword">new</span> String[]&#123;<span class="string">"Hello World"</span>, <span class="string">"Hello NIO"</span>&#125;));</span><br></pre></td></tr></table></figure>
<h3 id="u9762_u5411_u5177_u6709_u7F13_u5B58_u529F_u80FDio_u7684_u64CD_u4F5C"><a href="#u9762_u5411_u5177_u6709_u7F13_u5B58_u529F_u80FDio_u7684_u64CD_u4F5C" class="headerlink" title="面向具有缓存功能io的操作"></a>面向具有缓存功能io的操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(System.getProperty(<span class="string">"user.home"</span>), <span class="string">"text"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建BufferedReader</span></span><br><span class="line">BufferedReader reader = Files.newBufferedReader(path);</span><br><span class="line">String line = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    System.out.println(line);</span><br><span class="line">&#125;</span><br><span class="line">reader.close();</span><br><span class="line"></span><br><span class="line">BufferedWriter write = Files.newBufferedWriter(path);</span><br><span class="line">write.write(<span class="string">"Hello NIO"</span>);</span><br><span class="line">write.close();</span><br></pre></td></tr></table></figure>
<h3 id="u9762_u5411_u4E0D_u5177_u6709_u7F13_u5B58_u529F_u80FDio_u7684_u64CD_u4F5C"><a href="#u9762_u5411_u4E0D_u5177_u6709_u7F13_u5B58_u529F_u80FDio_u7684_u64CD_u4F5C" class="headerlink" title="面向不具有缓存功能io的操作"></a>面向不具有缓存功能io的操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(System.getProperty(<span class="string">"user.home"</span>), <span class="string">"text"</span>);</span><br><span class="line"></span><br><span class="line">InputStream inputStream = Files.newInputStream(path);</span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream)));</span><br><span class="line"><span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">    System.out.println(scanner.nextLine());</span><br><span class="line">&#125;</span><br><span class="line">scanner.close();</span><br><span class="line"></span><br><span class="line">OutputStream outputStream = Files.newOutputStream(path);</span><br><span class="line">PrintWriter writer = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(outputStream)));</span><br><span class="line">writer.write(<span class="string">"Hello World"</span>);</span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure>
<h3 id="u9762_u5411_u7BA1_u9053_u7684_u64CD_u4F5C"><a href="#u9762_u5411_u7BA1_u9053_u7684_u64CD_u4F5C" class="headerlink" title="面向管道的操作"></a>面向管道的操作</h3><p>普通流每次读取一个字符，而管道每次读取一块缓存，这也是NIO与传统IO一个重要的区别。</p>
<h4 id="u8BFB_u53D6_u7F13_u5B58_u5B57_u8282"><a href="#u8BFB_u53D6_u7F13_u5B58_u5B57_u8282" class="headerlink" title="读取缓存字节"></a>读取缓存字节</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(System.getProperty(<span class="string">"user.home"</span>), <span class="string">"text"</span>);</span><br><span class="line"></span><br><span class="line">SeekableByteChannel channel = Files.newByteChannel(path);</span><br><span class="line"></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">while</span> (channel.read(buffer) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    buffer.flip();</span><br><span class="line">    System.out.println(Charset.forName(System.getProperty(<span class="string">"file.encoding"</span>)).decode(buffer));</span><br><span class="line">    buf.compact();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">channel.close();</span><br></pre></td></tr></table></figure>
<h4 id="u5199_u5165_u7F13_u5B58_u5B57_u8282"><a href="#u5199_u5165_u7F13_u5B58_u5B57_u8282" class="headerlink" title="写入缓存字节"></a>写入缓存字节</h4><p>管道可以读，也可以写。通过Files创建管道时默认是READ，当需要写操作是需要传入WRITE操作<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(System.getProperty(<span class="string">"user.home"</span>), <span class="string">"text"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置可写操作</span></span><br><span class="line">SeekableByteChannel channel = Files.newByteChannel(path, EnumSet.of(CREATE, WRITE));</span><br><span class="line"></span><br><span class="line">ByteBuffer buffer = ByteBuffer.wrap(<span class="string">"Hello World"</span>.getBytes());</span><br><span class="line">channel.write(buffer);</span><br><span class="line">channel.close();</span><br></pre></td></tr></table></figure></p>
<h3 id="u521B_u5EFA_u6587_u4EF6"><a href="#u521B_u5EFA_u6587_u4EF6" class="headerlink" title="创建文件"></a>创建文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(System.getProperty(<span class="string">"user.home"</span>), <span class="string">"text"</span>);</span><br><span class="line">        </span><br><span class="line">Files.createFile(path, asFileAttribute(fromString(<span class="string">"rw-r-----"</span>)));</span><br></pre></td></tr></table></figure>
<h4 id="u521B_u5EFA_u4E34_u65F6_u6587_u4EF6"><a href="#u521B_u5EFA_u4E34_u65F6_u6587_u4EF6" class="headerlink" title="创建临时文件"></a>创建临时文件</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path file = createTempFile(<span class="keyword">null</span>, <span class="string">".xxy"</span>);</span><br><span class="line">System.out.println(file);</span><br><span class="line"></span><br><span class="line">PosixFileAttributes attrbutes = readAttributes(file, PosixFileAttributes.class);</span><br><span class="line"><span class="comment">// 默认权限为 "rx-------"</span></span><br><span class="line">System.out.println(attrbutes.permissions());</span><br></pre></td></tr></table></figure>
<h2 id="u6587_u4EF6_u76EE_u5F55"><a href="#u6587_u4EF6_u76EE_u5F55" class="headerlink" title="文件目录"></a>文件目录</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 系统根目录</span></span><br><span class="line">FileSystems.getDefault().getRootDirectories().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建目录或递归创建目录</span></span><br><span class="line">Files.createDirectory(Paths.get(System.getProperty(<span class="string">"user.home"</span>), <span class="string">"tmp"</span>));</span><br><span class="line">Files.createDirectories(Paths.get(System.getProperty(<span class="string">"user.home"</span>), <span class="string">"tmp/a/b/c"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历目录内容</span></span><br><span class="line">Files.newDirectoryStream(Paths.get(System.getProperty(<span class="string">"user.home"</span>))).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目录内容过滤，当然你也可以创建自己的过滤器</span></span><br><span class="line">Files.newDirectoryStream(Paths.get(System.getProperty(<span class="string">"user.home"</span>)), <span class="string">".py"</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h2 id="u9012_u5F52_u904D_u5386_u6587_u4EF6_u5939"><a href="#u9012_u5F52_u904D_u5386_u6587_u4EF6_u5939" class="headerlink" title="递归遍历文件夹"></a>递归遍历文件夹</h2><p>在日常应用中经常需要递归遍历某个文件夹寻找某个文件、或进行访问操作，这时可以使用Files提供的<code>walkFileTree</code>方法，不过你需要实现<code>FileVisitor</code>接口，自定义遍历时的逻辑。</p>
<h3 id="FileVisitor"><a href="#FileVisitor" class="headerlink" title="FileVisitor"></a>FileVisitor</h3><p>FileVisitor接口定义了遍历文件树时的具体行为：访问一个文件时，访问一个目录前，访问一个目录后，以及访问出错时。</p>
<p>访问文件树时可支持自定义深度：<code>walkFileTree(Path, Set&lt;FileVisitOption&gt;, int, FileVisitor)</code></p>
<h3 id="FileVisitor_u7684_u5B9E_u73B0"><a href="#FileVisitor_u7684_u5B9E_u73B0" class="headerlink" title="FileVisitor的实现"></a><code>FileVisitor</code>的实现</h3><p>实现具体的遍历行为时，可以通过继承<code>SimpleFileVisitor</code>，但需要注意：</p>
<ol>
<li>递归删除文件时，那么就需要<em>在删除了目录里内容后，再删除目录本身</em>。</li>
<li>递归创建文件时，顺序则相反</li>
<li>递归修改文件权限时同样需要考虑，因为修改权限后，可能会导致你无法访问。</li>
</ol>
<h3 id="u4FBF_u5229_u6D41_u7A0B_u7684_u63A7_u5236"><a href="#u4FBF_u5229_u6D41_u7A0B_u7684_u63A7_u5236" class="headerlink" title="便利流程的控制"></a>便利流程的控制</h3><p><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileVisitResult.html" target="_blank" rel="external">FileVisitResult</a>是FileVisitor中每个方法的返回值，包括：继续（CONTINUE），终止（TERMINATE），跳过此目录（SKIP_SUBTREE），跳过同级文件或目录（SKIP_SIBLINGS）。</p>
<h2 id="u6587_u4EF6_u641C_u7D22"><a href="#u6587_u4EF6_u641C_u7D22" class="headerlink" title="文件搜索"></a>文件搜索</h2><p>搜索文件可以理解为：递归遍历文件夹，然后一一进行对文件名称匹配。由于在NIO中的核心模型为Path（传统io为File），所以NIO中同样提供了用于路径匹配的<code>PathMatcher</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PathMatcher</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Path path)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u8DEF_u5F84_u5339_u914D"><a href="#u8DEF_u5F84_u5339_u914D" class="headerlink" title="路径匹配"></a>路径匹配</h3><p>PathMatcher可以用过<code>FileSystem</code>的<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#getPathMatcher-java.lang.String-" target="_blank" rel="external">getPathMatcher(String)</a>方法实例化。</p>
<p>创建PathMatcher时的语法为：<code>syntax:pattern</code>。FileSystem支持<a href="http://docs.oracle.com/javase/tutorial/essential/io/fileOps.html#glob" target="_blank" rel="external">glob</a>、<a href="http://docs.oracle.com/javase/tutorial/essential/regex/index.html" target="_blank" rel="external">regex</a>两种语法。</p>
<h4 id="glob"><a href="#glob" class="headerlink" title="glob"></a>glob</h4><ul>
<li><code>*</code>表示匹配0个或多个字符（但没有跨越目录）</li>
<li><code>**</code>表示匹配0个或多个字符（跨目录）</li>
<li><code>?</code>表示匹配0个或1个字符</li>
<li><code>\</code>为转义字符，用来匹配<code>*</code>、<code>?</code>等</li>
<li><p><code>[ ]</code>表示匹配一组字符中的1个字符，比如“[abc]”可以匹配“a”、“b”或者“c”。<br>常常结合<code>-</code>一起使用，表示范围。如“[a-z]”可以匹配从“a”到“z”的所有单个字符。<br>有时也会搭配<code>!</code>来使用表示取反，如[!a-c]表示可以匹配任何字符但除了“a”、“b”、“c”。</p>
<p><em>注意：</em> 方括号中的<code>*</code>，<code>?</code>，<code>\</code>不在具有上述统配意义，将匹配它们本身表示的字符。而<code>-</code>符号为第一字符，也就是不再表示范围时，也表示它本身代表的字符。</p>
</li>
<li><code>{ }</code>表示匹配一组字符串中的任意一个，但不能嵌套使用。<code>,</code>为分隔符。</li>
<li><code>.</code>开头的字符串视为常规的字符，不要理解为正则中的任意字符。</li>
</ul>
<p>比如我们要匹配所有java文件，可以这么来创建：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PathMatcher matcher = FileSystems.getDefault().getPathMatcher(<span class="string">"glob:a.java"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一定要使用 getFileName</span></span><br><span class="line"><span class="keyword">if</span> (matcher.matches(file.getFileName())) &#123;</span><br><span class="line">    <span class="comment">// TODO something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，一定要使用<code>getFileName</code>，因为file一般表示从root到文件中的所有元素。</p>
<h4 id="regex"><a href="#regex" class="headerlink" title="regex"></a>regex</h4><p>参见<a href="http://docs.oracle.com/javase/tutorial/essential/regex/index.html" target="_blank" rel="external">oracle上的教程</a>。</p>
<h2 id="u4E0Ejava-io-File_u7684_u6BD4_u8F83"><a href="#u4E0Ejava-io-File_u7684_u6BD4_u8F83" class="headerlink" title="与java.io.File的比较"></a>与<code>java.io.File</code>的比较</h2><p>JDK7发布前File是主要的I/O类，但它具有很多缺点：</p>
<ul>
<li>很多方法失败时不会抛出明确异常。比如文件删除失败时，你无法得知是文件不存在还是没有权限。</li>
<li>不能友好的支持文件连接。</li>
<li>不能全面的支持文件元数据，如Ownner，permission等。</li>
<li>不能友好的支持递归遍历目录。</li>
</ul>
<h3 id="Path_u4E0EFile_u7684_u8F6C_u5316"><a href="#Path_u4E0EFile_u7684_u8F6C_u5316" class="headerlink" title="Path与File的转化"></a>Path与File的转化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path input = file.toPath();</span><br><span class="line">Files.delete(fp);</span><br></pre></td></tr></table></figure>
<p>其他场景的转化参见：<a href="http://docs.oracle.com/javase/tutorial/essential/io/legacy.html#mapping" target="_blank" rel="external">官方文档</a></p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://tutorials.jenkov.com/java-nio/index.html" target="_blank" rel="external">http://tutorials.jenkov.com/java-nio/index.html</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>java.io是面向序列化得字节流，阻塞模式工作，在java.nio中引入很多新的类，它们是面向缓存、非阻塞模式工作，并且类似线程池引入了选择器来管理管道,极大的提升的I/O性能。nio是new i/o，对传统i/o的扩展，但不是替代。</p>]]>
    
    </summary>
    
      <category term="NIO" scheme="http://www.xiaoyuxee.com/tags/NIO/"/>
    
      <category term="Java-Core" scheme="http://www.xiaoyuxee.com/categories/Java-Core/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java中的输入/输出流]]></title>
    <link href="http://www.xiaoyuxee.com/2016/02/15/basic-IO-in-java/"/>
    <id>http://www.xiaoyuxee.com/2016/02/15/basic-IO-in-java/</id>
    <published>2016-02-15T02:46:17.000Z</published>
    <updated>2016-03-14T15:40:58.000Z</updated>
    <content type="html"><![CDATA[<p>流（Stream）是java中输入和输出经常涉及也是最简单的概念。Java中存在各种各样的流，字符流、字节流、缓存流、基本数据流、对象流等。Java持久化中谈及的序列化与反序列化同样离不开流（将整个对象写入流中，并可以从流中获取整个对象）。</p>
<a id="more"></a>
<h2 id="u5B57_u8282_u6D41_uFF08InputSteam_uFF09"><a href="#u5B57_u8282_u6D41_uFF08InputSteam_uFF09" class="headerlink" title="字节流（InputSteam）"></a>字节流（InputSteam）</h2><p>常见的有<code>FileInputSteam</code>，主要用于读取原生的字节流，如图片。如果想要读取关于字符的字节流可以使用<code>FileReader</code>。</p>
<h2 id="u5B57_u7B26_u6D41_uFF08Reader_uFF09"><a href="#u5B57_u7B26_u6D41_uFF08Reader_uFF09" class="headerlink" title="字符流（Reader）"></a>字符流（Reader）</h2><h3 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a><code>Reader</code></h3><p>所有的字符流都继承于Reader，它包含一个同步锁<code>lock</code>，默认是将自己作为一锁。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Reader</span> <span class="keyword">implements</span> <span class="title">Readable</span>, <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用于同步流</span></span><br><span class="line">    <span class="keyword">protected</span> Object lock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Reader</span><span class="params">(Object lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lock == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a><code>InputStreamReader</code></h3><p>InputStreamReader是从字节流到字符流的桥连接。它读取字节并将其编码成相应<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html" target="_blank" rel="external">字符集</a>的字符。字符集可以用指定的名称、或具体的字符集对象或者系统默认的字符集。</p>
<p>其实现是通过<code>StreamDecoder</code>的forInputStreamReader方法进行编码。<code>read()</code>方法同样委托给<code>StreamDecoder</code>。</p>
<h3 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a><code>FileReader</code></h3><p>继承于In继承putStreamReader，其实现是通过<code>FileInputSteam</code>创建字节流然后通过桥连接构造<code>StreamDecoder</code>，其读方法均由<code>InputStreamReader</code>实现（委托给<code>StreamDecoder</code>）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStreamReader</span> <span class="keyword">extends</span> <span class="title">Reader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InputStreamReader</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(in);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sd = StreamDecoder.forInputStreamReader(in, <span class="keyword">this</span>, (String)<span class="keyword">null</span>); <span class="comment">// check lock object</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="comment">// The default encoding should always be available</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sd.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReader</span> <span class="keyword">extends</span> <span class="title">InputStreamReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileReader</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> FileInputStream(fileName));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u7F13_u51B2_u6D41_uFF08Buffered_Stream_uFF09"><a href="#u7F13_u51B2_u6D41_uFF08Buffered_Stream_uFF09" class="headerlink" title="缓冲流（Buffered Stream）"></a>缓冲流（Buffered Stream）</h2><p>对于无缓冲的I/O操作，每次写或者读请求都会直接作用于操作系统，如硬盘访问、网络访问等代价非常昂贵的操作。 缓冲流的引入就是为了提升常规I/O操作的效率。</p>
<p>缓冲输入流是从一块缓冲的内容中读取数据，只有当缓冲区没有数据时才会调用操作系统的API获取一整块的数据，然后放入缓冲区以供程序读取。同样，缓冲输出流每次向缓冲区写入数据，只有当缓冲区被写满后才会调用操作系统的API将数据真正写入目标位置。</p>
<ul>
<li><p><a href="https://docs.oracle.com/javase/8/docs/api/java/io/BufferedInputStream.html" target="_blank" rel="external">BufferedInputStream</a>、<a href="https://docs.oracle.com/javase/8/docs/api/java/io/BufferedOutputStream.html" target="_blank" rel="external">BufferedOutputStream</a>：用于创建缓冲的字节流<br><strong> 分别继承于<code>FilterInputStream</code>和<code>FilterOutputStream</code>，本身字节流成员。
</strong> 必须使用字节流构造，并可以指定缓存区大小。</p>
</li>
<li><p><a href="https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html" target="_blank" rel="external">BufferedReader</a>、<a href="https://docs.oracle.com/javase/8/docs/api/java/io/BufferedWriter.html" target="_blank" rel="external">BufferedWriter</a>：用于创建缓冲的字符流</p>
</li>
</ul>
<h2 id="Scanning"><a href="#Scanning" class="headerlink" title="Scanning"></a>Scanning</h2><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html" target="_blank" rel="external">Scanner</a>，一个文本扫描工具，使用正则表达式解析基本数据类型和<code>String</code>类型。<code>Scanner</code>可以使用分隔符将输入数据分割成诸多片段，默认的分隔符为<em>whitespace</em>（参见<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html#isWhitespace-char-" target="_blank" rel="external">Character.isWhitespace</a>)。可以使用不同<code>next</code>方法将这些片段转化成不同的数据类型。</p>
<h3 id="u6784_u6210_u65B9_u6CD5_uFF1A"><a href="#u6784_u6210_u65B9_u6CD5_uFF1A" class="headerlink" title="构成方法："></a>构成方法：</h3><ul>
<li>字符流：<code>Readable</code>接口。比如继承于<code>Reader</code>的所有类，<code>FileReader</code>等。</li>
<li><p>字节流：<code>InputStream</code>，支持自定义charset。其实现是将<em>字节流转化为字符流</em>，使用字符流构造。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Scanner</span><span class="params">(InputStream source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> InputStreamReader(source), WHITESPACE_PATTERN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>字节可读管道：<code>ReadableByteChannel</code>，比如对应文件的管道<code>FileChannel</code>。</p>
</li>
<li>文件：<code>File</code>，支持自定义charset。其实现是构造<code>FileInputStream</code>，获取文件管道<code>FileChannel</code>，然后使用字节可读管道构造。</li>
<li>文件路径：<code>Path</code>，支持自定义charset。其实现是获取文件的字节流，然后构造字符流。</li>
<li>字符串：<code>String</code>。其实现是构造<code>StringReader</code>，然后构造字符流。</li>
</ul>
<h3 id="u4E3B_u8981_u65B9_u6CD5"><a href="#u4E3B_u8981_u65B9_u6CD5" class="headerlink" title="主要方法"></a>主要方法</h3><ul>
<li><code>hasNext、next</code>：不仅支持基础类型，还支持<code>BigDecimal</code>、<code>BigInteger</code>以及<code>nextLine</code>。这两个方法都会阻塞（block）等待输入。</li>
<li><code>useDelimiter</code>：自定义分隔符。</li>
<li><code>reset</code>：重置分隔符为<em>whitespace</em>。</li>
</ul>
<h2 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a><a href="https://docs.oracle.com/javase/8/docs/api/java/io/PrintStream.html" target="_blank" rel="external">PrintStream</a></h2><ul>
<li>异常：不会抛<code>IOException</code>，但是内部会有相应的标记，可以通过<code>checkError</code>来检查。</li>
<li>自动flush：当写入一个字节数组、或者调用<code>println</code>方法、或者写入换行符<code>\n</code>时会自动flush。</li>
</ul>
<p><em>注意</em>： 通过<em>PrintStream</em>打印的字符均会根据平台默认的字符编码被转成字节。</p>
<h3 id="u6784_u9020_u65B9_u6CD5_uFF1A"><a href="#u6784_u9020_u65B9_u6CD5_uFF1A" class="headerlink" title="构造方法："></a>构造方法：</h3><p>支持字节流、文件、文件名进行构造。使用字节流构造时，可自定义是否自动flush，默认为<code>false</code>。使用文件名或文件时，不可自定义，默认也为<code>false</code>。</p>
<p>相应的，用于处理字符的类为<a href="https://docs.oracle.com/javase/8/docs/api/java/io/PrintWriter.html" target="_blank" rel="external">PrintWriter</a>。一般情况下直接使用<code>PrintWriter</code>。</p>
<h3 id="u4E3B_u8981_u65B9_u6CD5-1"><a href="#u4E3B_u8981_u65B9_u6CD5-1" class="headerlink" title="主要方法"></a>主要方法</h3><ul>
<li><code>format(String format, Object... args)</code><br>类似C语言，格式化输入源数据。具体语法参考<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax" target="_blank" rel="external">Formatter</a>。</li>
</ul>
<h2 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="PrintWriter"></a><a href="https://docs.oracle.com/javase/8/docs/api/java/io/PrintWriter.html" target="_blank" rel="external">PrintWriter</a></h2><p>跟<code>PrintStream</code>类似，也是用于格式化输出。并且实现了所有<code>PrintStream</code>的方法。但自动flush时有点不同：不再直接检查被写入的是否为换行符<code>\n</code>，而是检查是否为当前平台的换行符。</p>
<p>支持字节流（OutStream）、字符流（Writer）、文件名、文件（File）进行构造。特别的，除了字节流构造意外，其他实现均为会转化成缓存字符流（<code>BufferedWriter</code>）。</p>
<h2 id="u6807_u51C6_u6D41"><a href="#u6807_u51C6_u6D41" class="headerlink" title="标准流"></a>标准流</h2><p>标准输入流：<code>System.in</code>。<br>标准输出流：<code>System.out</code>，<code>System.error</code>。</p>
<p>因为历史原因，这些标准流均为<em>字节流</em>，而非字符流。需要转化时可以通过<code>InputStreamReader</code>进行转化，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStreamReader cin = <span class="keyword">new</span> InputStreamReader(System.in)</span><br></pre></td></tr></table></figure>
<h2 id="Console"><a href="#Console" class="headerlink" title="Console"></a>Console</h2><p><code>Console</code>是更强大的标准流，同时提供了输入流和输出流，并且是字符流。还有一个安全特性是针对密码输入时设计。</p>
<ul>
<li>无public构造函数：使用时，通过System获取，<code>System.console()</code>。</li>
<li>readPassword：返回一个字符（char）数组，不再使用时可以将其重写置空，从内存中删除。</li>
</ul>
<h2 id="u6570_u636E_u6D41_uFF08DataStream_uFF09"><a href="#u6570_u636E_u6D41_uFF08DataStream_uFF09" class="headerlink" title="数据流（DataStream）"></a>数据流（DataStream）</h2><p>对输入/输出字节流的包装，方便程序中输入/输出基本类型以及String。</p>
<p>因为DataStream操作的是字节流，所以在使用时可以使用缓存流<code>BufferedInputStream</code>和<code>BufferedOutputStream</code>。</p>
<p>与其他流不同的地方是检测输入结束的条件，它是通过catch<code>EOFException</code>，而不是检测返回值，参见一下具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span> <span class="title">readByte</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ch = in.read();</span><br><span class="line">    <span class="keyword">if</span> (ch &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">byte</span>)(ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u5BF9_u8C61_u6D41_uFF08Object_Stream_uFF09"><a href="#u5BF9_u8C61_u6D41_uFF08Object_Stream_uFF09" class="headerlink" title="对象流（Object Stream）"></a>对象流（Object Stream）</h2><p>对象流包括<code>ObjectInputSteam</code>和<code>ObjectOutputStream</code>，实现的接口分别为<code>ObjectInput</code>和<code>ObjectOutput</code>（继承于数据流接口<code>DataInput</code>）。这也意味着在数据流中所有基本数据类型相关的方法，在对象流中都有相应的实现。</p>
<p><code>ObjectInputSteam</code>用来反序列化那些用<code>ObjectOutputStream</code>序列化的基本数据类型和对象。而<code>ObjectOutputStream</code>则是一种将对象持久化的方法。</p>
<h3 id="u590D_u6742_u5BF9_u8C61_u7684_u8F93_u5165_u6D41_u4E0E_u8F93_u51FA_u6D41"><a href="#u590D_u6742_u5BF9_u8C61_u7684_u8F93_u5165_u6D41_u4E0E_u8F93_u51FA_u6D41" class="headerlink" title="复杂对象的输入流与输出流"></a>复杂对象的输入流与输出流</h3><ul>
<li>当一个对象引用了其他对象时，其所有引用都会被写入流中。</li>
<li>当多个对象引用了同一个对象时，被引用的对象在流中只会存在一份。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>流（Stream）是java中输入和输出经常涉及也是最简单的概念。Java中存在各种各样的流，字符流、字节流、缓存流、基本数据流、对象流等。Java持久化中谈及的序列化与反序列化同样离不开流（将整个对象写入流中，并可以从流中获取整个对象）。</p>]]>
    
    </summary>
    
      <category term="IO" scheme="http://www.xiaoyuxee.com/tags/IO/"/>
    
      <category term="Java-Core" scheme="http://www.xiaoyuxee.com/categories/Java-Core/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java8中的Stream]]></title>
    <link href="http://www.xiaoyuxee.com/2016/02/06/aggregate-operation-in-java8/"/>
    <id>http://www.xiaoyuxee.com/2016/02/06/aggregate-operation-in-java8/</id>
    <published>2016-02-06T06:41:16.000Z</published>
    <updated>2016-02-06T19:45:54.000Z</updated>
    <content type="html"><![CDATA[<p>Java8中为集合类<code>Collection</code>引入了新的特性：流<code>Stream</code>，使得基于集合的操作更加简洁、直观。为了更好的理解<code>Stream</code>，需要对Lambda表达式和方法引用有一定的认知，参见前一篇Note：<a href="http://www.xiaoyuxee.com/2016/02/05/lambda-in-java8/">Java8中的Lambda表达式</a>。</p>
<a id="more"></a>
<h2 id="u5F15_u5B50"><a href="#u5F15_u5B50" class="headerlink" title="引子"></a>引子</h2><p>当我们遍历一个集合并进行打印时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Person p : persons) &#123;</span><br><span class="line">    System.out.println(p.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>Stream</code>、Lambda表达式后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">persons</span><br><span class="line">    .stream()</span><br><span class="line">    .forEach(p -&gt; System.out.println(p.getName()));</span><br></pre></td></tr></table></figure>
<h2 id="u6D41Stream"><a href="#u6D41Stream" class="headerlink" title="流Stream"></a>流<code>Stream</code></h2><p>流<code>Stream</code>指的是一系列元素，但不像集合<code>Collection</code>，它不是用来存储元素的数据结构，而是通过管道（pipeline）而携带元素。通过集合中的<code>java.util.Collection.stream()</code>方法可以获得。</p>
<h2 id="u7BA1_u9053pipeline"><a href="#u7BA1_u9053pipeline" class="headerlink" title="管道pipeline"></a>管道pipeline</h2><p>管道（pipeline）指的是一系列的集成操作。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">persons</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(p -&gt; p.getAge() &gt;= <span class="number">18</span>)</span><br><span class="line">    .forEach(p -&gt; System.out.println(p.getName()));</span><br></pre></td></tr></table></figure>
<p>管道一般由以下几部分组成：</p>
<ul>
<li>来源：可能是集合、数组、生成函数或者I/O管道。</li>
<li>中间操作：比如过滤器<code>filter</code>，产生一个新的管道（pipeline）</li>
<li>终止操作：比如<code>forEach</code>。</li>
</ul>
<p>比如，统计<em>年龄≥18岁的person的平均年龄</em>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">persons</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(p -&gt; p.getAge() &gt;= <span class="number">18</span>)</span><br><span class="line">    .mapToInt(Person::getAge)</span><br><span class="line">    .average()</span><br><span class="line">    .getAsDouble();</span><br></pre></td></tr></table></figure>
<p>上例中，<code>mapToInt</code>操作产生了一个类型为<code>IntStream</code>的新流，包换所有<em>年龄≥18岁的person的年龄流</em>。</p>
<p><code>average</code>操作将计算<code>IntStream</code>中所有元素的平均值。JDK中提供了很多类似<code>average</code>终止操作，组合流中内容并返回一个值。这类操作叫做<a href="http://docs.oracle.com/javase/tutorial/collections/streams/reduction.html" target="_blank" rel="external">reduction</a>。</p>
<h2 id="Reduction"><a href="#Reduction" class="headerlink" title="Reduction"></a><code>Reduction</code></h2><p>类似于<code>average</code>，统计流Stream中内容而返回一个值，还有<code>sum</code>、<code>min</code>、<code>max</code>、<code>count</code>。此外，JDK还提供返回集合的终止操作。</p>
<p>当然，JDK还提供了更加通用的<code>reduce</code>和<code>collect</code>方法。</p>
<h3 id="reduce_u65B9_u6CD5"><a href="#reduce_u65B9_u6CD5" class="headerlink" title="reduce方法"></a><code>reduce</code>方法</h3><p>例如，我们要统计<em>年龄≥18岁的person的年龄之和</em>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">persons</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(p -&gt; p.getAge() &gt;= <span class="number">18</span>)</span><br><span class="line">    .mapToInt(Person::getAge)</span><br><span class="line">    .sum();</span><br></pre></td></tr></table></figure>
<p>这里用到了<code>sum</code>终结操作，计算所有<code>IntStream</code>中内容之和。如果使用<code>reduce</code>则可以这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">persons</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(p -&gt; p.getAge() &gt;= <span class="number">18</span>)</span><br><span class="line">    .mapToInt(Person::getAge)</span><br><span class="line">    .reduce(<span class="number">0</span>, Math::addExact);</span><br></pre></td></tr></table></figure>
<p>查询<code>sum</code>源码可以发现，其实也是如此：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于<code>reduce</code>有三个方法：</p>
<h4 id="Optional_26lt_3BT_26gt_3B_reduce_28BinaryOperator_26lt_3BT_26gt_3B_accumulator_29__u7528_u4E8E_u5BFB_u627E_u6700_u5927_u503C_u3001_u6700_u5C0F_u503C_u7B49"><a href="#Optional_26lt_3BT_26gt_3B_reduce_28BinaryOperator_26lt_3BT_26gt_3B_accumulator_29__u7528_u4E8E_u5BFB_u627E_u6700_u5927_u503C_u3001_u6700_u5C0F_u503C_u7B49" class="headerlink" title="Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator) 用于寻找最大值、最小值等"></a><code>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</code> 用于寻找最大值、最小值等</h4><h4 id="T_reduce_28T_identity_2C_BinaryOperator_26lt_3BT_26gt_3B_accumulator_29__u9002_u5408_u4E8E_u6709_u7D2F_u52A0_u884C_u4E3A"><a href="#T_reduce_28T_identity_2C_BinaryOperator_26lt_3BT_26gt_3B_accumulator_29__u9002_u5408_u4E8E_u6709_u7D2F_u52A0_u884C_u4E3A" class="headerlink" title="T reduce(T identity, BinaryOperator&lt;T&gt; accumulator) 适合于有累加行为"></a><code>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code> 适合于有累加行为</h4><p><code>reduce</code>操作包含两个参数：</p>
<ul>
<li>标识：reduce操作的初始化值以及默认值（如果流中没有元素）</li>
<li>累加器：累加器包含两个参数：requce操作的<em>部分结果和下一个流中内容的值</em>，然后返回一个新的局部结果。</li>
</ul>
<p><code>reduce</code>操作时，累加器每次都返回一个新的值。假如你的操作是返回一个更加复杂的对象，比如集合，那么就需要为你的程序担忧了。因为其效率是非常低的，正确的做法是<em>更新已经存在的集合</em>。这就是<code>collect</code>方法。</p>
<h3 id="collect_u65B9_u6CD5"><a href="#collect_u65B9_u6CD5" class="headerlink" title="collect方法"></a><code>collect</code>方法</h3><p>假如你要收集所有<em>年龄≥18岁的person的人名</em>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">persons</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(p -&gt; p.getAge() &gt;= <span class="number">18</span>)</span><br><span class="line">    .map(Person::getName)</span><br><span class="line">    .collect(ArrayList::<span class="keyword">new</span>, ArrayList::add, ArrayList::addAll);</span><br></pre></td></tr></table></figure>
<p><code>collect</code>有两个方法：</p>
<h4 id="R_collect__28Supplier_26lt_3BR_26gt_3B_2C_BiConsumer_26lt_3BR_2C__3F_super_T_26gt_3B_2C_BiConsumer_26lt_3BR_2C_R_26gt_3B_29"><a href="#R_collect__28Supplier_26lt_3BR_26gt_3B_2C_BiConsumer_26lt_3BR_2C__3F_super_T_26gt_3B_2C_BiConsumer_26lt_3BR_2C_R_26gt_3B_29" class="headerlink" title="R collect (Supplier&lt;R&gt;, BiConsumer&lt;R, ? super T&gt;, BiConsumer&lt;R, R&gt;)"></a><code>R collect (Supplier&lt;R&gt;, BiConsumer&lt;R, ? super T&gt;, BiConsumer&lt;R, R&gt;)</code></h4><ul>
<li>第一个参数Supplier：用于初始化返回结果</li>
<li>第二个参数BiConsumer： 用于操作<em>部分结果与下一个流内容</em></li>
<li>第二个参数BiConsumer： 用于<em>合并操作</em></li>
</ul>
<h4 id="26lt_3BR_2C_A_26gt_3B_R_collect_28Collector_26lt_3B_3F_super_T_2C_A_2C_R_26gt_3B_collector_29"><a href="#26lt_3BR_2C_A_26gt_3B_R_collect_28Collector_26lt_3B_3F_super_T_2C_A_2C_R_26gt_3B_collector_29" class="headerlink" title="&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector)"></a><code>&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector)</code></h4><p><code>Collector</code>将上述<em>初始化</em>、<em>部分接口与下一个流内容操作</em>、<em>合并</em>封装了起来，并且在<code>java.util.stream.Collectors</code>中提供了一些常用的collector，如<code>toList</code>、<code>toSet</code>等。</p>
<p>上述收集所有<em>年龄≥18岁的person的人名</em>的例子可以改写为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">persons</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(p -&gt; p.getAge() &gt;= <span class="number">18</span>)</span><br><span class="line">    .map(Person::getName)</span><br><span class="line">    .collect(Collectors.toList()));</span><br></pre></td></tr></table></figure>
<p><code>Collectors.groupingBy(classifier)</code>用于分组，返回一个key为<code>classifier</code>分类的标准，value为ArrayList的Map。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">persons</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(Collectors.groupingBy(Person::getGender)));</span><br></pre></td></tr></table></figure>
<p>如果要将persons按性别分组，返回其name：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">persons</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(Collectors.groupingBy(</span><br><span class="line">            Person::getGender,</span><br><span class="line">            Collectors.mapping(Person::getName, Collectors.toList()))));</span><br></pre></td></tr></table></figure>
<p>如果要将persons按性别分组，返回每组的年龄总数/年龄最大值/平均年龄：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 年龄和</span></span><br><span class="line">persons</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(Collectors.groupingBy(</span><br><span class="line">            Person::getGender,</span><br><span class="line">            Collectors.mapping(</span><br><span class="line">                    Person::getAge, </span><br><span class="line">                    Collectors.reducing(<span class="number">0</span>, Math::addExact)))));</span><br><span class="line"><span class="comment">// 年龄和</span></span><br><span class="line">persons</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(Collectors.groupingBy(</span><br><span class="line">            Person::getGender,</span><br><span class="line">            Collectors.reducing(<span class="number">0</span>, Person::getAge, Math::addExact))));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 年龄最大值</span></span><br><span class="line">persons</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(Collectors.groupingBy(</span><br><span class="line">            Person::getGender,</span><br><span class="line">            Collectors.mapping(</span><br><span class="line">                    Person::getAge, </span><br><span class="line">                    Collectors.reducing(Math::max)))));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 年龄平均值</span></span><br><span class="line">persons</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(Collectors.groupingBy(</span><br><span class="line">            Person::getGender,</span><br><span class="line">            Collectors.averagingInt(Person::getAge))));</span><br></pre></td></tr></table></figure>
<h2 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h2><p><a href="http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html" target="_blank" rel="external">http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Java8中为集合类<code>Collection</code>引入了新的特性：流<code>Stream</code>，使得基于集合的操作更加简洁、直观。为了更好的理解<code>Stream</code>，需要对Lambda表达式和方法引用有一定的认知，参见前一篇Note：<a href="http://www.xiaoyuxee.com/2016/02/05/lambda-in-java8/">Java8中的Lambda表达式</a>。</p>]]>
    
    </summary>
    
      <category term="Aggregate-Operation" scheme="http://www.xiaoyuxee.com/tags/Aggregate-Operation/"/>
    
      <category term="Java8" scheme="http://www.xiaoyuxee.com/tags/Java8/"/>
    
      <category term="Stream" scheme="http://www.xiaoyuxee.com/tags/Stream/"/>
    
      <category term="Java-Core" scheme="http://www.xiaoyuxee.com/categories/Java-Core/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java8中的Lambda表达式]]></title>
    <link href="http://www.xiaoyuxee.com/2016/02/05/lambda-in-java8/"/>
    <id>http://www.xiaoyuxee.com/2016/02/05/lambda-in-java8/</id>
    <published>2016-02-04T16:43:08.000Z</published>
    <updated>2016-02-08T02:30:34.000Z</updated>
    <content type="html"><![CDATA[<p>Lambda表达式是Java8引进的新特性，用一句话概括为：<em>更紧凑的表达仅有一个方法的接口实例</em>。</p>
<a id="more"></a>
<h2 id="Lambda_u8868_u8FBE_u5F0F_u5982_u4F55_u800C_u6765"><a href="#Lambda_u8868_u8FBE_u5F0F_u5982_u4F55_u800C_u6765" class="headerlink" title="Lambda表达式如何而来"></a>Lambda表达式如何而来</h2><p>我们在日常编程中经常会遇到只有一个方法的接口，如<code>Runnable</code>，只有一个<code>void run()</code>方法。在Java8之前是不支持接口中的方法带有默认实现的，所以在Java8中，Lambda表达式更准确得讲为：<em>更紧凑的表达仅有一个抽象方法的接口实例</em>，因为Jaba8中可以有<a href="http://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html" target="_blank" rel="external">默认实现的方法</a>和<a href="http://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html#static" target="_blank" rel="external">静态方法</a>。</p>
<p>特别地，在使用策略模式时，经常会使用匿名类来实现某个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, Operation operator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> operator.calculate(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"1 + 2 = "</span> + calculate(<span class="number">1</span>, <span class="number">2</span>, <span class="keyword">new</span> Operation()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在引入Lambda表达式之后，上面的例子就可改写为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"1 + 2 = "</span> + calculate(<span class="number">1</span>, <span class="number">2</span>, (a, b) -&gt; a + b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>较之前的匿名类而言，更加简洁、直观、紧凑。</p>
<h2 id="Lambda_u8868_u8FBE_u5F0F_u7684_u8BED_u6CD5"><a href="#Lambda_u8868_u8FBE_u5F0F_u7684_u8BED_u6CD5" class="headerlink" title="Lambda表达式的语法"></a>Lambda表达式的语法</h2><p>一个Lambda表达式由以下几部分组成：</p>
<ul>
<li><p>一个在闭合圆括号中用逗号分隔的参数列表。<br>如：<code>calculate(1, 3, (int a, int b) -&gt; a + b)</code>。<br><em>Note</em>：在Lambda表达式中，<em>可以省略数据类型</em>。此外，<em>如果仅有一个参数时，也可以将圆括号省略</em>：<code>a -&gt; a.foo()</code>。</p>
</li>
<li><p><code>-&gt;</code></p>
</li>
<li><p>表达体：一个单独的表达式 或者 区块。<br>如：<code>a &gt; 0 &amp;&amp; b &gt;0</code> 或者 <code>{ return a &gt; 0 &amp;&amp; b &gt; 0; }</code>。当然，如果返回值为<code>void</code>时，完全没必要写成后者形式。</p>
</li>
</ul>
<h2 id="JDK_u5BF9Lambda_u8868_u8FBE_u5F0F_u7684_u652F_u6301"><a href="#JDK_u5BF9Lambda_u8868_u8FBE_u5F0F_u7684_u652F_u6301" class="headerlink" title="JDK对Lambda表达式的支持"></a>JDK对Lambda表达式的支持</h2><p>Java8中引入注释<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html" target="_blank" rel="external">FunctionalInterface</a>，用于标识功能性接口<a href="http://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html#package.description" target="_blank" rel="external"></a>。</p>
<p>在<code>java.util.function</code>包中提供了大量的通用功能性接口：<code>Function</code>、<code>Consumer</code>、<code>Predicate</code>：</p>
<ul>
<li><code>Function</code>：<code>R apply(T t)</code></li>
<li><code>Consumer</code>：<code>void accept(T t)</code></li>
<li><code>Predicate</code>：<code>boolean test(T t)</code></li>
<li><code>Supplier</code>：<code>T get()</code></li>
</ul>
<p>还包括一些指定数据类型的<code>ToIntFunction</code>、<code>LongConsumer</code>等。</p>
<p>使用JDK中提供的标准接口可以将上例改写为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, ToIntBiFunction&lt;Integer, Integer&gt; operator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> operator.applyAsInt(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"1 + 2 = "</span> + calculate(<span class="number">1</span>, <span class="number">2</span>, (a, b) -&gt; a + b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Lambda_u8868_u8FBE_u5F0F_u7684_u76EE_u6807_u7C7B_u578B"><a href="#Lambda_u8868_u8FBE_u5F0F_u7684_u76EE_u6807_u7C7B_u578B" class="headerlink" title="Lambda表达式的目标类型"></a>Lambda表达式的目标类型</h2><p>Java编译器会通过调用时的上下文或者Lambda表达式的位置来决定其表达式的类型。</p>
<p>例如，当你自己定义一个相同功能的功能性接口进行使用时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, Operation operator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> operator.calculate(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>(a, b) -&gt; a + b)</code>的类型为<code>Operation</code>，当你使用JDK提供的标准接口时类型为：<code>ToIntBiFunction</code>。</p>
<h3 id="u76EE_u6807_u7C7B_u578B_u548C_u65B9_u6CD5_u53C2_u6570"><a href="#u76EE_u6807_u7C7B_u578B_u548C_u65B9_u6CD5_u53C2_u6570" class="headerlink" title="目标类型和方法参数"></a>目标类型和方法参数</h3><p>比如下面两个可调用的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    r.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">invoke</span><span class="params">(Callable&lt;T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c.call();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当执行 <code>String s = invoke(() -&gt; &quot;done&quot;);</code> 时，调用的方法为 <code>invoke(Callable&lt;T&gt; c)</code>，因为这个方法返回了值。所有Lambda表达式的类型为<code>Callable&lt;T&gt;</code>。</p>
<h2 id="u672C_u5730_u53D8_u91CF_u7684_u8BBF_u95EE"><a href="#u672C_u5730_u53D8_u91CF_u7684_u8BBF_u95EE" class="headerlink" title="本地变量的访问"></a>本地变量的访问</h2><p>Lambda表达式中并不会产生一个新的局部变量，所以你不能再表达式的参数列表中包含上一次的局部变量，但是你可以在表达体中直接使用这些的变量。</p>
<p>当然，同内部类、匿名类一样，这些被Lambda表达式使用的变量必须是<code>final</code>类型，否则编译器会提示你：</p>
<blockquote>
<p>local variables referenced from a lambda expression must be final or effectively final。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Lambda expression's parameter a cannot redeclare another local variable  </span></span><br><span class="line">    <span class="comment">// defined in an enclosing scope.</span></span><br><span class="line">    <span class="comment">// int a = 0;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">    System.out.println(<span class="string">"1 + 2 = "</span> + calculate(<span class="number">1</span>, <span class="number">2</span>, (a, b) -&gt; a + b + c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u65B9_u6CD5_u5F15_u7528"><a href="#u65B9_u6CD5_u5F15_u7528" class="headerlink" title="方法引用"></a>方法引用</h2><p>还是上面的例子：计算两个数字之和。<code>java.lang.Math</code>中提供了相关api：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">addExact</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = x + y;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (((x ^ r) &amp; (y ^ r)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException(<span class="string">"integer overflow"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以上述例子可以改写为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"1 + 2 = "</span> + calculate(<span class="number">1</span>, <span class="number">3</span>, </span><br><span class="line">        <span class="keyword">new</span> ToIntBiFunction&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">applyAsInt</span><span class="params">(Integer t, Integer u)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Math.addExact(t, u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br></pre></td></tr></table></figure>
<p>此处的功能接口中实际上调用的是<code>addExact</code>方法，Java8中支持方法的引用，可以写得更简洁 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"1 + 2 = "</span> + calculate(<span class="number">1</span>, <span class="number">3</span>, Math::addExact));</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>Lambda表达式是Java8引进的新特性，用一句话概括为：<em>更紧凑的表达仅有一个方法的接口实例</em>。</p>]]>
    
    </summary>
    
      <category term="Java8" scheme="http://www.xiaoyuxee.com/tags/Java8/"/>
    
      <category term="Lambda" scheme="http://www.xiaoyuxee.com/tags/Lambda/"/>
    
      <category term="Java-Core" scheme="http://www.xiaoyuxee.com/categories/Java-Core/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Wiring Beans In Spring]]></title>
    <link href="http://www.xiaoyuxee.com/2016/01/30/wiring-beans-in-spring/"/>
    <id>http://www.xiaoyuxee.com/2016/01/30/wiring-beans-in-spring/</id>
    <published>2016-01-29T16:43:26.000Z</published>
    <updated>2016-02-08T02:28:37.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://martinfowler.com/articles/injection.html" target="_blank" rel="external">控制反转和依赖注入</a>是Spring的核心功能，也是其他模块的基石。Spring容器控制着bean的生命周期，并维护其之间的依赖关系。如何在容器中装配（配置）这些bean是学习Spring的基础。</p>
<p>本文将介绍如何在Spring4.0中进行bean的装配，及每种方式的特点。</p>
<a id="more"></a>
<h2 id="u81EA_u52A8_u88C5_u914D_uFF08Automatically_uFF09"><a href="#u81EA_u52A8_u88C5_u914D_uFF08Automatically_uFF09" class="headerlink" title="自动装配（Automatically）"></a>自动装配（Automatically）</h2><p><code>@ComponentScan</code>：用于指定扫描路径，将所有带有注解<code>@Component</code>的类注册到ioc容器中进行管理。也可以通过XML类配置<code>&lt;context:component-scan&gt;</code>。</p>
<ul>
<li><code>basePackages</code>：当没有指定扫描的包名时，默认扫描当前配置所在的包</li>
<li><code>basePackageClasses</code>：使用<code>basePackages</code>可能会遇到一个问题：重构包名时，扫描将会失效。那么我们可以指定扫描类所在的包。有个技巧为：<em>在预想扫描的包里创建一个标记类，用于标记扫描的包</em>。</li>
</ul>
<p><code>@Component</code>：用于说明该类将会注册到ioc容器中。</p>
<ul>
<li>id：当没有指定id时，id为首字母小写的类名，如：beanFactory，当类为BeanFactory时。</li>
<li><code>@Named</code>：与<code>@Component</code>有同样的功效，它是<a href="https://jcp.org/en/jsr/detail?id=330" target="_blank" rel="external">Dependency Injection for Java</a>中的规范。<em>不建议使用</em>，因为其语义很差劲。</li>
</ul>
<p><code>@AutoWired</code>：告诉ioc容器，帮其自动解决（某方法）的依赖关系。</p>
<ul>
<li>使用范围：适用于构造函数、以及其他任何函数。</li>
<li><code>Inject</code>：同<code>@AutoWired</code>。</li>
</ul>
<h2 id="Java_u4EE3_u7801_u88C5_u914D_uFF08Java-based_uFF09"><a href="#Java_u4EE3_u7801_u88C5_u914D_uFF08Java-based_uFF09" class="headerlink" title="Java代码装配（Java-based）"></a>Java代码装配（Java-based）</h2><p>虽然自动装配非常的诱人，简介而高效，但有些场景却无法适用。比如，当依赖一些第三方的jar包时，我们没有源码，没有办法为他们添加类似于<code>@Component</code>的注解，那我们必须在配置中明确指定依赖关系。</p>
<p><code>Configuration</code>：表示此类为配置文件，其中包含将要注册到容器中的Bean。</p>
<p><code>Bean</code>：表示此方法将会返回一个对象，并需要将其注册到容器中进行管理。</p>
<ul>
<li>id：默认id为<em>方法名</em>，当然也可以显式的指定：<code>name=&quot;foo&quot;</code>。</li>
<li>依赖关系：可以通过调用通一个配置里的方法，或者构造函数解决（不在同一个配置项中时）。</li>
</ul>
<h2 id="XML_u6587_u4EF6_u88C5_u914D_uFF08XML_uFF09"><a href="#XML_u6587_u4EF6_u88C5_u914D_uFF08XML_uFF09" class="headerlink" title="XML文件装配（XML）"></a>XML文件装配（XML）</h2><p>XML文件配置Spring历史悠久，Spring刚面世时就是基于XML来配置bean，甚至在大多数人眼中有这样的观念：spring就是XML配置。</p>
<h2 id="Java-based_with_xml"><a href="#Java-based_with_xml" class="headerlink" title="Java-based with xml"></a>Java-based with xml</h2><p>使用java-based配置时，可以引入别的java-based配置以及xml配置：</p>
<ul>
<li><code>@Import</code>：引入其他java-based配置</li>
<li><code>@ImportResource</code>：引入xml配置</li>
</ul>
<p><code>注意</code>：这里的xml必须要携带完整的路径（包括包路径），<br>如：<code>@ImportResource(&quot;classpath:/com/osceola/soundsystem/cd-config.xml&quot;)</code></p>
<h2 id="Xml_with_java-based"><a href="#Xml_with_java-based" class="headerlink" title="Xml with java-based"></a>Xml with java-based</h2><p>在使用xml配置时，同样可以引入别的xml配置和java-based配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">import</span> <span class="attribute">resource</span>=<span class="value">"config.xml"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"Config"</span> /&gt;</span> <span class="comment">&lt;!-- 想配置bean一样将java-based类配置进来 --&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="u63A8_u8350"><a href="#u63A8_u8350" class="headerlink" title="推荐"></a>推荐</h2><p><code>Automatically</code> &gt; <code>Java-based</code> &gt; <code>XML</code></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://martinfowler.com/articles/injection.html">控制反转和依赖注入</a>是Spring的核心功能，也是其他模块的基石。Spring容器控制着bean的生命周期，并维护其之间的依赖关系。如何在容器中装配（配置）这些bean是学习Spring的基础。</p>
<p>本文将介绍如何在Spring4.0中进行bean的装配，及每种方式的特点。</p>]]>
    
    </summary>
    
      <category term="Wiring-Beans" scheme="http://www.xiaoyuxee.com/tags/Wiring-Beans/"/>
    
      <category term="Spring" scheme="http://www.xiaoyuxee.com/categories/Spring/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java应用中的数据库访问]]></title>
    <link href="http://www.xiaoyuxee.com/2016/01/24/database-access-in-java/"/>
    <id>http://www.xiaoyuxee.com/2016/01/24/database-access-in-java/</id>
    <published>2016-01-24T05:56:04.000Z</published>
    <updated>2016-02-08T01:56:38.000Z</updated>
    <content type="html"><![CDATA[<p>早起对数据库的访问，都是直接调用数据库厂商提供的专有API。<a href="https://zh.wikipedia.org/zh-cn/ODBC" target="_blank" rel="external">ODBC(Open Database Connectivity)</a>是微软开放服务结构（WOSA，Windows Open Service Architecture）中有关数据库的一部分，提供了Windows下统一的数据库访问方式。使用者只需要调用ODBC API，由ODBC驱动程序将调用请求转化为对特定数据库的调用请求。</p>
<p>Java语言问世后，Sun公司与1996年推出了<a href="https://zh.wikipedia.org/zh-cn/Java%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5" target="_blank" rel="external">JDBC(Java Database Connectivity)</a>，提供了对数据库访问的统一方式。JDBC是一套标准的访问关系数据库的Java类库，同时为数据库厂商提供了一个标准的API，让厂商为自己的数据库产品提供相应的JDBC驱动程序。应用程序调用JDBC API，由JDBC驱动程序（具体数据库厂商的实现层）处理与数据库的通信，从而使应用程序与具体数据库产品解耦。</p>
<a id="more"></a>
<h2 id="u52A0_u8F7D_u6CE8_u518C_u6570_u636E_u5E93_u9A71_u52A8"><a href="#u52A0_u8F7D_u6CE8_u518C_u6570_u636E_u5E93_u9A71_u52A8" class="headerlink" title="加载注册数据库驱动"></a>加载注册数据库驱动</h2><h3 id="Drive_u63A5_u53E3"><a href="#Drive_u63A5_u53E3" class="headerlink" title="Drive接口"></a>Drive接口</h3><p><code>javax.sql.Driver</code>是所有JDBC驱动程序需要实现的接口。</p>
<p>其中，<code>connect(url, info)</code>方法用于建立到数据到的连接。而在实际的应用程序中，不需要直接调用此方法，而是通过JDBC驱动程序管理器<code>DriverManager</code>注册相应的驱动程序，使用驱动管理器来建立数据库连接。</p>
<h3 id="u52A0_u8F7D_u6CE8_u518CJDBC_u9A71_u52A8"><a href="#u52A0_u8F7D_u6CE8_u518CJDBC_u9A71_u52A8" class="headerlink" title="加载注册JDBC驱动"></a>加载注册JDBC驱动</h3><p>加载JDBC驱动通过<code>Class.forName(String className)</code>在CLASSPATH中定位、加载驱动类。</p>
<p>注册JDBC驱动实例则是通过<code>Driver.registerDriver(Driver driver)</code>来完成。通常，不需要我们亲自去注册，因为实现了<code>Driver</code>的驱动类都包含一个静态区，调用驱动管理器的静态方法来注册自己的一个实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Driver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// Required for Class.forName().newInstance()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u5EFA_u7ACB_u5230_u6570_u636E_u5E93_u7684_u8FDE_u63A5"><a href="#u5EFA_u7ACB_u5230_u6570_u636E_u5E93_u7684_u8FDE_u63A5" class="headerlink" title="建立到数据库的连接"></a>建立到数据库的连接</h2><p>通过<code>DriverManager.getConnection(String url, String user, String password)</code>建立到数据库的连接（代理给相应的驱动程序）</p>
<h3 id="JDBC_URL"><a href="#JDBC_URL" class="headerlink" title="JDBC URL"></a>JDBC URL</h3><p><code>jdbc:subprotocol:subname</code>：</p>
<ul>
<li>协议：jdbc，唯一允许的协议</li>
<li>子协议：标识一个数据库驱动程序，如mysql、sqlserver</li>
<li>子名称：与具体数据库驱动有关，如mysql中：jdbc:mysql://localhost:3306/database</li>
</ul>
<h2 id="u6570_u636E_u5E93_u8BBF_u95EE"><a href="#u6570_u636E_u5E93_u8BBF_u95EE" class="headerlink" title="数据库访问"></a>数据库访问</h2><p>数据库访问通过建立的连接的来访问，有3种方式<code>Statement</code>、<code>PreparedStatement</code>、<code>CallableStatement</code>。</p>
<h3 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h3><p>用于执行静态的SQL语句，通过<code>Connection.createStatement()</code>来创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Statement</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 执行查询语句 */</span></span><br><span class="line">    <span class="function">ResultSet <span class="title">executeQuery</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 用于执行INSERT、UPDATE、DELETE等语句 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 通过`addBatch()`批量添加sql命令，然后一起执行 */</span></span><br><span class="line">    <span class="keyword">int</span>[] executeBatch() <span class="keyword">throws</span> SQLException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h3><p><code>ResultSet</code>以<em>逻辑表格</em>封装了数据库执行结果，由数据库厂商来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResultSet</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 将游标移动到下一行，如果该行有数据返回`true`，否则返回`false` */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 通过索引（1开始）查看某列数据 **/</span></span><br><span class="line">    <span class="function">String <span class="title">getString</span><span class="params">(<span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 通过列名称查看某列数据 **/</span></span><br><span class="line">    <span class="function">String <span class="title">getString</span><span class="params">(String columnLabel)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h3><p>sql语句在执行以前需要预编译，包括语句分析、代码优化等。如果仅仅是参数不同的sql语句，可以使用<code>PreparedStatement</code>。</p>
<h3 id="ResultSetMetaData"><a href="#ResultSetMetaData" class="headerlink" title="ResultSetMetaData"></a>ResultSetMetaData</h3><p>用于描述数据库表结构的元数据， <code>ResultSet.getMetaData()</code></p>
<h2 id="u4E8B_u52A1_u5904_u7406"><a href="#u4E8B_u52A1_u5904_u7406" class="headerlink" title="事务处理"></a>事务处理</h2><ul>
<li>脏读（dirty read）<br>一个事务对数据进行了修改，但没有提交，与此同时另外一个事务读取了被修改的数据。如若前一个事务发生回滚，那么后一个事务读取的数据也就是无效数据。</li>
<li>不可重复读（non-repeatable read）<br>一个事务读取了一行数据，在事务结束以前另外一个事务对这行数据进行了修改，那么当前一个事务再次读取那部分数据时，得到了不同的数据。</li>
<li>幻读（phantom read）<br>一个事务查询某条件下的数据，事务结束之前另外一个事务又插入一些满足条件的数据，那么当第一个事务再次查询时发现数据多出几行。</li>
</ul>
<h3 id="Connection_u4E2D_u5173_u4E8E_u4E8B_u52A1_u9694_u79BB_u7EA7_u522B_u7684_u5E38_u91CF"><a href="#Connection_u4E2D_u5173_u4E8E_u4E8B_u52A1_u9694_u79BB_u7EA7_u522B_u7684_u5E38_u91CF" class="headerlink" title="Connection中关于事务隔离级别的常量"></a><code>Connection</code>中关于事务隔离级别的常量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Connection</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 不支持事务 */</span></span><br><span class="line">    <span class="keyword">int</span> TRANSACTION_NONE             = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 允许脏读 */</span></span><br><span class="line">    <span class="keyword">int</span> TRANSACTION_READ_UNCOMMITTED = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 不允许脏读，但允许不可重复我和幻读 */</span></span><br><span class="line">    <span class="keyword">int</span> TRANSACTION_READ_COMMITTED   = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 不允许脏读、不可重复读，但允许幻读 */</span></span><br><span class="line">    <span class="keyword">int</span> TRANSACTION_REPEATABLE_READ  = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 脏读、不可重复读、幻读均不允许 */</span></span><br><span class="line">    <span class="keyword">int</span> TRANSACTION_SERIALIZABLE     = <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mysql默认级别为：<code>TRANSACTION_READ_COMMITTED</code>, 禁止脏读、不可重复读。</p>
<p>而事务默认为<em>自动提交</em>，可通过<code>Connection.setAutoCommit(false)</code>来重置，自行提交（commit）或回滚（rollback）。</p>
<h2 id="JDBC_u6570_u636E_u6E90_u548C_u8FDE_u63A5_u6C60"><a href="#JDBC_u6570_u636E_u6E90_u548C_u8FDE_u63A5_u6C60" class="headerlink" title="JDBC数据源和连接池"></a>JDBC数据源和连接池</h2><p>对数据库的访问除了加载、实例化驱动程序并通过驱动程序管理器获得连接外，还可通过<code>DataSource</code>来实现（由数据库厂商实现）。</p>
<h3 id="u4EC0_u4E48_u662F_u8FDE_u63A5_u6C60"><a href="#u4EC0_u4E48_u662F_u8FDE_u63A5_u6C60" class="headerlink" title="什么是连接池"></a>什么是连接池</h3><p>建立数据库连接的成本是很大的，并且一个数据库服务器能够同时建立的连接数是有限的。在web应用中可能同时会有成千上万个访问数据库的请求，如果为每个请求创建一个数据库连接，性能将急剧下降。为了能够<em>重复利用数据库连接</em>，提高对请求的响应时间和服务器性能，于是诞生了数据库连接池。</p>
<p>数据库连接池预先建立了一些数据库连接，然后保存到连接池中，当有访问数据库的请求时，从池中取出一个闲置的连接对象完成对数据的访问，请求结束后将连接对象放回池中。</p>
<p>调用物理连接的<code>close</code>方法将关闭连接，而连接池的连接的<code>close</code>方法为释放连接对象放回连接池中。</p>
<p>大部分servlet容器都支持基于JNDI的数据库连接池的配置，如<a href="http://tomcat.apache.org/tomcat-9.0-doc/jndi-datasource-examples-howto.html" target="_blank" rel="external">Tomcat</a>，<a href="http://www.eclipse.org/jetty/documentation/current/jndi-datasource-examples.html" target="_blank" rel="external">Jetty</a>。</p>
<h3 id="u8FDE_u63A5_u6C60_u5B9E_u73B0"><a href="#u8FDE_u63A5_u6C60_u5B9E_u73B0" class="headerlink" title="连接池实现"></a>连接池实现</h3><ul>
<li><a href="http://commons.apache.org/proper/commons-dbcp/" target="_blank" rel="external">Apache Commons DBCP</a></li>
<li><a href="http://sourceforge.net/projects/c3p0/" target="_blank" rel="external">c3p0</a></li>
<li><a href="https://github.com/wwadge/bonecp" target="_blank" rel="external">bonecp</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>早起对数据库的访问，都是直接调用数据库厂商提供的专有API。<a href="https://zh.wikipedia.org/zh-cn/ODBC">ODBC(Open Database Connectivity)</a>是微软开放服务结构（WOSA，Windows Open Service Architecture）中有关数据库的一部分，提供了Windows下统一的数据库访问方式。使用者只需要调用ODBC API，由ODBC驱动程序将调用请求转化为对特定数据库的调用请求。</p>
<p>Java语言问世后，Sun公司与1996年推出了<a href="https://zh.wikipedia.org/zh-cn/Java%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5">JDBC(Java Database Connectivity)</a>，提供了对数据库访问的统一方式。JDBC是一套标准的访问关系数据库的Java类库，同时为数据库厂商提供了一个标准的API，让厂商为自己的数据库产品提供相应的JDBC驱动程序。应用程序调用JDBC API，由JDBC驱动程序（具体数据库厂商的实现层）处理与数据库的通信，从而使应用程序与具体数据库产品解耦。</p>]]>
    
    </summary>
    
      <category term="JDBC" scheme="http://www.xiaoyuxee.com/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac下高效地使用Eclipse]]></title>
    <link href="http://www.xiaoyuxee.com/2016/01/17/coding-effectively-with-eclipse-on-mac/"/>
    <id>http://www.xiaoyuxee.com/2016/01/17/coding-effectively-with-eclipse-on-mac/</id>
    <published>2016-01-17T11:04:43.000Z</published>
    <updated>2016-01-24T13:14:35.000Z</updated>
    <content type="html"><![CDATA[<blockquote><p>工欲善其事，必先利其器。</p>
<footer><strong>孔子，论语·卫灵公</strong></footer></blockquote>
<p><a href="http://www.eclipse.org/" target="_blank" rel="external">Eclipse</a>想必是很多同学每天接触的IDE，那么熟练使用eclipse中的快捷键，对每天coding效率的提升将会带来显著的提示。</p>
<a id="more"></a>
<h2 id="u6587_u4EF6_u4E0E_u5DE5_u7A0B_u7BA1_u7406"><a href="#u6587_u4EF6_u4E0E_u5DE5_u7A0B_u7BA1_u7406" class="headerlink" title="文件与工程管理"></a>文件与工程管理</h2><p><code>command</code>+<code>N</code>：新建文件/工程<br><code>command</code>+<code>shift</code>+<code>R</code>：快速打开文件，支持<code>?</code>、<code>*</code>匹配<br><code>command</code>+<code>I</code>：打开文件属性<br><code>option</code>+<code>I</code>：打开文件属性<br><code>command</code>+<code>S</code>：保存当前文件<br><code>command</code>+<code>shift</code>+<code>S</code>：保存所有文件<br><code>command</code>+<code>W</code>：关闭当前文件<br><code>command</code>+<code>shift</code>+<code>W</code>：关闭所有文件<br><code>F5</code>：从本地文件系统刷新资源</p>
<h2 id="u7F16_u8F91_u7A97_u53E3"><a href="#u7F16_u8F91_u7A97_u53E3" class="headerlink" title="编辑窗口"></a>编辑窗口</h2><p><code>command</code>+<code>shift</code>+<code>[</code>：返回上一个编辑的文件<br><code>command</code>+<code>shift</code>+<code>]</code>：返回下一个编辑的文件<br><code>control</code>+<code>M</code>：最大化/最小化当前窗口<br><code>command</code>+<code>E</code>：在打开的文件列表中切换<br><code>command</code>+<code>L</code>：跳至指定行</p>
<h2 id="u7F16_u8F91_u6587_u4EF6"><a href="#u7F16_u8F91_u6587_u4EF6" class="headerlink" title="编辑文件"></a>编辑文件</h2><p><code>command</code>+<code>C</code>：复制<br><code>command</code>+<code>X</code>：剪切<br><code>command</code>+<code>V</code>：黏贴<br><code>command</code>+<code>Z</code>：取消上步操作<br><code>command</code>+<code>shift</code>+<code>Z</code>：重新执行上步被取消的操作<br><code>command</code>+<code>D</code>：删除当前这一行<br><code>option</code>+<code>Arrow Up</code>/<code>Arrow Down</code>：向上/向下<em>移动</em>当前行或者当前选择的区块<br><code>command</code>+<code>option</code>+<code>Arrow Up</code>/<code>Arrow Down</code>：向上/向下<em>复制</em>当前行或者当前选择的区块<br><code>command</code>+<code>delete</code>：删除上一个单词<br><code>shift</code>+<code>enter</code>：在下一行插入编辑<br><code>command</code>+<code>shift</code>+<code>enter</code>：在上一行插入编辑<br><code>command</code>+<code>shift</code>+<code>X</code>：将选择区块全部变为大写<br><code>command</code>+<code>shift</code>+<code>Y</code>：将选择区块全部变为小写</p>
<h2 id="u641C_u7D22_u548C_u66FF_u6362"><a href="#u641C_u7D22_u548C_u66FF_u6362" class="headerlink" title="搜索和替换"></a>搜索和替换</h2><p><code>command</code>+<code>F</code>：打开<em>查找和替换</em>对话框<br><code>control</code>+<code>H</code>：在工作区间中搜索（java、task、file等）<br><code>control</code>+<code>J</code>：输入内容后，<em>正向</em>查找字符串<br><code>command</code>+<code>shift</code>+<code>J</code>：输入内容后，<em>反向</em>查找字符串</p>
<h2 id="u4EE3_u7801_u7F16_u8F91"><a href="#u4EE3_u7801_u7F16_u8F91" class="headerlink" title="代码编辑"></a>代码编辑</h2><p><code>command</code>+<code>I</code>：修正当前选择区块的缩进<br><code>command</code>+<code>shift</code>+<code>F</code>：格式化代码<br><code>command</code>+<code>/</code>：注释/取消注释当前行<br><code>command</code>+<code>control</code>+<code>/</code>：添加块注释<code>/* ... */</code><br><code>command</code>+<code>control</code>+<code>\</code>：取消块注释<br><code>command</code>+<code>option</code>+<code>J</code>：增加元素注释<code>/** ... *</code><br><code>command</code>+<code>1</code>：快速修复<br><code>command</code>+<code>shift</code>+<code>M</code>：增加<code>import</code><br><code>command</code>+<code>shift</code>+<code>O</code>：组织包<code>import</code><br><code>option</code>+<code>/</code>：代码提示</p>
<h2 id="u4EE3_u7801_u4FE1_u606F"><a href="#u4EE3_u7801_u4FE1_u606F" class="headerlink" title="代码信息"></a>代码信息</h2><p><code>command</code>+<code>O</code>：快速查看代码结构<br><code>command</code>+<code>T</code>：快速查看类型继承<br><code>command</code>+<code>shift</code>+<code>T</code>：搜索查看类<br><code>F2</code>：查看类、方法、变量注释说明<br><code>F3</code>：跳至类、方法、变量声明处<br><code>F4</code>：在类型继承窗口（视图）中打开<br><code>control</code>+<code>option</code>+<code>H</code>：查看类、方法调用层次<br><code>command</code>+<code>shift</code>+<code>U</code>：在当前类中查找表达式出现的地方<br><code>command</code>+move over method：打开方法声明或则实现</p>
<h2 id="u91CD_u6784"><a href="#u91CD_u6784" class="headerlink" title="重构"></a>重构</h2><p><code>control</code>+<code>option</code>+<code>R</code>：类、方法、变量等重命名<br><code>control</code>+<code>option</code>+<code>V</code>：方法移动<br><code>control</code>+<code>option</code>+<code>M</code>：抽取方法<br><code>control</code>+<code>option</code>+<code>L</code>：抽取本地变量<br><code>control</code>+<code>option</code>+<code>I</code>：内联收拢变量</p>
<h2 id="u8C03_u8BD5_u4E0E_u8FD0_u884C"><a href="#u8C03_u8BD5_u4E0E_u8FD0_u884C" class="headerlink" title="调试与运行"></a>调试与运行</h2><p><code>command</code>+<code>F11</code>：Run<br><code>shift</code>+<code>command</code>+<code>B</code>：设置断点<br><code>F5</code>：单步进入<br><code>F6</code>：下一行<br><code>F7</code>：跳出，进行下一步<br><code>F8</code>：调至下一个断点</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.shortcutworld.com/en/win/Eclipse.html" target="_blank" rel="external">Eclipse Shortcuts </a><br><a href="http://blog.csdn.net/jmyue/article/details/16960199" target="_blank" rel="external">玩转Eclipse — 快捷键设置及汇总</a><br><a href="http://www.codeaffine.com/2012/11/26/working-efficiently-with-junit-in-eclipse-2/" target="_blank" rel="external">Working Efficiently with JUnit in Eclipse</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote><p>工欲善其事，必先利其器。</p>
<footer><strong>孔子，论语·卫灵公</strong></footer></blockquote>
<p><a href="http://www.eclipse.org/">Eclipse</a>想必是很多同学每天接触的IDE，那么熟练使用eclipse中的快捷键，对每天coding效率的提升将会带来显著的提示。</p>]]>
    
    </summary>
    
      <category term="Eclipse" scheme="http://www.xiaoyuxee.com/tags/Eclipse/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Servlet3.0中配置DispatcherServlet]]></title>
    <link href="http://www.xiaoyuxee.com/2016/01/16/config-diapatcher-servlet-with-servlet3.0/"/>
    <id>http://www.xiaoyuxee.com/2016/01/16/config-diapatcher-servlet-with-servlet3.0/</id>
    <published>2016-01-15T16:08:30.000Z</published>
    <updated>2016-02-08T02:33:48.000Z</updated>
    <content type="html"><![CDATA[<p>大家都知道<code>DispatcherServelt</code>是 <em>spring-mvc</em> 中的前端控制器。按照传统的方式，可以在<code>web.xml</code>中配置这个 <em>servlet</em> 。</p>
<p>而在 <em>Servlet 3.0</em> 以后，支持通过注解配置 <em>servlet</em>、<em>listener</em>、<em>filter</em>等，同时也支持以注解方式配置<em>servlet container</em>，达到与配置<code>web.xml</code>一样的效果。</p>
<p>这篇文章主要介绍下<em>如何在Servlet 3.0下以 Java-Code 配置Servlet Container以及Dispatcher Servlet</em>。</p>
<a id="more"></a>
<h2 id="u4F20_u7EDFweb-xml_u4E2D_u5B9A_u4E49Servlet"><a href="#u4F20_u7EDFweb-xml_u4E2D_u5B9A_u4E49Servlet" class="headerlink" title="传统web.xml中定义Servlet"></a>传统web.xml中定义Servlet</h2><p>通过<code>web.xml</code>来配置一个web应用时，一般是这样子的：</p>
<figure class="highlight xml"><figcaption><span>code.1-web.xml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">web-app</span> <span class="attribute">xmlns</span>=<span class="value">"http://java.sun.com/xml/ns/javaee"</span> <span class="attribute">version</span>=<span class="value">"2.5"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>/WEB-INF/spring/dispatcher-config.xml<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="title">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="ServletContainerInitializer"><a href="#ServletContainerInitializer" class="headerlink" title="ServletContainerInitializer"></a>ServletContainerInitializer</h2><p>Servlet 3.0中，定义了一个接口：<code>javax.servlet.ServletContainerInitializer</code>，在Servlet 3.0下，将会在 <em>classpath</em> 下寻找该接口的实现，然后以此来配置Servlet Container。</p>
<blockquote>
<p>Implementations of this interface may be annotated with <code>HandlesTypes</code>, in order to receive (at their <code>onStartup</code> method) the Set of application classes that implement, extend, or have been annotated with the class types specified by the annotation. </p>
<p>Implementations of this interface must be declared by a JAR file resource located inside the <code>META-INF/services</code> directory and named for the fully qualified class name of this interface, and will be discovered using the runtime’s service provider lookup mechanism or a container specific mechanism that is semantically equivalent to it.</p>
</blockquote>
<p>通过其注释不难得知：</p>
<ol>
<li>被<code>@HandlesTypes</code>注解的接口的 <em>实现</em> 将被以参数的方式传给其方法 <code>onStartup</code></li>
<li>具体实现必须在JAR包的Spring中的 <em>META-INF/services</em> 下声明其实现。它的运行时发现机制其实是通过<code>ServiceLoader</code>实现的，具体参考官方文档<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html#Service_Provider" target="_blank" rel="external">Service Provider</a></li>
</ol>
<h2 id="SpringServletContainerInitializer"><a href="#SpringServletContainerInitializer" class="headerlink" title="SpringServletContainerInitializer"></a>SpringServletContainerInitializer</h2><h3 id="provider_u58F0_u660E"><a href="#provider_u58F0_u660E" class="headerlink" title="provider声明"></a>provider声明</h3><p>在 <em>spring-web</em> 包下的 <em>META-INF/services</em> 中定义有：</p>
<figure class="highlight"><figcaption><span>code.2-javax.servlet.ServletContainerInitializer</span></figcaption><table><tr><td class="code"><pre><span class="line">org.springframework.web.SpringServletContainerInitializer</span><br></pre></td></tr></table></figure>
<h3 id="u63A5_u53E3_u5B9A_u4E49"><a href="#u63A5_u53E3_u5B9A_u4E49" class="headerlink" title="接口定义"></a>接口定义</h3><figure class="highlight java"><figcaption><span>SpringServletContainerInitializer.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="annotation">@HandlesTypes</span>(WebApplicationInitializer.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringServletContainerInitializer</span> <span class="keyword">implements</span> <span class="title">ServletContainerInitializer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="onStartup__u5177_u4F53_u5B9E_u73B0"><a href="#onStartup__u5177_u4F53_u5B9E_u73B0" class="headerlink" title="onStartup 具体实现"></a>onStartup 具体实现</h3><figure class="highlight java"><figcaption><span>code.3-SpringServletContainerInitializer.onStartup</span></figcaption><table><tr><td class="code"><pre><span class="line">List&lt;WebApplicationInitializer&gt; initializers = <span class="keyword">new</span> LinkedList&lt;WebApplicationInitializer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (webAppInitializerClasses != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; waiClass : webAppInitializerClasses) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// servlet container传入的参数均为具体实现，而非接口或抽象类</span></span><br><span class="line">        <span class="keyword">if</span> (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers())</span><br><span class="line">            &amp;&amp; WebApplicationInitializer.class.isAssignableFrom(waiClass)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                initializers.add((WebApplicationInitializer) waiClass.newInstance());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"Failed to instantiate WebApplicationInitializer class"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 Servlet Context</span></span><br><span class="line"><span class="keyword">for</span> (WebApplicationInitializer initializer : initializers) &#123;</span><br><span class="line">    initializer.onStartup(servletContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u901A_u8FC7java_code_u521D_u59CB_u5316Servlet_Context"><a href="#u901A_u8FC7java_code_u521D_u59CB_u5316Servlet_Context" class="headerlink" title="通过java code初始化Servlet Context"></a>通过java code初始化Servlet Context</h2><p>初始化 <em>Servlet Context</em> 的工作其实是委托给了<code>WebApplicationInitializer</code>的实现类，那么我们就可以自定义其实现过程，如：</p>
<figure class="highlight java"><figcaption><span>code.4-MyWebAppInitializer.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebAppInitializer</span> <span class="keyword">implements</span> <span class="title">WebApplicationInitializer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(ServletContext container)</span> </span>&#123;</span><br><span class="line">        XmlWebApplicationContext appContext = <span class="keyword">new</span> XmlWebApplicationContext();</span><br><span class="line">        appContext.setConfigLocation(<span class="string">"/WEB-INF/spring/dispatcher-config.xml"</span>);</span><br><span class="line"></span><br><span class="line">        ServletRegistration.Dynamic dispatcher = </span><br><span class="line">        container.addServlet(<span class="string">"dispatcher"</span>, <span class="keyword">new</span> DispatcherServlet(appContext));</span><br><span class="line"></span><br><span class="line">        dispatcher.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        dispatcher.addMapping(<span class="string">"/"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们就完全取代了<code>web.xml</code>。但是，还是<code>/WEB-INF/spring/dispatcher-config.xml</code>还是XML配置，能否也用 <em>Java-Code</em> 替代呢？</p>
<p>答案是肯定的，因为Spring 3.0就支持通过注解<code>@Configuration</code>来实现以往通过XML形式配置的工作了：</p>
<figure class="highlight java"><figcaption><span>code.5-MyWebAppInitializer.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebAppInitializer</span> <span class="keyword">implements</span> <span class="title">WebApplicationInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(ServletContext container)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Create the 'root' Spring application context</span></span><br><span class="line">        AnnotationConfigWebApplicationContext rootContext =</span><br><span class="line">        <span class="keyword">new</span> AnnotationConfigWebApplicationContext();</span><br><span class="line">        rootContext.register(AppConfig.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Manage the lifecycle of the root application context</span></span><br><span class="line">        container.addListener(<span class="keyword">new</span> ContextLoaderListener(rootContext));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the dispatcher servlet's Spring application context</span></span><br><span class="line">        AnnotationConfigWebApplicationContext dispatcherContext =</span><br><span class="line">        <span class="keyword">new</span> AnnotationConfigWebApplicationContext();</span><br><span class="line">        dispatcherContext.register(DispatcherConfig.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Register and map the dispatcher servlet</span></span><br><span class="line">        ServletRegistration.Dynamic dispatcher =</span><br><span class="line">        container.addServlet(<span class="string">"dispatcher"</span>, <span class="keyword">new</span> DispatcherServlet(dispatcherContext));</span><br><span class="line">        dispatcher.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        dispatcher.addMapping(<span class="string">"/"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>以上的demo仅为简单实现，那么Spring中又是如何设计的呢？</p>
<h2 id="Spring_u4E2D_u5982_u4F55_u8BBE_u8BA1"><a href="#Spring_u4E2D_u5982_u4F55_u8BBE_u8BA1" class="headerlink" title="Spring中如何设计"></a>Spring中如何设计</h2><p>分析<code>code.5</code>，其实变化的、需要用户具体指定的内容有3块：</p>
<ol>
<li>rootConfig：根容器配置</li>
<li>dispatcherConfig：dispatcher配置</li>
<li>mapping：dispatcherServlet匹配规则</li>
</ol>
<ul>
<li>AbstractContextLoaderInitializer</li>
</ul>
<figure class="highlight java"><figcaption><span>code.6-AbstractContextLoaderInitializer.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractContextLoaderInitializer</span> <span class="keyword">implements</span> <span class="title">WebApplicationInitializer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(ServletContext servletContext)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        registerContextLoaderListener(servletContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerContextLoaderListener</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">        WebApplicationContext rootAppContext = createRootApplicationContext();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注册root ApplicationContext</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> WebApplicationContext <span class="title">createRootApplicationContext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> ApplicationContextInitializer&lt;?&gt;[] getRootApplicationContextInitializers() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>AbstractDispatcherServletInitializer</li>
</ul>
<figure class="highlight java"><figcaption><span>code.7-AbstractDispatcherServletInitializer.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDispatcherServletInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractContextLoaderInitializer</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(ServletContext servletContext)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStartup(servletContext);</span><br><span class="line"></span><br><span class="line">        registerDispatcherServlet(servletContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerDispatcherServlet</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">        WebApplicationContext servletAppContext = createServletApplicationContext();</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> WebApplicationContext <span class="title">createServletApplicationContext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> ApplicationContextInitializer&lt;?&gt;[] getServletApplicationContextInitializers() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizeRegistration</span><span class="params">(ServletRegistration.Dynamic registration)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户自定义Url匹配规则</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> String[] getServletMappings();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>AbstractAnnotationConfigDispatcherServletInitializer</li>
</ul>
<figure class="highlight java"><figcaption><span>code.8-AbstractAnnotationConfigDispatcherServletInitializer.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span></span><br><span class="line">        <span class="keyword">extends</span> <span class="title">AbstractDispatcherServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createRootApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// create root ApplicationContext</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createServletApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// create servlet ApplicationContext</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定root ApplicationContext配置文件</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Class&lt;?&gt;[] getRootConfigClasses();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定servlet ApplicationContext配置文件</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Class&lt;?&gt;[] getServletConfigClasses();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u6700_u7EC8_u914D_u7F6E"><a href="#u6700_u7EC8_u914D_u7F6E" class="headerlink" title="最终配置"></a>最终配置</h2><figure class="highlight java"><figcaption><span>code.9-WebAppInitializer.java</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebAppInitializer</span> </span><br><span class="line">    <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[] &#123; RootConfig.class &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[] &#123; WebConfig.class &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123; <span class="string">"/"</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>大家都知道<code>DispatcherServelt</code>是 <em>spring-mvc</em> 中的前端控制器。按照传统的方式，可以在<code>web.xml</code>中配置这个 <em>servlet</em> 。</p>
<p>而在 <em>Servlet 3.0</em> 以后，支持通过注解配置 <em>servlet</em>、<em>listener</em>、<em>filter</em>等，同时也支持以注解方式配置<em>servlet container</em>，达到与配置<code>web.xml</code>一样的效果。</p>
<p>这篇文章主要介绍下<em>如何在Servlet 3.0下以 Java-Code 配置Servlet Container以及Dispatcher Servlet</em>。</p>]]>
    
    </summary>
    
      <category term="Srping-MVC" scheme="http://www.xiaoyuxee.com/tags/Srping-MVC/"/>
    
      <category term="Spring" scheme="http://www.xiaoyuxee.com/categories/Spring/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我的二〇一五]]></title>
    <link href="http://www.xiaoyuxee.com/2016/01/11/my-2015/"/>
    <id>http://www.xiaoyuxee.com/2016/01/11/my-2015/</id>
    <published>2016-01-11T15:47:00.000Z</published>
    <updated>2016-01-12T16:15:49.000Z</updated>
    <content type="html"><![CDATA[<p>2015就这样过去了，而且是已经过去了11天。一直想着要认真制定下新年计划，然后记录下来，因为方向是什么比当下在做什么更重要。前几天却因为博客迟迟没有迁移过来而纠结年度计划记录在哪里… 现在博客基本达到了自己想要的样子，也该把年度计划给落地了。</p>
<p>有人说，没有回顾的计划都是自欺欺人。貌似很有稻梨，于是就静静地坐下来回顾这匆匆过去的又一年。</p>
<a id="more"></a>
<h2 id="u5F15_u5B50"><a href="#u5F15_u5B50" class="headerlink" title="引子"></a>引子</h2><p>其实我2015年是没有做年度计划的。</p>
<p>只记得那个2014年的最后一个晚上，心潮澎湃地说要跨年，新年第一天一定不能贪睡。于是第二天就起了个早直奔<a href="https://zh.wikipedia.org/zh-cn/%E5%AE%9D%E7%9F%B3%E5%B1%B1" target="_blank" rel="external">宝石山</a>看日出，无奈在高架上错过西湖大道的出口不得不到下个出口掉头重新上高架… 更无奈的是再次错过保俶路的停车场… 于是整个行程就耽误了半个多小时，上山的时候看见别人已经开始下山了。但却丝毫没有影响我的心情，因为我还是来了。站在<a href="https://zh.wikipedia.org/zh-cn/%E4%BF%9D%E4%BF%B6%E5%A1%94" target="_blank" rel="external">保俶塔</a>旁边的小山上，望着苏堤倾斜的穿过整个西湖，心中在想：我的2015应该如何度过。</p>
<p>然后最后还是没有产出一些像样的新年计划，只是在脑海中时不时浮现出那些清晰又模糊的计划或者目标。</p>
<h2 id="u56DE_u987E"><a href="#u56DE_u987E" class="headerlink" title="回顾"></a>回顾</h2><p>现在还能回忆起或者顺利地回忆起过去的一年，功劳归功于<a href="http://www.feidee.com/money/" target="_blank" rel="external">随手记</a>。因为某些原因，去年的记账还是坚持了下来（除去1、2月份，春节过后开始的）。以每个月的开销为主线，不免想起很多无从想起的事情。</p>
<ul>
<li><p><em>个人感情</em><br>将近一年的感情告一段落。离开是为了成全让对方遇到更好的彼此。坚信每一个人都有自己的优点和缺点，也肯定会有另外一个人来欣赏你、包容你然后陪你走到最后。所以没有走到最后只是因为彼此还不是那个对的人。不后悔遇见，只愿你找到那个合适的他。</p>
</li>
<li><p><em>身体健康</em><br>拖了很久，终于还是把种牙提上了日程并且经过3个月的折腾可以正常吃饭了（虽然早已不习惯，早年不用右边吃饭了…），这算今年蛮大的收获之一吧，因为有这个想法已经将近一年了。<br>健身卡一张，健身次数 <em>&lt;8</em> 次，游泳次数 <em>&lt;10</em> 次：后面因为某些原因（狗狗、感情等因素），被搁浅了…</p>
</li>
<li><p><em>财务收支</em><br>春节过后坚持记账，对自己的支出有了明确的认识。而收入明年需要跟上。<br>不完全统计全年支出<a href="/">25W+</a>，其中生活开销<a href="/">11W+</a>（以上数据均不包含1、2月份…）<br>在收支平衡上比上一年有进步。<em>这点应该是2015的最大收获吧。</em></p>
</li>
<li><p><em>远足旅行</em><br>4月份港澳游，10月份台湾行：也算把我天朝的三个未接壤的地方给去了。收获良多，感受他乡风情的同时，更加内心的目标更加清晰，坚定。<br>大于12次杭州周边游：最喜欢的是<a href="https://zh.wikipedia.org/zh-cn/%E8%8E%AB%E5%B9%B2%E5%B1%B1" target="_blank" rel="external">德清·莫干山</a>，最失望的是<a href="/">半山·仙人谷</a></p>
</li>
<li><p><em>阅读清单</em><br>买了很多书、读了很多书但全部读完且印象深刻的有<a href="http://www.books.com.tw/products/0010675560" target="_blank" rel="external">《慢慢來 人生就會不一樣》</a>、<a href="http://www.books.com.tw/products/0010687284" target="_blank" rel="external">《跳槽法則》</a>（两本书都是从台湾带回来的）。<br>两个书架已经快装不下，上周末去宜家买了个书架，书架促销性价比极高（开森ing…）。</p>
</li>
<li><p><em>休闲娱乐</em><br>电影院：12+<br>聚餐/下馆子：48+</p>
</li>
<li><p><em>个人成长</em><br>相对前两年成长较明显的一年，但还不够，因为原本也没有年度计划，此处不展开详说。<br>这应该算是2015第二大欣慰的地方吧：渐渐明白自己努力的方向，深感时间不够用，越深入越发现自己需要掌握的东西越多。</p>
</li>
<li><p><em>数码装备</em><br><a href="http://www.apple.com/cn/macbook-air/" target="_blank" rel="external">Air</a>升级到<a href="http://www.apple.com/cn/macbook-pro/" target="_blank" rel="external">Pro</a>。陪伴了自己4年多的小A退出了舞台，希望小P在其之上更助自己一臂之力。<br>入手<a href="https://en.wikipedia.org/wiki/High_fidelity" target="_blank" rel="external">HiFi</a>，使用次数 <em>&lt;10+</em> 次。<br>入手<a href="https://www.asus.com/us/Networking/RTAC68U/" target="_blank" rel="external">RT-AC68U</a>，实现家中路由<a href="https://zh.wikipedia.org/zh-cn/%E7%AA%81%E7%A0%B4%E7%BD%91%E7%BB%9C%E5%AE%A1%E6%9F%A5" target="_blank" rel="external">科学上网</a>，全家终端自由访问<a href="https://www.facebook.com/" target="_blank" rel="external">Facebook</a>。</p>
</li>
<li><p><em>陪伴家人</em><br>春节在家中待了 <em>3</em> 天，每月平均通话：<em>30</em> 分钟<br>平均带闹闹外出远足次数：<em>1</em> 次/月<br><em>这是2015做得最差的地方</em></p>
</li>
<li><p><em>英语学习</em><br>学习次数 <em>&lt;10</em>，呵呵了…</p>
</li>
</ul>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>如果2015年可以重来，你选择怎么度过（扯蛋，所以叫如果）。</p>
<p>捡重点，具体落实到2016年计划中：</p>
<ol>
<li>个人成长：制定详细的学习计划（月计划），加强深度，分模块各个击破。</li>
<li>阅读清单：同上</li>
<li>身体健康：身体是自己的，看着办</li>
<li>英语学习：这个没得商量</li>
<li>财务收支：节流，暂不开源</li>
<li>陪伴家人：重点</li>
<li>其他：视情况待定</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>2015就这样过去了，而且是已经过去了11天。一直想着要认真制定下新年计划，然后记录下来，因为方向是什么比当下在做什么更重要。前几天却因为博客迟迟没有迁移过来而纠结年度计划记录在哪里… 现在博客基本达到了自己想要的样子，也该把年度计划给落地了。</p>
<p>有人说，没有回顾的计划都是自欺欺人。貌似很有稻梨，于是就静静地坐下来回顾这匆匆过去的又一年。</p>]]>
    
    </summary>
    
      <category term="个人计划" scheme="http://www.xiaoyuxee.com/tags/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92/"/>
    
      <category term="目标管理" scheme="http://www.xiaoyuxee.com/categories/%E7%9B%AE%E6%A0%87%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://www.xiaoyuxee.com/2016/01/10/hello-world/"/>
    <id>http://www.xiaoyuxee.com/2016/01/10/hello-world/</id>
    <published>2016-01-10T03:44:08.000Z</published>
    <updated>2016-01-10T16:25:29.000Z</updated>
    <content type="html"><![CDATA[<p>国际惯例：<code>Hello World</code></p>
<p>折腾了许久，从 <a href="https://wordpress.com/" target="_blank" rel="external">wordpress</a> 到 <a href="http://jekyllrb.com/" target="_blank" rel="external">jekyll</a> ，以及国人开发的 <a href="https://www.farbox.com/" target="_blank" rel="external">farbox</a>… 待最近静下来梳理思路时问自己：<em>为何折腾，有没有必要，初衷又是什么。</em></p>
<p>屡清楚之后选择了 <a href="https://hexo.io" target="_blank" rel="external">hexo</a>。</p>
<a id="more"></a>
<h2 id="u521D_u8877"><a href="#u521D_u8877" class="headerlink" title="初衷"></a>初衷</h2><ul>
<li><p>记录生活、工作中的点点滴滴<br>其实起因是工作中的一个小需求：有个页面需要反向代理到别的团队，鉴于业务统计原因，页面中的链接必须是我们的域名，同时别人的页面还可正常访问。<br>于是就将这个<code>nginx</code>文本替换的工单提给了PE（由PE统一处理，我们没有权限… ），结果PE吭哧吭哧半天没搞定，对<code>substitutions_filter_module</code>不熟悉，最后被告知“<em>自己申请权限去改，改好了由他审批发布</em>”。</p>
<p>本来就对<code>niginx</code>感兴趣，一直没有时间折腾，索性就折腾一把。自己看文档，拉代码，编译，安装，测试。整个过程还是还是蛮有意思的，也遇到了各种问题。之后就在想，能否将这些分析问题、解决问题的思路和方法记录一下，备案的同时也给别人某种程度上的参考。</p>
</li>
<li><p>适合程序员方式的记录<br>之前在本地都在使用<a href="http://www.ulyssesapp.com" target="_blank" rel="external">Ulysess</a>，一款专注于写作的软件，支持<code>Markdown</code>、<code>Dropbox</code>同步、多种文档格式的输出等。</p>
</li>
<li><p>可托管于Github<br>无须担心备份等问题。</p>
</li>
<li><p>极简<br>记录，分享。包括呈现方式，抛弃华丽的外表，不忘初心，分享内容而非炫酷的各种Blog效果。</p>
</li>
</ul>
<h2 id="u6846_u67B6_u9009_u62E9"><a href="#u6846_u67B6_u9009_u62E9" class="headerlink" title="框架选择"></a>框架选择</h2><p>最后选择<a href="https://hexo.io" target="_blank" rel="external">hexo</a>的原因也很简单，其官方定义</p>
<blockquote>
<p>  A fast, simple &amp; powerful blog framework</p>
</blockquote>
<ul>
<li><p>速度<br>基于Node.js，支持多进程，几百篇文章几秒搞定</p>
</li>
<li><p>简单</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一条日志</span></span><br><span class="line">hexo n <span class="string">"Hell World"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发布</span></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>几条简单的命令就可完成全部过程。</p>
</li>
<li><p>易扩展<br>已经有很多成熟的插件，比如同时部署到Github和Gitcafe等</p>
</li>
</ul>
<h2 id="u6A21_u677F_u9009_u62E9"><a href="#u6A21_u677F_u9009_u62E9" class="headerlink" title="模板选择"></a>模板选择</h2><p><a href="https://github.com/pagecho/maupassant" target="_blank" rel="external">maupassant</a>，简约但不简单。 官方定义：</p>
<blockquote>
<p>A simple template with great performance on different devices.</p>
</blockquote>
<p>已支持的平台：<a href="https://github.com/pagecho/maupassant/" target="_blank" rel="external">Typecho</a>, <a href="https://github.com/pagecho/mewpassant/" target="_blank" rel="external">Octopress</a>, <a href="https://github.com/pagecho/Maupassant-farbox" target="_blank" rel="external">Farbox</a>, <a href="https://github.com/iMuFeng/maupassant" target="_blank" rel="external">Wordpress</a>, <a href="https://github.com/LjxPrime/maupassant" target="_blank" rel="external">Ghost</a>, <a href="https://github.com/tufu9441/maupassant-hexo" target="_blank" rel="external">Hexo</a>。</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="external">hexo你的博客</a></li>
<li><a href="https://www.haomwei.com/technology/maupassant-hexo.html" target="_blank" rel="external">大道至简——Hexo简洁主题推荐</a></li>
<li><a href="http://theme-next.iissnan.com/" target="_blank" rel="external">NexT - an elegant theme for hexo</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>国际惯例：<code>Hello World</code></p>
<p>折腾了许久，从 <a href="https://wordpress.com/">wordpress</a> 到 <a href="http://jekyllrb.com/">jekyll</a> ，以及国人开发的 <a href="https://www.farbox.com/">farbox</a>… 待最近静下来梳理思路时问自己：<em>为何折腾，有没有必要，初衷又是什么。</em></p>
<p>屡清楚之后选择了 <a href="https://hexo.io">hexo</a>。</p>]]>
    
    </summary>
    
      <category term="生活随笔" scheme="http://www.xiaoyuxee.com/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
